<?xml version="1.0" encoding="utf-8" ?>
<Content>
  <Element Type="Opus" Name="ASP.NET Extensibility - Workers and Threads" Short="Explore how to break through ASP.NET's boundaries" Description="Pro ASP.NET Extensibility, a book for advanced users of ASP.NET.">
    ASP.NET Extensibility
    <Element Type="Section" Name="Worker and Threads">
      Worker and Threads
      <Element Type="Text">

        <p>
          In the first chapter I looked into the handling
          of a page request, and, in particular, the application life cycle and page life
          cycle. This is the fundamental process that runs when anyone requests a page
          resource. However, Chapter 1 was a simplification of the situation—I assumed that
          only one request comes in at a time. Reality is quite different.
        </p>
        <p>
          Managing hundreds, or even thousands, of
          simultaneous requests requires advanced knowledge and skills. In this and
          subsequent chapters you will learn those skills.
        </p>
        <p>Objectives in this chapter:</p>
        <ul>
          <li>Learn how ASP.NET handles multiple requests</li>
          <li>Understand how to manage the worker processes and optimize the workload</li>
          <li>Comprehend the thread model, thread pool behavior and how to optimize its usage</li>
          <li>Learn how to build asynchronous handlers, pages, and tasks</li>
        </ul>

      </Element>
      <Element Type="Section" Name="Managing the Worker Process">
        Managing the Worker Process
        <Element Type="Text">

          <p>
            In Chapter 1 you learned about the
            worker process, w3wp.exe, which executes a request and initiates the ASP.NET
            engine processing. Managing the worker process is the key to managing high
            server demand, and keeping your applications stable and reliable.
          </p>

        </Element>
        <Element Type="Section" Name="Managing Worker Processes and AppDomains in IIS7">
          Managing Worker Processes and AppDomains in IIS7
          <Element Type="Text">

            <p>
              One of the leading Windows application
              management tools is Windows Management Instrumentation (WMI). You have probably
              used WMI to administer basic ASP.NET-related parts of IIS. It’s a well-known
              way to access worker processes while your application is running.
            </p>

          </Element>
          <Element Type="Sidebar"  SidebarType="Box">

            <header>Good Old Days: Windows Management Instrumentation</header>
            <aside>
              <p>WMI stands for Windows Management Instrumentation. If you’re unfamiliar with it, there’s a good introduction in Wikipedia at:</p>
              <ul>
                <li>http://en.wikipedia.org/wiki/Windows_Management_Instrumentation</li>
              </ul>
              <p>
                It suggests that WMI is a good tool for automating
                the management of worker processes and application domains in IIS7. It can also
                help us find a better way to customize the ASP.NET environment. IIS7 worker
                processes are spawned by the Windows Process Activation Service (WAS), using w3wp.exe.
                A worker process can contain AppDomains that are typically created to handle a request.
              </p>
            </aside>

          </Element>
          <Element Type="Text">

            <p>
              To accommodate today’s managed-code
              world, Microsoft exposed the WMI and COM method calls via .NET. Instead of invoking
              WMI directly, you can manage IIS using .NET typed classes, rather than using untyped
              strings. These classes expose a direct interface to the IIS7 management level
              and appear to be easy to use and robust.
            </p>

          </Element>
          <Element Type="Section" Name="Prerequisites">
            Prerequisites
            <Element Type="Text">

              <p>
                There are several prerequisites to writing
                sophisticated management applications using Visual Studio. First of all, IIS7
                itself is a prerequisite. No other web server currently supports these
                interfaces. To test your application it must run with elevated privileges. If
                you run the development environment on Windows Vista, you must launch Visual
                Studio with Administrator rights. An application built on such a system runs
                well on Windows Server 2008, as long as it runs with Administrator privileges.
                Once Visual Studio is running with the right account, you need to reference the
                administration assemblies in your project. There are several managed assemblies
                available in the IIS7 installation folder:
              </p>

              <p class="Query">&lt;%WinDir%&gt;\system32\inetsrv</p>

              <p>
                You will find several assemblies
                starting with the name “Microsoft.Web". Depending on what you’re planning to do,
                you’ll need one or another. For the moment, just reference all of them to
                ensure that all the examples in this chapter run properly. Here’s the list of what
                you’ll need:
              </p>
              <ul>
                <li>
                  <code>Microsoft.Web.Administration</code>
                </li>

                <li>
                  <code>Microsoft.Web.Management.Aspnet</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management.AspnetClient</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management.Iis</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management.IisClient</code>
                </li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Tasks to Manage">
            Tasks to Manage
            <Element Type="Text">

              <p>
                There are several tasks you can manage
                using the techniques described in this chapter. They will allow you to extend
                the available toolkit and customize the management of the ASP.NET environment. I
                will focus here on some of the more common tasks, but there is almost unlimited
                scope for extending the new management classes:
              </p>
              <ul>
                <li>
                  View the currently executing
                  requests for a worker process
                </li>

                <li>
                  Get the state of all worker processes
                </li>

                <li>
                  Unload a specific AppDomain, or all
                  AppDomains
                </li>

                <li>
                  Display all AppDomains and their
                  properties
                </li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Backup your Configuration">
            Backup your Configuration
            <Element Type="Text">

              <p>
                It is possible that the following
                samples will destroy or damage your IIS7 configuration. As it’s cumbersome to
                re-install your development environment after any undesirable side effects, you
                should test in a virtual machine or backup the IIS configuration of your
                production machine before you start.
              </p>
              <p>To make a backup of the configuration:</p>
              <ul>
                <li>
                  Open a command window with
                  Administrator rights
                </li>

                <li>Navigate to %WinDir%\system32\inetsrv</li>
                <li>Enter following command:</li>

                <p class="Query">            AppCmd add backup IIS7backup</p>

                <li>
                  The backup is created in the folder
                  %WinDir%\system32\inetsrv\IIS7backup
                </li>
              </ul>
              <p>
                You can use any name you like for the
                backup.
              </p>

            </Element>
            <Element Type="Image" Name="Backup command and created Backup folder with IIS7 settings">
              images/19835f0201.png
            </Element>
            <Element Type="Text">

              <p>
                The AppCmd tool has several options. The
                basic structure of the command is:
              </p>

              <p class="Query">AppCmd Command ObjectType ID Parameter</p>

              <p>
                The <i>command</i> parameter depends on
                the <i>ObjectType</i> parameter. For backup purposes the <i>ObjectType</i> is <code>Backup</code>. You can use the following commands:
              </p>
              <ul>
                <li>
                  list – shows all available backups
                </li>
                <li>
                  add – creates a new backup for the current configuration
                </li>
                <li>
                  delete – delete a backup from disk
                </li>
                <li>
                  restore – restore a backup and
                  overwrite current configuration
                </li>
              </ul>
              <p>
                The usage is straightforward. Again,
                remember to run this tool with Administrator privileges to access the IIS
                settings.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Basic tasks">
            Basic tasks
            <Element Type="Text">

              <p>
                The code in Listing 2-1 shows the
                typical structure of an IIS7 management code snippet. You can use whatever
                client environment you prefer. You could use a simple WPF (Windows Presentation
                Foundation) client to display the data in a hierarchical format (such as a
                TreeView), or perhaps well-formatted in a RichTextBox control.
              </p>

              <p>
                For the purpose of demonstrating sample
                code, a console application is a simple, satisfactory alternative. I will use
                the following generic test structure for the examples:
              </p>

            </Element>
            <Element Type="Listing" Name="Basic code structure for IIS7 administration code snippets">

              using System;
              using System.Text;
              using Microsoft.Web.Administration;

              namespace Apress.AspNetExtensiblity.IIS7Console
              {
                  static class IIS7Management
                  {

                      internal static string Method()
                      {

                          StringBuilder sb = new StringBuilder();
                                              // Code goes here
                                              return sb.ToString();
                      }
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                These static methods are invoked from the
                console’s entry point. The basis for most operations is
                the <code>ServerManager</code> class. From the
                <code>ServerManager</code> class there
                are several collections available:
              </p>
              <ul>
                <li>Applications</li>

                <li>Sites</li>

                <li>WorkerProcesses</li>

                <li>Bindings</li>

                <li>VirtualDirectories</li>
              </ul>
              <p>
                Through these collections you can reach
                the desired objects and properties for monitoring and managing IIS7. You always
                have read and write access. To save your changes, you need to explicitly call the
                <code>CommitChanges</code> method.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Get Information about the Worker Processes">
            Get Information about the Worker Processes
            <Element Type="Text">

              <p>
                Once I’ve shown you how to loop through
                each worker process on a Web server, you’ll see how to display the currently
                executing requests, process ID, and state of each worker process, as well as
                the application pool to which it belongs.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Get the State of a Worker Process">
            Get the State of a Worker Process
            <Element Type="Text">

              <p>
                The <code>WorkerProcess</code> object in the IIS7 administration has a
                <code>GetState</code> method that indicates whether a worker process is starting,
                running, or stopping. <code>WorkerProcess</code> also has
                two properties that particularly interest us: <code>ApplicationPool</code> and
                <code>ProcessId</code>. The
                <code>ApplicationPool</code> property represents the application pool to which the worker
                process belongs. The <code>ProcessId</code> property
                contains the process ID that uniquely identifies the worker process.
              </p>
            </Element>
            <Element Type="Listing" Name="Getting information about worker processes">

              internal static string ShowWorkerProcesses()
              {
                  StringBuilder sb = new StringBuilder();
                  try
                  {
                      ServerManager manager = new ServerManager();
                      foreach (WorkerProcess proc in manager.WorkerProcesses)
                      {
                          sb.AppendFormat(&quot;WorkerProcess found: {0}\n&quot;, proc.ProcessId);
                          sb.AppendFormat(&quot;\t|--AppPool : {0}\n&quot;, proc.AppPoolName);
                          sb.AppendFormat(&quot;\t|--ProcGuid: {0}\n&quot;, proc.ProcessGuid);
                          sb.AppendFormat(&quot;\t|--State   : {0}\n&quot;, proc.State.ToString());

                          foreach (ApplicationDomain appDom in proc.ApplicationDomains)
                          {
                              sb.AppendFormat(
                                  &quot;\t+--ApplicationDomain Found: {0}\n&quot;, appDom.Id);
                              sb.AppendFormat(
                                  &quot;\t\t|--AppDomPhysPath: {0}\n&quot;, appDom.PhysicalPath);
                              sb.AppendFormat(
                                  &quot;\t\t+--AppDomVirtPath: {0}\n&quot;, appDom.VirtualPath);
                          }
                      }
                      return sb.ToString();
                  }
                  catch (Exception ex)
                  {
                      return ex.Message;
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                The worker processes are exposed by the
                property <code>WorkerProcesses</code>.
                The value should match the number of w3wp.exe instances running in the Windows Task Manager.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Tip">
              <header>Tip</header>
              <aside>If there are no worker processes but IIS7 is running, open a website to force the process to launch.</aside>

            </Element>
            <Element Type="Text">

              <p>
                The properties used depend on the object
                you wish to investigate. Refer to the documentation on MSDN to get full
                descriptions of all available values.
              </p>

            </Element>
            <Element Type="Image" Name="Watching worker processes">
              images/19835f0203.png
            </Element>
            <Element Type="Text">

              <p>
                To monitor your worker processes, check the
                <code>State</code> property. The state of a process can be one of:
              </p>
              <ul>
                <li>Starting</li>

                <li>Running</li>

                <li>Stopping</li>

                <li>Unknown</li>
              </ul>
              <p>
                Why can’t the worker process have a
                state of "Stopped"? After the process has been shut down, the executable is
                disposed of and removed from memory. The worker process then disappears from the
                list of processes. Therefore, the worker is first starting, then running, and,
                if there is nothing to do, stopping. There isn’t a specific situation where the
                state <code>Unknown</code>
                appears, as the name implies. I assume that it occurs when the
                process dies unexpectedly and hangs.  
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Get Executing Requests">
            Get Executing Requests
            <Element Type="Text">

              <p>
                One exciting new feature of IIS7 is the
                ability to see the requests which are currently executing in a worker process.
                You do this with the <code>WorkerProcess.GetRequests</code> method in a manner
                very similar to the one shown above. Retrieve the worker process and invoke the <code>GetRequests</code>
                method to get the current requests.
              </p>

              <p>
                The <code>GetRequests</code>
                method requires an <code>int</code> parameter to filter
                the results for requests which have run for at least the number of milliseconds
                specified. This is very useful for displaying only long running requests. It’s a
                good idea to set the value to zero initially in order to get all requests, as
                shown in Listing 2-4.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Tip">
              <header>Tip</header>
              <aside>
                A request to test an application within the development environment can be tricky. Use the <code>Thread.Sleep</code>
                method to make the request last long enough to be caught.
              </aside>

            </Element>
            <Element Type="Text">

              <p>
                Use Windows Notepad to save the
                following text into a file called Sleep.aspx. Listing 2-3 shows the complete page for a
                request that will take a minute to execute.
              </p>

            </Element>
            <Element Type="Listing" Name="Define a page running one minute to get a long-lasting request">
              <Element Type="Text">

                &lt;% System.Threading.Thread.Sleep(60000);
                Response.Write (&quot;I'm finally finished...&quot;) %&gt;

              </Element>
            </Element>
            <Element Type="Text">

              <p>
                Running the management code, as in
                Listing 2-4, shows that the request is running and displays various properties
                for the request.
              </p>

              <Element Type="Listing" Name="Looping through some properties of a running worker process">

                internal static string ShowRequest()
                {
                    StringBuilder sb = new StringBuilder();
                    try
                    {
                        ServerManager manager = new ServerManager();
                        foreach (WorkerProcess proc in manager.WorkerProcesses)
                        {
                            foreach (Request r in proc.GetRequests(0))
                            {
                               sb.AppendFormat(&quot;Request:\n&quot;)
                                sb.AppendFormat(&quot; Hostname = {0}\n&quot;, r.HostName);
                                sb.AppendFormat(&quot; Url = {0}\n&quot;, r.Url);
                                sb.AppendFormat(&quot; Verb = {0}\n&quot;, r.Verb);
                                sb.AppendFormat(&quot; IP = {0}\n&quot;, r.ClientIPAddr);
                            }
                        }
                        return sb.ToString();
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  The console (see Figure 2-3) shows all the
                  requests currently running on available worker processes. Before running this on
                  a production system, it would be advisable to add some filter conditions to avoid
                  returning an excessive number of results.
                </p>

              </Element>
              <Element Type="Image" Name="Output shows detailed information about certain requests">
                images/19835f0202.png
              </Element>
              <Element Type="Text">

                <p>
                  Monitoring requests is not particularly
                  suited to a console application. Imagine you have some requests that don’t function
                  as expected, but the errors are infrequent and not reproducible. In this
                  situation, you could write an application to monitor a specific request and log
                  all relevant data. When the error reappears, your log file should contain
                  information enabling you to track down the error source.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name="Get Information about the Application Domains">
              Get Information about the Application Domains
              <Element Type="Text">

                <p>
                  The first time a request for an ASP.NET
                  page is received, the IIS7 managed engine module creates an application domain
                  (AppDomain) in memory. I explained this in Chapter 1. The AppDomain processes
                  requests for aspx pages, or any page that uses managed code. Unloading and
                  enumerating AppDomains is straightforward. This section shows you how to do
                  both.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name="Unloading a Specific AppDomain">
              Unloading a Specific AppDomain
              <Element Type="Text">

                <p>
                  To unload a specific AppDomain, you
                  must be able to uniquely identify it. AppDomains have three key properties: <code>Id</code>, <code>VirtualPath</code>
                  and <code>PhysicalPath</code>. One of these properties should be sufficient.
                </p>

                <p>
                  The code snippet in Listing 2-5 shows you
                  how to obtain the desired AppDomain using a  LINQ query. The nested
                  <code>from</code> statements form a join to retrieve the <code>ApplicationDomains</code> property for each running <code>
                    WorkerProcess
                  </code> object. The <code>where</code>
                  clause restricts the result to the single AppDomain defined by the given
                  <code>Id</code>. For a real-life application, this value could be a variable. We
                  saw the <code>ShowWorkerProcesses</code> method earlier in Listing 2-2.
                  It’s not required, but I’ve included it here for demonstration purposes.
                </p>

              </Element>
              <Element Type="Listing" Name="Retrieve information about the application domains">

                internal static string UnloadAppDomain(string name)
                {
                    StringBuilder sb = new StringBuilder();
                    try
                    {
                        sb.Append(ShowWorkerProcesses());
                        ServerManager manager = new ServerManager();
                        var appDomains = from proc in manager.WorkerProcesses
                                         from adc in proc.ApplicationDomains
                                         where adc.Id == &quot;/LM/W3SVC/4/ROOT&quot;
                                         select adc;

                        ApplicationDomain ad = appDomains.FirstOrDefault&lt;ApplicationDomain&gt;();

                        if (ad != null)
                        {
                            ad.Unload();
                            return name + &quot; unloaded&quot;;
                        }
                        else
                        {
                            return &quot;can't find &quot; + name;
                        }
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  Incidentally, the AppDomain’s <code>Id</code> property is a path that looks like this:
                </p>

              </Element>

              <Element Type="Listing">

                /LM/W3SVC/1/ROOT
              </Element>
              <Element Type="Text">

                <p>
                  The “1" in the path listed is
                  the site’s ID. “1" usually corresponds to the default Web site. You could find
                  any number here, depending on how many webs you have on the machine you’re
                  currently investigating.
                </p>

                <p>
                  If you generate a list of your
                  server’s AppDomains and their properties first, you’ll find the right one
                  easily (see Listing 2-2 where
                  we extracted the AppDomain instances from the currently running worker
                  processes).
                </p>

                <p>
                  However, the purpose of the
                  script was to unload a particular AppDomain. To understand what happens when
                  you unload an AppDomain, run this scenario:
                </p>
                <ul>
                  <li>Request a page from your server</li>
                  <li>
                    Watch running processes and
                    AppDomains and retrieve the properties
                  </li>
                  <li>Launch the code and unload the domain</li>
                  <li>Request the page again</li>
                  <li>Retrieve the very same information from properties</li>
                </ul>
              </Element>
            </Element>
            <Element Type="Section" Name="Unloading all AppDomains">
              Unloading all AppDomains
              <Element Type="Text">
                <p>
                  The next example unloads all
                  AppDomains. Again, I use LINQ and generic features. You don’t have to do it this
                  way, but it results in compact and highly readable code. The LINQ statement again
                  uses a nested query.
                </p>

              </Element>

              <Element Type="Listing" Name="Unload all AppDomains">

                internal static string UnloadAppDomains()
                {
                    try
                    {
                        ServerManager manager = new ServerManager();
                        Func&lt;ApplicationDomain, bool&gt; unloadFunc = new Func&lt;ApplicationDomain, bool&gt;(Unload);
                        var appDomains = from proc in manager.WorkerProcesses
                                         from adc in proc.ApplicationDomains
                                         where unloadFunc(adc) == true
                                         select adc;
                        return &quot;Unloaded &quot; + appDomains.Count() + &quot; domain(s)&quot;;
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

                private static bool Unload(ApplicationDomain appDomain)
                {
                    try
                    {
                        appDomain.Unload();
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  The unload method is encapsulated in
                  the callback function <code>Unload</code>. It takes the
                  AppDomain as a parameter of type <code>
                    ApplicationDomain
                  </code>. As before, the query starts by retrieving the worker processes and
                  the AppDomains joined to them. In the <code>where</code> clause,
                  the inline method <code>unloadFunc()</code>  is used
                  to unload the domain. The <code>Func</code> type is a
                  predefined typed delegate used to pass a parameter and retrieve a Boolean
                  result flag. The clause forces the method call to <code>Unload</code>
                  and the return value decides whether the AppDomain becomes part of
                  the result set. This leads to a direct usage of the <code>Count</code>
                  method that returns the number of successfully unloaded AppDomains.
                </p>

              </Element>
              <Element Type="Image" Name="Number of successfully unloaded AppDomains">
                images/19835f0204.png
              </Element>
            </Element>
            <Element Type="Section" Name="Enumerating AppDomains">
              Enumerating AppDomains
              <Element Type="Text">

                <p>
                  Dealing with AppDomains in a management
                  environment often starts with showing all available properties. For learning
                  purposes it makes sense to investigate the AppDomain’s properties. Listing 2-7
                  shows how to get this information.
                </p>

              </Element>
              <Element Type="Listing" Name="Show properties of AppDomains">

                internal static string ShowAppDomains()
                {
                    StringBuilder sb = new StringBuilder();
                    try
                    {
                        ServerManager manager = new ServerManager();
                        var appDomains = from proc in manager.WorkerProcesses
                                         from adc in proc.ApplicationDomains
                                         select
                                           String.Format(@&quot;Physical Path = {0}
                                                         {4}VirtualPath = {1}
                                                         {4}Process ID = {2}
                                                         {4}Is Idle = {3}&quot;,
                                                adc.PhysicalPath,
                                                 adc.VirtualPath,
                                                 adc.Id
                                                 adc.Idle,
                                                 Environment.NewLine)

                        if (appDomains.Count() == 0)
                        {
                            sb.Append(&quot;can't find AppDomains&quot;);
                        }
                        else
                        {
                            foreach (string ad in appDomains)
                            {
                                sb.AppendLine(ad);
                            }
                        }
                        return sb.ToString();
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

              </Element>
            </Element>
            <Element Type="Text">

              <p>
                The LINQ query retrieves the worker
                processes and the attached AppDomains. In the <code>select</code>
                clause, the string is constructed to simplify output. You can alter this clause
                to retrieve the specific values you desire. With this, you can monitor your
                ASP.NET environment with your custom application, without requiring Internet
                Information Services Manager Console.
              </p>

            </Element>

            <Element Type="Image" Name="Information about a running AppDomain">
              images/19835f0205.png
            </Element>
            <Element Type="Text">

              <p>
                You can compare this
                information with that available in the IIS Manager Console. Open the IIS
                Manager Console, navigate to the site and click on <i>Extended Settings</i> to
                see the settings and check against the values retrieved using the code shown
                above.
              </p>
              <p>
                When working with the <code>ApplicationDomain</code>
                object, you might see many more properties than were shown in the
                last example. This is because all settings derive from the <code>ConfigurationSettings</code>
                type, which contains several common properties that we don’t need.
                The helpful properties for an AppDomain are:
              </p>
              <ul>
                <li>
                  <code>Id</code>
                </li>
                <li>
                  <code>VirtualPath</code>
                </li>
                <li>
                  <code>PhysicalPath</code>
                </li>
                <li>
                  <code>Idle</code>
                </li>
              </ul>
              <p>
                Id returns the current internal Id of
                the AppDomain. The <code>VirtualPath</code> is as
                defined in the IIS settings; for the root path it is usually "/". The <code>PhysicalPath</code>
                is the full path to the application on local disk. The <code>Idle</code> property is
                a runtime value. It’s defined as <code>int</code>; it returns either 0 or 1, where the latter is the value for an
                idle application domain. Additional values about the worker process are
                helpful, too. You can add these easily by extending the <code>select</code> clause in this manner:
              </p>
            </Element>
            <Element Type="Listing">
              adc.WorkerProcess.ProcessId
            </Element>
            <Element Type="Text">
              <p>
                The object <code>adc</code> is of the current <code>
                  ApplicationDomain
                </code> type.
                By using a back reference to the <code>WorkerProcess</code> object, all property values
                available there can be retrieved directly.
              </p>
            </Element>
            <Element Type="Section" Name="Configuring the Worker Process">
              Configuring the Worker Process
              <Element Type="Text">
                <p>
                  Unlike classic ASP, which runs in the
                  same memory space as IIS, ASP.NET runs as a process of its own. This gives it more
                  flexibility, stability, and power. You can use the configuration file <i>machine.config</i>
                  to make the Webmaster’s job a lot easier.
                </p>
                <p>
                  I’ll take a closer look here at the
                  ASP.NET process and the attributes that we can adjust. The <i>machine.config</i>
                  file is plain XML and easy to read. As the name implies, it’s a definition at the
                  machine level. Several portions define the default values for the application
                  and the folder specific <i>web.config</i>. However, some parts can’t be
                  overwritten, and there’s no point in attempting to alter others.
                </p>
              </Element>
            </Element>
            <Element Type="Section" Name="The machine.config file">
              The machine.config file
              <Element Type="Text">
                <p>
                  As mentioned earlier, version 3.5 of the
                  .NET framework augments, rather than replaces, .NET framework 2.0. This
                  explains why the <i>machine.config</i> file is stored under the 2.0 hive. The
                  path on your machine should look similar to:
                </p>
                <p class="Query">%WinDir%\Microsoft.NET\Framework\v2.0.50727\CONFIG</p>
                <p>
                  There are several other configuration
                  files, but we’re only examining <i>machine.config</i>. Because it’s XML, you
                  can use Visual Studio to edit it. The worker process settings are stored in the
                  <code>&lt;processModel&gt;</code>
                  tag. It’s located under <code>&lt;system.web&gt;</code> and usually looks like this:
                </p>
                <p>
                  <code>&lt;processModel autoConfig="true" /&gt;</code>
                </p>
                <p>
                  Microsoft sets all common values using the
                  auto configuration option. This is good for most installations, but not all. To
                  optimize the settings, you can set the value of this attribute to false and
                  change whatever you like:
                </p>
                <p>
                  <code>
                    &lt;processModel autoConfig=&quot;false&quot; /&gt;
                  </code>
                </p>
                <p>
                  However, changing basic settings is not
                  simple and may lead to servers not responding or performing poorly. Before
                  going on, let me explain the various settings.
                </p>
              </Element>
              <Element Type="Sidebar" SidebarType="Note">
                <header>Note</header>
                <aside>
                  Changes made to the
                  &lt;processModel&gt; tag do not have immediate effect. You must restart a
                  worker process to force it to re-read the settings. To restart a worker process,
                  you can open Task Manager, right click the w3wp.exe found in the task list, and
                  kill the process. The worker process will start again automatically.
                </aside>
              </Element>
            </Element>
            <Element Type="Section" Name="Why Customize the machine.config Settings?">
              Why Customize the machine.config Settings?
              <Element Type="Text">
                <p>
                  You may wonder why and when you’re
                  supposed to change the <i>machine.config</i> settings and  the <code>>&lt;processModel&gt;</code> settings. Let’s consider the following scenario:
                </p>
                <ul>
                  <li>
                    Your network supports only one
                    application domain (AppDomain)
                  </li>
                  <li>
                    Each page causes one request (no
                    subsequent AJAX calls)
                  </li>
                  <li>
                    All requests go to the same IP
                    address
                  </li>
                </ul>
                <p>
                  In this case, the default settings are
                  very good and there is no reason to change anything. However, other specific
                  scenarios could be problematic:
                </p>
                <ul>
                  <li>Requests to many IP addresses</li>
                  <li>Frequent redirects (HTTP status code 302)</li>
                  <li>Using authentication</li>
                  <li>Using more than one AppDomain</li>
                </ul>
                <p>
                  The following section describes
                  all the <code>processModel</code>
                  parameters. (A later section, <i>Configuring the Thread Pool</i>,
                  explains this in even greater depth.)
                </p>
                <p>
                  Keep in mind that, behind the
                  scenes, IIS must handle the available resources to manage all incoming
                  requests. If the rate of incoming page requests is such that the fraction of
                  memory in use or CPU power exceeds certain levels, the default values for the <code>processModel</code>
                  parameters may not be optimal. However, setting higher values is
                  not always better as this can lead to higher resource consumption and slow down
                  even a lightly-loaded server handling simple requests. Finding the most
                  appropriate options in the parameter jungle is a challenge. 
                </p>

              </Element>
            </Element>

            <Element Type="Section" Name="A First Look Into the Attributes">
              A First Look Into the Attributes
              <Element Type="Text">

                <p>
                  Table 2-1 lists the <code>processModel</code>
                  attributes available. The description column indicates the purpose
                  of each attribute and where to find more information.
                </p>

              </Element>
              <Element Type="Table" Name="Settings available for the &lt;processModel&gt; tag (excerpt)">
                <table>
                  <tr>
                    <th>Attribute</th>
                    <th>Default</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>
                      <code>clientConnectedCheck</code>
                    </td>
                    <td>00:00:05 (five seconds)</td>
                    <td>Once a request has been waiting in the queue for this long, ASP.NET checks whether the client is still connected.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>cpuMask</code>
                    </td>
                    <td>0xffffffff</td>
                    <td>
                      Specifies
                      which CPU of a multiprocessor system runs ASP.NET processes. The value is a
                      bitmask where each bit represents a CPU. Assume you set the value to 0xa, which
                      is 1010 in binary form. CPUs are numbered beginning with 0, and read from right
                      to left. For this value, CPUs 1 and 3 are qualified to run ASP.NET threads and CPUs
                      0 and 2 are not.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>enable</code>
                    </td>
                    <td>true</td>
                    <td>Enables or disables the process model.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>idleTime</code>
                    </td>
                    <td>Infinite</td>
                    <td>
                      The period
                      of inactivity (in time format hh:mm:ss), after which the worker process ends.
                      (For example, a value of “00:20:00" will cause the worker process to shut down
                      twenty minutes after the last request is concluded.) “Infinite" prevents the
                      worker process from stopping at all.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>logLevel</code>
                    </td>
                    <td>Errors</td>
                    <td>The quantity of errors written to the event log. Choose from “All", “Errors", or “None".</td>
                  </tr>
                  <tr>
                    <td>
                      <code>maxAppDomains</code>
                    </td>
                    <td>2000</td>
                    <td>
                      The number of application domains in one process. The default value, 2000, is the maximum
                      allowed. Lower values are appropriate for hosting providers, for instance.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>maxIoThreads</code>
                    </td>
                    <td>20</td>
                    <td>
                      The maximum
                      number of threads for I/O operations, counted on a per-CPU basis. Must be greater than or equal to <code>minFreeThreads</code> in
                      <code>&lt;httpRuntime&gt;</code> settings. Allowed range is between 5 and 100. See the section
                      “Understanding and using threads" in this chapter for more information.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>maxWorkerThreads</code>
                    </td>
                    <td>20</td>
                    <td>
                      The maximum number of worker threads, counted on a per-CPU basis. Must be greater than
                      or equal to <code>minFreeThreads</code> in
                      <code>&lt;httpRuntime&gt;</code> settings. Allowed range is between 5 and 100. See section
                      “Understanding and using threads" in this chapter for more information.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>memoryLimit</code>
                    </td>
                    <td>60</td>
                    <td>
                      The maximum allowed memory size as a percentage of total system memory that one worker
                      process is allowed to consume. Beyond this limit, a new worker process is launched and subsequent requests are redirected to this one.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>minIoThreads</code>
                    </td>
                    <td>1</td>
                    <td>The minimum number of I/O threads. See section “Understanding and using threads" in this chapter for more information.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>minWorkerThreads</code>
                    </td>
                    <td>1</td>
                    <td>The minimum number of worker threads. See section “Understanding and using threads" in this chapter for more information.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>username</code>, <code>password</code>
                    </td>
                    <td>AutoGenerate</td>
                    <td>The account used to run the worker process.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>pingFrequency</code>
                    </td>
                    <td>Infinite</td>
                    <td>
                      The time interval in hh:mm:ss format used to ping the worker process to get its state.
                      If the worker process is not running it is restarted.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>pingTimeout</code>
                    </td>
                    <td>Infinite</td>
                    <td>The time, also in hh:mm:ss format, waiting for a response to a ping request. After a ping timeout is detected, the process is restarted.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>requestLimit</code>
                    </td>
                    <td>Infinite</td>
                    <td>The number of requests a single worker process can handle. Beyond this value a new worker process starts.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>requestQueueLimit</code>
                    </td>
                    <td>5000</td>
                    <td>The number of requests allowed in the queue. Any request beyond this limit receives the HTTP error 503 “Server Too Busy" response.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>responseDeadlockInterval</code>
                    </td>
                    <td>00:03:00 </td>
                    <td>
                      The time period (again in hh:mm:ss format) allowed for the worker process to respond to a queued request. After the time period expires, the worker process
                      is restarted. The default is three minutes.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>restartQueueLimit</code>
                    </td>
                    <td>10</td>
                    <td>
                      After a nonstandard (unexpected) termination of the worker process, incoming requests are queued, waiting for the worker process to become available. The value
                      specifies the number of requests queued.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>serverErrorMessageFile</code>
                    </td>
                    <td>-</td>
                    <td>
                      A file path (either absolute or relative to the <i>machine.config</i> file path) for a file containing the error message to send to the client when a fatal
                      error occurs. If no file is present or the attribute is not set, the string “Server unavailable" is sent. This is the default setting.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>shutdownTimeout</code>
                    </td>
                    <td>00:00:05</td>
                    <td>The time the worker process is allowed to take when shutting the process down. If this time interval is exceeded, the worker process is forcibly terminated.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>timeout</code>
                    </td>
                    <td>Infinite</td>
                    <td>If a worker process is not responding, ASP.NET launches a new one after the specific period is elapsed.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>webGarden</code>
                    </td>
                    <td>False</td>
                    <td>
                      A flag which indicates that the attribute cpuMask is being used. If False (default) this means that all CPU cores are available for worker processes and the
                      operating system decides which CPU will handle the next request.
                    </td>
                  </tr>
                </table>
              </Element>
            </Element>
          </Element>
          <Element Type="Section" Name="Additional Settings Outside the ProcessModel Tag">
            Additional Settings Outside the ProcessModel Tag
            <Element Type="Text">

              <p>
                The <code>&lt;processModel&gt;</code>
                tag  attributes control most of the relevant settings. However,
                there are more tags where we can refine the configuration. One important setting
                is shown below:
              </p>

            </Element>
            <Element Type="Listing">

              &lt;system.net&gt;
                &lt;connectionManagement&gt;
                  &lt;add address=&quot;&quot; maxconnection=&quot;100&quot; /&gt;
                &lt;/connectionManagement&gt;
              &lt;/system.net&gt;

            </Element>
            <Element Type="Text">

              <p>
                This does not impact your client
                connections but controls the connections you make from your application to
                other servers, such as fetching RSS feeds or using web services on another
                server. The default for the attribute <code>maxconnection</code>
                is 2, which is obviously too low. It means you cannot make more
                than two simultaneous connections to an IP address, from your web application.
                In the sample above the value is set to 100.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Specific Tasks">
            Specific Tasks
            <Element Type="Text">

              <p>
                Using these settings, you can perform
                specific tasks. The following sections explain how to use the attributes to:
              </p>
              <ul>
                <li>Recycle the worker process</li>
                <li>Shut down the worker process</li>
                <li>Check if the client is still connected</li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Recycling the Worker Process">
            Recycling the Worker Process
            <Element Type="Text">

              <p>
                A common task configured in this manner
                is the recycling of the process. This generally improves the stability and
                reliability of your web application. There are five ways to recycle a process
                using the attributes <code>timeout</code>,
                <code>requestLimit</code>,
                <code>memoryLimit</code>,
                <code>responseDeadlockInterval</code>
                , and the pair <code>pingFrequency</code>/
                <code>pingTimeout</code>
                . They are explained one by one below:
              </p>
              <ul>
                <li>timeout=&quot;48:00:00&quot;  </li>
              </ul>
              <p>
                This involves the <code>timeout</code>
                attribute, which simply creates a new process after the specified
                time interval elapses. For example, the above setting will start a new process
                after 48 hours, or two days. The first request causes the timer to start.
              </p>
              <ul>
                <li>requestLimit=&quot;1000&quot;  </li>
              </ul>
              <p>
                Another way is to use the <code>requestLimit</code>
                attribute and an Integer value. A value of 1,000 will start a new
                process after 1,000 requests have been made. This can be useful if your web
                server’s performance degrades after a set number of requests.
              </p>
              <ul>
                <li>memoryLimit=&quot;30&quot;  </li>
              </ul>
              <p>
                A third way is to let your system watch
                how much memory the process is consuming. In the above example, the attribute <code>
                  memoryLimit
                </code>
                is set to 30% of the total system memory. Once the limit is
                reached, the process is killed, a new one is created, and all existing requests
                are reassigned to the new process. This is helpful when you have a memory leak.
              </p>
              <ul>
                <li>responseDeadlockInterval=&quot;00:02:00&quot; </li>
              </ul>
              <p>
                A fourth approach is to use the <code>responseDeadlockInterval</code>
                attribute. The time setting of two minutes will restart the process
                if there are requests in the queue and if there have been no responses for the
                last two minutes.
              </p>
              <ul>
                <li>pingFrequency=&quot;00:00:30&quot; </li>
                <li>pingTimeout=&quot;00:00:05&quot; </li>
              </ul>
              <p>
                The final method for recycling the
                process is to use the <code>pingFrequency</code> and
                <code>pingTimeout</code>
                attributes in tandem. The system pings the process at the
                <code>pingFrequency</code>
                interval, and restarts it if there is no response within the
                <code>pingTimeout</code> time interval.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Shutting Down the Process">
            Shutting Down the Process
            <Element Type="Text">

              <p>
                There are two ways of shutting down the worker
                process.
              </p>
              <ul>
                <li>idleTimeout=&quot;00:20:00&quot; </li>
              </ul>
              <p>
                The first way uses the <code>idleTimeout</code>
                attribute. If the server has not served any requests for 20 minutes
                (in this example), then it automatically shuts down the process. If a new request
                comes in, a new process is started automatically. This might be useful if you experience
                long periods of inactivity. The server can then handle other tasks better
                because there is more free memory.
              </p>
              <ul>
                <li>shutDownTimeout=&quot;00:00:10&quot; </li>
              </ul>
              <p>
                The second way is by using the <code>shutDownTimeout</code>
                attribute. This is used as a last resort after  the worker process
                tries to shut down gracefully and fails. In this case, after the time set here
                has passed, a low level kill command is performed on the process to ensure its
                termination. This is useful in situations where the process has crashed and is
                no longer responding. The setting shown will force a kill after ten seconds.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name="Checking if the client is still connected">
            Checking if the client is still connected
            <Element Type="Text">
              <p>
                This is useful for eliminating unwanted
                requests from the queue.
              </p>
              <ul>
                <li>clientConnectedCheck=&quot;00:00:10&quot; </li>
              </ul>
              <p>
                Users can become impatient. If your web
                server is slow to respond to their requests, they might click on the same link
                many times. Even if only the last request is returned to them, the server will
                process all the previous ones. Furthermore, if the user abandons their session
                with your server, the queue from that user will remain. In the example above, the
                server will check each request at ten seconds intervals after it has entered
                the queue, to ensure that the user who made it is still connected. If the user
                is not, the server discards that request.
              </p>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Understanding and Using Threads">
        Understanding and Using Threads
        <Element Type="Text">
          <p>In ASP.NET, threads are like magic.</p>
          <p>
            Threads are well-known and easy to
            program using .NET techniques. However, in ASP.NET, threading is handled behind
            the scenes and consequently regarded by some developers as unimportant. This
            common misunderstanding of threading can cause poor performance, unpredictable
            behavior, and, in the end, unreliable applications.
          </p>
        </Element>
        <Element Type="Section" Name="ASP.NET Thread Usage on IIS">
          ASP.NET Thread Usage on IIS
          <Element Type="Text">
            <p>
              Threading in ASP.NET is complicated by
              the various changes Microsoft applied over the years with each new version of
              IIS. As we saw in Chapter 1, IIS plays a major part in ASP.NET’s request
              processing. Because of the co-existence of IIS6 and IIS7, I will explain firstly
              how threads are handled in IIS6, and then the changes in threading introduced
              with IIS7.
            </p>
            <p>
              You may also think of other hosting
              capabilities ASP.NET supports. Because threading has a direct and explicit
              relation to multiple requests and high workload, other environments, such as
              Visual Studio’s integrated web server, do not handle threads in any special way
              worth discussing.
            </p>

          </Element>
          <Element Type="Section" Name="Thread Usage with IIS6">
            Thread Usage with IIS6
            <Element Type="Text">
              <p>
                Each request from the outside world to
                the web server is handed over to an I/O thread on IIS. This thread comes from the
                CLR (Common Language Runtime) ThreadPool and returns the status “Pending" to
                IIS. Having passed the work on to the new thread, IIS is now free to service
                other requests, such as requests for static resources.
              </p>
              <p>
                The CLR ThreadPool works like a
                queue. It can adjust itself according to the actual workload. This means that the
                situation depends on the frequency of incoming requests and the ability of the processor
                workload to respond to each request. There are two extreme situations you need
                to take care of.
              </p>
              <p>
                Firstly, you might receive many
                simultaneous requests that are processed quickly. In this case, the ThreadPool will
                attempt to run only 1 or 2 threads per CPU to ensure a very low latency (waiting
                time).
              </p>
              <p>
                Secondly, you might receive a
                few requests where one is processor intensive and somewhat long-running.
                Additional incoming requests will cause more threads to be spawned per CPU. The
                processing time will always be longer in this scenario.
              </p>
              <p>
                A queue is a clever way to
                avoid allocating a lot of memory for each request, before processing starts and
                memory expensive objects such as <code>HttpRequest</code> are
                created. Keep in mind that the thread queue is in native memory and has no
                overhead caused by managed code components. Once a thread is ready for processing,
                we leave the unmanaged world and start working completely within the managed code
                realm.
              </p>
              <p>
                The ThreadPool queue is not the
                only way to handle a lot of incoming requests. Within each AppDomain there are
                ways to handle requests that exceed the number of available threads. If there
                is lot of latency, the ThreadPool starts growing and launches more active
                threads. However, there are physical limitations; either the system runs out of
                threads, or the available memory restricts the number of threads.
              </p>
            </Element>
            <Element Type="Sidebar" SidebarType="Note">
              <header>Note</header>
              <aside>default the ThreadPool has a limitation of 25 worker threads per CPU and 1000 I/O completion threads.</aside>
            </Element>
            <Element Type="Text">
              <p>
                ASP.NET sets its own limits to
                ThreadPool usage. If this limit is exceeded, incoming requests are still
                handled but another queue is now built on the application level and performance
                becomes significantly worse. You can control the settings with the following
                parameters of the <code>&lt;httpRuntime&gt;</code> tag:
              </p>
              <ul>
                <li>
                  <code>minFreeThreads</code>
                </li>
                <li>
                  <code>minLocalRequestFreeThreads</code>
                </li>
              </ul>
              <p>
                Performance Counters are widely
                used in Windows to monitor a system running with high workload. To observe the
                internal behavior of the ThreadPool you can use the following counter: “ASP.NET
                Applications\Requests in Application Queue".
              </p>
              <p>
                Any value but zero shows that
                there is a performance problem on that system, as it indicates that the
                ThreadPool has at some time run out of threads.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Managing the ThreadPool">
            Managing the ThreadPool
            <Element Type="Text">

              <p>
                Usually the ThreadPool does not require
                managing, because few sites exceed the default limitations. Additionally, the
                <code>autoConfig</code>
                settings allow the ASP.NET engine to optimize behavior as much as
                possible. However, maintaining an ASP.NET system that is running near its limits
                is the goal of this book. If you experience performance issues, it’s time to explore
                manual intervention. The auto settings assume that the number of concurrently
                executing requests per CPU is twelve. An application with high latency might
                require higher values.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Thread Usage with IIS7">
            Thread Usage with IIS7
            <Element Type="Text">

              <p>
                In chapter 1, I discussed IIS7 and
                integrated mode several times. As mentioned earlier, the differences between
                IIS7 and IIS6 are significant for basic page request processing.
              </p>
              <p>
                First of all, the queues built
                on the application level are gone, due to poor performance. The biggest difference is that IIS6
                restricts the number of threads, while IIS7 restricts the number of requests.
                Each thread in IIS6 handles a request and this—indirectly—limits the number of
                requests handled in parallel. IIS7 is able, due to the tight integration of
                ASP.NET within IIS7, to directly restrict the number of requests. It is when
                you employ asynchronous processing that this makes a difference. Although the
                processing pipeline is usually synchronous (see Chapter 1), both, Handlers and
                Modules, can be set up to run asynchronously. I’ll explain this, with examples,
                later in this chapter.
              </p>

              <p>
                For requests that are processed
                synchronously, the number of threads equals the number of requests, as each
                request runs in a single thread. If the processing is asynchronous, the number of
                threads may differ from the number of requests.
                Imagine that an incoming
                request starts processing and is running a long lasting action. The thread is
                handed over to ASP.NET and IIS accepts the next incoming request. This leads to
                more concurrently running requests than threads. ASP.NET gets the request as
                incoming IIS I/O thread. The CLR ThreadPool is immediately asked to create and
                start a new thread and this thread becomes responsible for this very request.
                As quickly as it starts, it returns with status of “Pending". After this, IIS
                checks the number of requests currently executing. If this value is too high,
                the next request is put in a process-wide global queue. This queue is in native
                code within IIS7.

              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Configuring the ThreadPool">
            Configuring the ThreadPool
            <Element Type="Text">

              <p>
                In the <code>&lt;processModel&gt;</code> configuration settings are the following parameters:
              </p>
              <ul>
                <li>
                  <code>autoConfig</code>
                </li>
                <li>
                  <code>maxWorkerThreads</code>
                </li>
                <li>
                  <code>maxIoThreads</code>
                </li>
                <li>
                  <code>minWorkerThreads</code>
                </li>
                <li>
                  <code>minIoThreads</code>
                </li>
              </ul>
              <p>
                The settings for IIS6 <code>minFreeThreads</code> and <code>minFreeThreads</code> in the <code>httpRuntime</code>
                tag are still there, but they do nothing. They are there merely for
                backwards compatibility. But where can you find the settings for IIS7? With
                .NET 3.5 SP1 the settings become available in web.config, as shown below:
              </p>
              <pre>
                &lt;system.web&gt;
                  &lt;applicationPool maxConcurrentRequestsPerCPU=&quot;12&quot;
                                  maxConcurrentThreadsPerCPU=&quot;0&quot;
                                  requestQueueLimit=&quot;5000&quot;/&gt;
                &lt;/system.web&gt;
              </pre>
            </Element>
            <Element Type="Text">
              <p>
                The <i>web.config</i> settings
                override the settings in the Registry mentioned in the footnote.
              </p>

              <p>
                They are not values that you
                would change frequently. You might experiment with different quantities, but
                the default is usually appropriate. The current settings are a compromise
                between requests for static resources such as images, and dynamic resources such
                as aspx pages.
              </p>

              <p>
                In chapter 6, I’ll explain the
                extensibility concepts of resource management. This includes the creation of
                design time expressions to retrieve resources. It’s possible to suppress code
                compilation when your aspx pages consist solely of declarative markup,
                resources, and expressions. This is a way to optimize overall system
                performance under particular circumstances.
              </p>
              <p>
                Now, you could try setting the
                number of threads per request to 0. If you have only static requests and no (or
                very few) dynamic ones, and if these dynamic requests are fast due to
                such
                techniques
                , this might
                improve performance. Imagine that the requests are now being executed within
                the IIS I/O thread and that there is no handover procedure to the CLR
                ThreadPool. Less overhead leads to faster resource processing.
              </p>

              <p>
                The opposite scenario appears
                when you have many heavily asynchronous operations. In this case, the limit of twelve
                threads might be too low. Imagine a scenario you’ll probably work with: Ajax
                enabled applications. These applications have fewer page requests but many
                background tasks created by JavaScript/web service pairs. This is heavily asynchronous
                and a single webpage can send large numbers of such requests. If you look into
                browser-based Outlook clients or Word-like text processing interfaces, you’ll
                see that a lot of background work happens even when the user merely moves the mouse
                pointer. Settings of up to
                several thousand are possible in order to handle many simple requests. 5000 is
                the limit, without making changes elsewhere in the system.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Server Too Busy">
            Server Too Busy
            <Element Type="Text">

              <p>
                You might be wondering when and why the
                “Server Too Busy" status is sent to the client. This is HTTP status error 503
                and appears when the limit of concurrent requests exceeds the default value of
                5000. The actual value is exposed by the “ASP.NET/Requests Current" performance
                counter.
              </p>

              <p>
                See the section “Install a Performance
                Counter" for details on how to monitor and log such values and discover what is
                happening to your server at any given moment.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Tune the threading">
          Tune the threading
          <Element Type="Text">
            <p>
              The previous explanations might
              discourage you from changing the settings. However, they’re worth exploring
              when performance issues arise or strange errors occur. This section shows some
              solutions for the following error messages:
            </p>
            <ul>
              <li>A process serving application pool ‘name’ exceeds time limits during shut down</li>
              <li>System.InvalidOperationException: There are not enough free threads in the ThreadPool object to complete the operation.</li>
              <li>HttpException (0x80004005): Request timed out.</li>
            </ul>
            <p>
              To solve the problems above, try the
              following:
            </p>
            <ul>
              <li>Limit the number of requests that can execute at the same time to approximately twelve per CPU. This limit works well for most applications.</li>
              <li>Permit web service callbacks to freely use threads in the ThreadPool. </li>
              <li>
                Select an appropriate value for the <code>maxconnections</code> attribute. Base your selection on the number of IP addresses and AppDomains that are used (more details follow).
              </li>
            </ul>

          </Element>
        </Element>
        <Element Type="Section" Name="Tuning Task by Task">
          Tuning Task by Task
          <Element Type="Text">

            <p>
              This section gives some examples of how
              and when to change the default settings of the following values:
            </p>
            <ul>
              <li>maxWorkerThreads </li>
              <li>minWorkerThreads </li>
              <li>maxIoThreads </li>
              <li>minFreeThreads </li>
              <li>minLocalRequestFreeThreads </li>
              <li>maxconnection </li>
              <li>executionTimeout </li>
            </ul>

          </Element>
        </Element>
        <Element Type="Section" Name="Set maxWorkerThreads and maxIoThreads">
          Set maxWorkerThreads and maxIoThreads
          <Element Type="Text">

            <p>
              ASP.NET uses the following two
              configuration settings to limit the number of worker threads and completion
              threads used:
            </p>

          </Element>
          <Element Type="Listing">

            &lt;processModel maxWorkerThreads=&quot;20&quot; maxIoThreads=&quot;20&quot;&gt;

          </Element>
          <Element Type="Text">
            <p>
              The <code>maxWorkerThreads</code> attribute and the <code>
                maxIoThreads
              </code> attribute are
              implicitly multiplied by the number of CPUs. In the example, the maximum number
              of worker threads is 40 if you have a dual-core processor.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set minFreeThreads and minLocalRequestFreeThreads">
          Set minFreeThreads and minLocalRequestFreeThreads
          <Element Type="Text">

            <p>
              ASP.NET also contains the following
              configuration settings which determine how many worker threads and completion
              port threads must be available to start a remote request or a local request:
            </p>

          </Element>
          <Element Type="Listing">

            &lt;httpRuntime minFreeThreads=&quot;8&quot; minLocalRequestFreeThreads=&quot;8&quot;&gt;

          </Element>
          <Element Type="Text">
            <p>
              If there are insufficient threads
              available, the request is queued until sufficient threads are free to handle
              the request. Therefore, ASP.NET will not execute more than the following number
              of requests at the same time:
            </p>

            <p class="Query">(maxWorkerThreads  numCPUs ) - minFreeThreads</p>

            <p>
              The <code>minFreeThreads</code> parameter and the <code>
                minLocalRequestFreeThreads
              </code> attributes are not implicitly multiplied by the number of CPUs.
              Assuming you have four CPUs, the formula given equals 24 parallel requests ((8
              x 4) – 8).
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set minWorkerThreads">
          Set minWorkerThreads
          <Element Type="Text">

            <p>
              ASP.NET also contains a configuration
              setting for the number of worker threads to be made available immediately to
              service a remote request.
            </p>

          </Element>
          <Element Type="Listing">

            &lt;processModel minWorkerThreads=&quot;1&quot;&gt;
          </Element>
          <Element Type="Text">

            <p>
              Threads that are controlled by
              this setting can be created at a much faster rate than worker threads that are
              created from the CLR’s default capabilities.
            </p>

            <p>
              Requests may suddenly fill the
              request queue due to a slow-down on a back end server, a sudden burst of
              requests from the client end, or something similar that would cause a sudden
              rise in the number of requests in the queue.
            </p>

            <p>
              The default value for the <code>minWorkerThreads</code> parameter is
              1. Microsoft recommends that you set the value for the
              <code>minWorkerThreads</code> parameter to half of the <code>
                maxWorkerThreads
              </code> value. By default, the <code>
                minWorkerThreads
              </code> parameter is implicitly multiplied by the number of CPUs.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set maxconnection">
          Set maxconnection
          <Element Type="Text">

            <p>
              The <code>maxconnection</code> attribute determines how many connections can be made to a specific
              IP address. The setting was mentioned before, but here is a more complex
              scenario:
            </p>

          </Element>
          <Element Type="Listing">

            &lt;connectionManagement&gt;
                &lt;add address=&quot;&quot; maxconnection=&quot;2&quot;&gt;
                &lt;add address=&quot;10.6.205.84&quot; maxconnection=&quot;20&quot;&gt;
            &lt;/connectionManagement&gt;

          </Element>
          <Element Type="Text">

            <p>
              The <code>maxconnection</code> setting applies at the AppDomain level. Consequently, only two
              connections (by default) can be made to a specific IP address from each
              AppDomain in your process.
            </p>
            <p>
              In this example, all IP addresses
              accept two connections, except for the specified one at 10.6.205.84, which accepts
              20.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set executionTimeout">
          Set executionTimeout
          <Element Type="Text">

            <p>
              ASP.NET uses the following
              configuration setting to limit the request execution time (in seconds):
            </p>

          </Element>
          <Element Type="Listing">

            &lt;httpRuntime executionTimeout=&quot;90&quot;/&gt;

          </Element>
          <Element Type="Text">
            <p>
              This refers to the <code>Server.ScriptTimeout</code> property exposed by the
              <code>HttpServer</code>
              object. If you increase the value of the <code>executionTimeout</code> attribute, you may
              have to also modify the <code>responseDeadlockInterval</code> attribute of the
              <code>&lt;processModel&gt;</code>
              tag.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name="Install a Performance Counter">
          Install a Performance Counter
          <Element Type="Text">
            <p>
              To monitor the current workload, you can
              use a Performance Counter. Open the <i>Reliability and Performance Monitor </i>tool
              (PerfMon) by entering <i>PerfMon</i> in the <i>Run</i> window. Install the
              counter using these steps:
            </p>
            <ol>
              <li>1. Click on “Performance Monitor" in the tree view.</li>
              <li>2. Right click and choose “New" and then “Data Collector Set".</li>
            </ol>
          </Element>
          <Element Type="Image" Name="Install new data collection using the Performance Monitor tool">
            images/19835f0210.png
          </Element>
          <Element Type="Text">
            <ol start="3">
              <li>
                Give the collection an appropriate name
                (such as “MonitorIIS") and click “Next".
              </li>
              <li>
                Choose a directory in which the data is to
                be saved. The default path is %systemdrive%\PerfLogs\Admin\MonitorIIS, if you have
                named the collection “MonitorIIS". Click “Next".
              </li>
              <li>
                In the last step, you can choose an
                account with which to run the counter. This is, by default, the current
                account. If you’re logged on as Administrator, it’s fine. Otherwise, select an
                appropriate account by clicking on “Change".
              </li>
              <li>
                Finish the wizard with the “Finish"
                button.
              </li>
            </ol>
            <p>
              You can now open your collection within
              the object’s tree view at the left and navigate the path to Reliability and
              Performance &gt; Data Collector Sets &gt; User Defined &gt; MonitorIIS. There
              is a default entry here named “System Monitor Log". You can modify this or add
              a new data collector. Let’s add a new one to demonstrate the process. Right
              click on the leaf entry in the tree named MonitorIIS and choose New &gt; Data
              Collector. A wizard launches and asks for a name and collection type. Name it
              “IISRequest" and choose Performance counter data collector as the type.
            </p>
          </Element>
          <Element Type="Image" Name="Add a new Data Collector">
            images/19835f0211.png
          </Element>
          <Element Type="Text">
            <p>
              Click on “Next" to add the
              counter. On the wizard’s next screen, choose “Add…" and search for the counter.
              In the left hand area you’ll find the Available counters group. Search for the section
              “ASP.NET Application" and expand it. The list is sorted alphabetically. Scroll
              down to “Requests In Application Queue". In the “Instances of selected object"
              group, you’ll find all applications. Accept the default selection __Total__ to view
              all requests. Click “Add&gt;&gt;" and “OK". The monitor begins to watch the
              counter and saves the results in the file chosen.
            </p>
            <p>
              To view the results, open the
              path Reliability and Performance &gt; Reports &gt; User Defined &gt; MonitorIIS
              &gt; IISRequest. It might take some time to load the results, depending on
              workload and settings. There are several ways to modify the counter to bind it
              to specific events. For example, you could add a scheduler to run the counter
              at a specific time. For instance, if you experience problems between 1 and 2
              a.m. on your server, it doesn’t make sense to run the tool the whole day and
              collect an unnecessarily large amount of data.
            </p>
            <p>
              You can define stop conditions
              based on time frame or the size of the log file. You can also launch a task
              when the scheduler stops. Depending on the resources of the server you could
              run an application that automatically analyses the content, sending the log
              file to an email address, or just copying it to another location.
            </p>
            <p>
              This short description does not
              cover the Reliability and Performance Monitor tool in all its glory. It’s just
              a “teaser" so that you know there are powerful tools available to monitor a
              server and find bottlenecks, failures and performance loss easily. You can also
              gather hard data to confirm a problem, find a solution, and validate that your
              solution fixes the problem.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name="Threading and Asynchronous Operations">
          Threading and Asynchronous Operations
          <Element Type="Text">
            <p>
              For most scenarios, the internal thread
              handling is well-designed and functional. However, there are situations where
              you reach the limits of the default settings. In particular, if a site comes
              under pressure from too many requests, the internal thread pool can run out of
              threads and the server will no longer respond as expected. I’ll discuss several
              techniques for overcoming this. I’ll consider how the common language runtime thread pool
              is used by ASP.NET to service requests, as well as looking into the pooling
              mechanisms used for handlers, modules, and applications.
            </p>
            <p>
              I’ll also show the threading usage independent
              of other techniques and the asynchronous processing of requests using internal
              features to solve common issues.
            </p>
          </Element>
          <Element Type="Section" Name="Threading in ASP.NET">
            Threading in ASP.NET
            <Element Type="Text">
              <p>
                To efficiently service multiple client
                requests, web servers make extensive use of concurrency by launching multiple processes
                and spawning multiple threads to service requests. Considering the construction
                and behavior of the ASP.NET engine, it seems that developers need not concern
                themselves with threading at all, as the challenging aspects are handled
                internally. This is correct for most scenarios; page requests are serviced on
                the same thread and a separate instance is created to service each new request.
                However, there are scenarios where you reach the limits of this model—as every
                model has limits—and need to extend the behavior.
              </p>

              <p>
                First of all, a clear understanding of
                the internal behavior is required. Some parts have been explained in the
                previous sections but I will repeat it from the perspective of threading. The
                process-wide CLR thread pool services requests. The thread pool size is set to
                25 worker threads and 25 I/O threads by default. Recall the <code>&lt;processModel&gt;</code>
                settings explained already:
              </p>
              <pre>
                &lt;processModel enable=&quot;true&quot;
                              maxWorkerThreads=&quot;25&quot;
                              maxIoThreads=&quot;25&quot; /&gt;
              </pre>
              <p>
                As explained in chapter 1, for each
                incoming request an instance of the type <code>HttpApplication</code> is created. To avoid
                reallocating applications and modules, each AppDomain holds a pool of applications and modules. The size of this pool is also
                25—that means that 25 requests can be handled per worker process.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name="The Need for Asynchrony">
            The Need for Asynchrony
            <Element Type="Text">
              <p>
                Imagine that you need to exclusively
                request a resource. As long as one person is using an application this is not a
                problem. However, web applications are typically employed by many, if not
                thousands, of concurrent users. The thread pool and thread handling design
                allows several requests to be executed in parallel to improve the user’s
                experience when using a web application.
                Limiting the number of threads is
                important in order to allow more than one request per CPU or core.
                Creating a
                vast number of threads can cause a system to a grind to a halt.
              </p>
              <p>
                However, a request can launch
                different kinds of tasks. Processing a page and sending resources to the client
                is the most common action. Requesting data from a database, RSS feed, or web
                service is another.  Requesting data can be time consuming, rather than processor
                intensive. What happens then? The number of threads in the thread pool quickly reaches
                its limit and subsequent requests are not handled as expected. Despite this,
                the CPU is only idling. As you learned in the previous sections, the settings
                allow you to change the number of concurrent threads. But this is not a solution
                either, as your system has to handle both kinds of requests: short-lived
                requests for resources and long running queries against other servers.
              </p>
              <p>
                To make things clearer, look at
                Listing 2-8. It delays a request while demanding little from the CPU. It displays
                the thread ID to show whether or not a new thread is created to handle the
                request.
              </p>
            </Element>
            <Element Type="Listing" Name="A simple page which slows down a request (Threading/SlowThread.aspx)">
              &lt;%>@ Page Language=&quot;C#&quot; %&gt;
              &lt;%>@ Import Namespace=&quot;System.Reflection&quot; %&gt;
              &lt;%>@ Import Namespace=&quot;System.Threading&quot; %&gt;

              &lt;script runat=&quot;server&quot;&gt;
                protected void Page_Load(object src, EventArgs e)
                {
                  System.Threading.Thread.Sleep(3000);
                  Response.Output.Write(&quot;Slow Response, Thread ID={0}&quot;,
                                 AppDomain.GetCurrentThreadId());
                }
              &lt;/script&gt;
            </Element>
            <Element Type="Text">
              <p>
                To test it, open the page in a browser.
                Open the page in more browser windows and refresh all the pages within the
                three second (3000 millisecond) period. You’ll see that the thread ID exposed
                by the script changes for each request. Once the period is over the next
                request receives a recycled thread from a previous request. Several long
                running requests can fill the thread pool and easily reach the limit of 25
                concurrent threads.
              </p>
              <p>
                Removing the <code>Sleep</code> call (Listing 2-9) will result in a faster running page. You won’t
                be able to request the page again while the server is handling the previous
                one. The thread IDs demonstrate that all requests run on the same thread, and the
                thread pool is never filled up to its limit.
              </p>
            </Element>
            <Element Type="Listing" Name="A simple page which performs well (Threading/FastThread.aspx)">
              &lt;%>@ Page Language=&quot;C#&quot; %&gt;
              &lt;%>@ Import Namespace=&quot;System.Reflection&quot; %&gt;

              &lt;script runat=&quot;server&quot;&gt;
                protected void Page_Load(object src, EventArgs e)
                {
                  Response.Output.Write(&quot;Fast Response, Thread ID={0}&quot;,
                                 AppDomain.GetCurrentThreadId());
                }
              &lt;/script&gt;
            </Element>
            <Element Type="Text">

              <p>
                Microsoft offers a stress test tool for
                simulating multiple concurrent requests even in the development environment.
                See
                the sidebar about the Web Stress Tool for more information.

              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Box">
              <header>Web Stress TOOL</header>
              <aside>
                <p>The web application stress tool can be downloaded from:</p>
                <ul>
                  <li>http://www.microsoft.com/downloads/details.aspx?familyid=e2c0585a-062a-439e-a67d-75a89aa36495&amp;displaylang=en</li>
                </ul>
                <p>
                  Unfortunately the tool is quite old and
                  Microsoft has not refreshed it to support newer environments. So if you run it
                  on Vista, a DLL named msvcp50.dll is missing. You may find the file on the web
                  or you can safely copy it from the support files section provided with this
                  book. Perform these steps to install the stress test tool:
                </p>
                <ul>
                  <li>Download the setup.exe from the address shown above</li>
                  <li>Download msvcp50.dll from the Apress support web site</li>
                  <li>Copy the unzipped file to folder %WinDir%\system (you must run with higher privileges to do this). Note that this is really system, not system32!</li>
                  <li>Install the stress test tool</li>
                  <li>Run it once to check that it’s working. Start it as an Administrator.</li>
                </ul>
                <p>Now you can use the tool as outlined in the following sections.</p>
              </aside>

            </Element>
          </Element>
          <Element Type="Section" Name="Working with the Stress Test Tool">
            Working with the Stress Test Tool
            <Element Type="Text">

              <p>
                A stress test is what the name
                implies—your application is forced to handle as many requests as necessary to
                feel stressed. To walk through this stress test, you’ll need to set up the
                pages shown above (Listings 2-8 and 2-9) within your IIS environment, which you’re
                able to run from a browser manually. Follow the steps below to set up the
                script in the stress test tool. I have set IIS to use this path:
              </p>

              <p class="Query">http://localhost/Threading/SlowThread.aspx</p>

              <p class="Query">http://localhost/Threading/FastThread.aspx</p>

              <p>
                Firstly, set up the script by adding the
                content tree—the pages requested from the tool.
              </p>

            </Element>
            <Element Type="Image" Name="Set the content for a stress test">
              images/19835f0206.png
            </Element>
            <Element Type="Text">

              <p>
                The content tree allows you to set the
                actions the tool performs several times. Alternatively, you can record a session
                to save the page load action. However, in this script, only one page is called
                using a GET command, so recording is not necessary.
              </p>

            </Element>
            <Element Type="Image" Name="Settings used to force the test">
              images/19835f0207.png
            </Element>
            <Element Type="Text">

              <p>
                The settings define how the
                tool operates on the server. In Figure 2-9 I set thirty threads, which create thirty
                concurrent requests. This runs for twenty seconds as quickly as possible. There
                is no throttling and no other options are used. This is the configuration that
                should cause the server to create twenty five threads and bring the thread pool
                to its limit.
              </p>

              <p>
                Table 2-2 shows the results of some
                stress tests. Remember that there is a wide range of possible values for
                response time depending on your machine, its configuration, and what other applications
                and services are currently running. It’s the relative values that are
                significant here.
              </p>

            </Element>
            <Element Type="Table" Name="Test results using a web stress test tool">
              <table>
                <tr>
                  <th> </th>
                  <th>Threads File</th>
                  <th>Hits </th>
                  <th>Average response time</th>
                </tr>

                <tr>
                  <td>100</td>
                  <td>FastThread.aspx</td>
                  <td>21093</td>
                  <td>45 ms</td>
                </tr>

                <tr>
                  <td>20</td>
                  <td>FastThread.aspx</td>
                  <td>21034</td>
                  <td>8.3 ms</td>
                </tr>

                <tr>
                  <td>100</td>
                  <td>SlowThread.aspx</td>
                  <td>33</td>
                  <td>6,108 ms</td>
                </tr>

                <tr>
                  <td>20</td>
                  <td>SlowThread.aspx</td>
                  <td>32</td>
                  <td>4,654 ms</td>
                </tr>

              </table>
            </Element>
            <Element Type="Text">

              <p>
                These results are not
                surprising. The server is less able to handle the requests as the number of parallel
                threads increases. Because we’re forcing IIS to queue the requests, this causes
                additional overhead.
                Running the client against both FastThread.aspx and SlowThread.aspx,
                however, reduces the average response time for FastThread.aspx requests to 2.05
                seconds and only 98 hits being handled.

                For SlowThread.aspx, the number of threads makes no significant difference. This is
                the worst case—because of long running requests, fast ones are not served
                quickly. Increasing the CPU power will not help. The slow page does not consume
                any CPU power because there is nothing to calculate. The delay you see is due
                to the saturation of the thread pool. Even the fast requests are queued until a
                thread is released.
              </p>

              <p>
                This demonstrates that some pages
                can influence the performance of other requests even if they have nothing to do
                with each other. What is the solution?
              </p>

              <p>
                I discussed previously the various
                settings available for improving the system’s behavior. In the stress test I
                used 100 threads. Increasing the thread pool limits might help. However, the
                real world does not have a defined number of requests regularly arriving.
                Finding the right value is anything but easy. It could change depending on user
                behavior, server settings, network connection, and application code—which means
                that there is no right answer.
              </p>
              <p>
                The solution we’re looking for
                should free the threads in the thread pool to hold the utilization low and have
                enough threads available at any time. In other words, each page should behave like
                a fast running page. This brings us to asynchronous handlers.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Note">
              <header>Note</header>
              <aside>
                next chapter is
                dedicated the world of handlers and modules. Here we discuss only the portion
                directly related to threading issues. For more information about handlers,
                refer to chapter 3.
              </aside>
            </Element>
          </Element>
          <Element Type="Section" Name="Custom Thread Pool and Asynchronous Handlers">
            Custom Thread Pool and Asynchronous Handlers
            <Element Type="Text">

              <p>
                While most ASP.NET pages and handlers
                are serviced synchronously on threads drawn from the thread pool, it is
                possible to create handlers and pages that service requests asynchronously.
              </p>

              <p>
                Asynchronous handlers implement the <code>IHttpAsyncHandler</code> interface, which derives from <code>
                  IHttpHandler
                </code>.
              </p>

            </Element>
            <Element Type="Listing" Name="Definition of the IHttpAsynchHandler interface">

              public interface IHttpAsyncHandler : IHttpHandler
              {
                IAsyncResult BeginProcessRequest(HttpContext ctx,
                                                 AsyncCallback cb,
                                                 object obj);
                void EndProcessRequest(IAsyncResult ar);
              }

            </Element>
            <Element Type="Text">

              <p>
                The interface follows the typical pattern
                for asynchronous actions—it has a method for indicating the beginning and one for
                indicating the end of a process. Usually handlers have a method named <code>ProcessRequest</code>.
                Instead of calling this method, the asynchronous handler calls the <code>BeginProcessRequest</code>
                method. In this method, you launch a new thread and manage things, which can take some time. The method returns immediately, providing a reference
                to an <code>IAsyncResult</code> instance. This frees the thread from the thread pool. A new thread
                is then used to perform the long running action. When the internal (or private)
                thread returns, the <code>EndProcessRequest</code>
                method is called. The <code>IAsyncResult</code> instance
                is handed over in order to parameterize the call. Cleanup actions, such as closing
                a database connection, are best placed here.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Handler with a Delegate">
            <Element Type="Text">
              <p>
                Creating an asynchronous handler with a
                delegate is the most common approach. Delegates called with <code>BeginInvoke</code> implicitly create a new thread.
              </p>

            </Element>

            <Element Type="Listing" Name="A handler using IHttpAsyncHandler">
              &lt;%>@ WebHandler Language=&quot;C#&quot; Class=&quot;Apress.Threading.AsyncHandlers.AsyncHandler&quot; %&gt;

              using System;
              using System.Web;
              using System.Threading;
              using System.Diagnostics;
              using System.Reflection;

              namespace Apress.Threading.AsyncHandlers
              {

                  public delegate void ProcessRequestDelegate(HttpContext ctx);

                  public class AsyncHandler : IHttpAsyncHandler
                  {
                      public void ProcessRequest(HttpContext ctx)
                      {
                          System.Threading.Thread.Sleep(2000);
                          ctx.Response.Output.Write(
                                       &quot;Async Delegate, Thread ID={0}&quot;,
                                       AppDomain.GetCurrentThreadId());
                      }

                      public bool IsReusable
                      {
                          get { return true; }
                      }

                      public IAsyncResult BeginProcessRequest(HttpContext ctx,  style='font-family: Wingdings'>
                                                              AsyncCallback cb,  style='font-family:Wingdings'>
                                                              object obj)
                      {
                          ProcessRequestDelegate prg = new ProcessRequestDelegate(ProcessRequest);
                          return prg.BeginInvoke(ctx, cb, obj);
                      }

                      public void EndProcessRequest(IAsyncResult ar)
                      {
                      }

                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                Call this handler by using a browser, as
                before, to test that it’s running properly:
              </p>

              <p class="Query">http://localhost/Threading/AsyncThreadDelegate.ashx</p>

              <p>
                The process starts with the
                method <code>BeginProcessRequest</code>. Using the delegate and its <code>
                  BeginInvoke
                </code>
                method, the method <code>ProcessRequest</code> is
                called. Then the <code>Sleep</code> method simulates
                something long running without performing anything on the CPU. Because there is
                nothing to clean up, no code is required  in <code>EndProcessRequest</code>.
              </p>

              <p>
                Now it’s time to see what the
                stress test tool is reporting.
              </p>

              <p>
                If you run the test as before,
                you can see that the results are nearly identical. What is going on here? Why write
                asynchronous delegates if there is no speed improvement at all? The reason is in
                the way ASP.NET internally handles the threading.
              </p>

              <p>
                Recall that when I first
                introduced the term “thread pool", it was called a “process wide thread pool".
                The asynchronous handler still runs in the very same process, which leads to a lack
                of improvement. The original thread is freed, but the new one is taken from the
                same thread pool. The same thing would happen if you used <code>ThreadPool.QueueUserWorkItem</code>
                from the <code>System.Threading</code>
                namespace. We need to find where we can get a new thread from another thread source.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Handler with Custom Threads">
            Asynchronous Handler with Custom Threads
            <Element Type="Text">

              <p>
                Before we can implement the whole
                solution, another interface is required—<code>IAsynchResult</code>—as the return result is now essential. The definition is short—just
                four properties (Listing 2-12).
              </p>

            </Element>
            <Element Type="Listing" Name="The definition of IAsyncResult">

              public interface IAsyncResult
              {
                public object     AsyncState             { get; }
                public bool       CompletedSynchronously { get; }
                public bool       IsCompleted            { get; }
                public WaitHandle AsyncWaitHandle        { get; }
              }

            </Element>
            <Element Type="Text">

              <p>
                Our actual implementation of the
                <code>IAsynchResult</code> interface (Listing 2-13) has two additional properties: a reference
                to the <code>HttpContext</code> object, and a reference to the callback object. The callback method
                is invoked later, when processing is complete. The
                <code>AsyncState</code> object is optional; you can use it to store private data.
                <code>AsyncWaitHandle</code> returns a <code>
                  WaitHandle
                </code> object,
                which is used to signal when the request is complete. Using the
                <code>CompleteRequest</code> method implemented additionally to the requirements of the interface,
                the calling class can execute the <code>EndProcessRequest</code> method. In this routine, the <code>
                  WaitHandle
                </code>
                object is triggered. Either way, the <code>IsCompleted</code>
                property shows that the object has reached the completed state.
              </p>

            </Element>
            <Element Type="Listing" Name="The implementation of IAsyncResult (from AsyncThreadCallback.ashx)">

              class AsyncRequestState : IAsyncResult
              {

                  internal HttpContext _ctx;
                  internal AsyncCallback _cb;
                  internal object _data;
                  private bool _isCompleted;
                  private ManualResetEvent _ completeEvent;

                  public AsyncRequestState(HttpContext ctx,
                                           AsyncCallback cb,
                                           object data)
                  {
                      _ctx = ctx;
                      _cb = cb;
                      _data = data;
                  }
                  internal HttpContext CurrentContext
                  {
                      get
                      {
                        return _ctx;
                      }
                  }

                  internal void CompleteRequest()
                  {
                      _isCompleted = true;
                      lock (this)
                      {
                          if (_completeEvent!= null)
                              _ completeEvent.Set();
                      }
                      // invoke registered callback, if any
                      if (_cb != null)
                          _cb(this);
                  }

                  public object AsyncState
                  {
                      get
                      {
                          return (_data);
                      }
                  }
                  public bool CompletedSynchronously
                  {
                      get
                      {
                          return (false);
                      }
                  }
                  public bool IsCompleted
                  {
                      get
                      {
                          return (_isCompleted);
                      }
                  }
                  public WaitHandle AsyncWaitHandle
                  {
                      get
                      {
                          lock (this)
                          {
                              if (_completeEvent == null)
                                  _ completeEvent = new ManualResetEvent(false);

                              return _completeEvent;
                          }
                      }
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                The next step is to spawn a new
                thread to process the request. The method called on this new thread will need
                access to the state cached in the <code>AsyncRequestState</code> class shown above. To pass necessary data to this object, a
                parameterized thread is used, based on <code>ParameterizedThreadStart</code> class.
              </p>

              <p>
                The handler itself is similar to
                the one already introduced. The definition for the ashx page looks like this:
              </p>

            </Element>
            <Element Type="Listing">

              &lt;%@ WebHandler Language=&quot;C#&quot;
              Class=&quot;Apress.Threading.AsyncHandlers.CustomAsyncHandler&quot; %&gt;

            </Element>
            <Element Type="Text">

              <p>
                The <code>ProcessRequest</code> method must be present, as it is required by the interface
                <code>IHttpAsyncHandler</code>, but we don’t use it. The whole work is split between the
                <code>BeginProcessRequest</code> and <code>
                  EndProcessRequest
                </code>
                methods. In the <code>BeginProcessRequest</code>
                method the <code>AsyncRequestState</code> object is created,
                along with the reference to the context and callback.
              </p>

            </Element>
            <Element Type="Listing" Name="The implementation of AsyncResult (AsyncThreadCallback.ashx)">

              public class CustomAsyncHandler : IHttpAsyncHandler
              {
                  public void ProcessRequest(HttpContext ctx)
                  {
                      // not used
                  }

                  public bool IsReusable
                  {
                      get { return false; }
                  }

                  public IAsyncResult BeginProcessRequest(HttpContext ctx,
                                                          AsyncCallback cb,
                                                          object obj)
                  {
                      AsyncRequestState reqState = style='font-family:Wingdings'>
                                        new AsyncRequestState(ctx, cb, obj);
                      ParameterizedThreadStart ts = new ParameterizedThreadStart(ProcessThread);
                      Thread t = new Thread(ts);
                      t.Start();

                      return reqState;
                  }

                  public void EndProcessRequest(IAsyncResult ar)
                  {
                      AsyncRequestState ars = ar as AsyncRequestState;
                      if (ars != null)
                      {
                         ars.CurrentContext.Response.Write(&quot;End Request reached&quot;);
                      }
                  }

                  private void ProcessThread(object obj)
                  {
                      Thread.Sleep(2000);
                      AsyncRequestState asr = obj as AsyncRequestState;
                      asr.CurrentContext.Response.Output.Write( style='font-family:Wingdings'>
                                  &quot;Async Thread, Thread ID = {0}&quot;, style='font-family:Wingdings'>
                                  AppDomain.GetCurrentThreadId());
                      // signal end of processing
                      asr.EndRequest();
                  }

              }

            </Element>
            <Element Type="Text">

              <p>
                Let’s look at the code to understand how
                it’s working. Figure 2-10 shows
                the thread usage during internal processing. Initiated by the request, the
                process starts by calling the <code>BeginProcessRequest</code>
                method. The <code>AsyncHandler</code>
                creates the helper objects required and launches the new custom thread
                independent of the thread pool. The custom thread runs and the thread pool
                thread is released. Once the process is completed, the end is signaled via the
                callback method and the request is finished.
              </p>
            </Element>
            <Element Type="Image" Name="First step of the processing using an asynchronous handler">
              images/19835f0208.png
            </Element>
            <Element Type="Text">
              <p>
                The response held in memory is
                waiting for the thread to complete. This might seem disappointing, because it
                doesn’t make anything faster. The page is still waiting for the slow operation
                to finish, and so is the user. Remember the thread pool issue, however; once the
                pool runs out of threads, the performance of the whole server is reduced and no
                more requests are handled properly. The advantage of custom threads is not a
                faster response for one user but for all users.
              </p>

              <p>
                In step two, as shown in Figure 2-11, the call to <code>EndRequest</code> indicates the end of the process and terminates the request. Once
                called, the response is complete and sent to the browser. This means that you
                can add content to the response at any time before the <code>EndProcessRequest</code> method is called. In the example code (Listing 2-14) the
                <code>Response.Output.Write</code> method demonstrates this.
              </p>

            </Element>
            <Element Type="Image" Name="Second step of the processing using an asynchronous handler">
              images/19835f0209.png
            </Element>
            <Element Type="Text">

              <p>
                Run the stress test again to see
                whether
                you find an improvement
                . Under
                pressure it performs better, and the thread pool no longer runs out of threads.
                This allows the site to accept incoming requests at any time, and the whole
                server appears to be more responsive. Again, the processing time for a single
                page is the same.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Handler and a Custom Thread Pool">
            Asynchronous Handler and a Custom Thread Pool
            <Element Type="Text">

              <p>
                This technique is useful for
                many extensibility projects. In Chapter 3, I’ll show more examples of practical
                implementations that solve common issues. All handlers explained there use
                simple synchronous operations. You can implement them all as asynchronous
                counterparts using the techniques described here. Using asynchronous handlers
                you’ll see how to improve the overall performance of an ASP.NET site
                drastically. The thread issues and handlers that I discuss here are just one
                solution.
              </p>

              <p>
                There is another issue that
                can be found easily using the stress test tool. In one of the previous
                paragraphs I wrote “accept incoming requests at any time".
                This is quite a claim, as it assumes that the server will respond no matter how
                many requests arrive, just by creating new threads. However, the operating
                system, CPU power, available memory, and architectural restrictions of the
                hardware may stop the code from creating new threads. It is possible for too
                many threads to be created, in which case they will block each other and make
                the system slow and unresponsive.
              </p>

              <p>
                You might ask “Why not use a
                thread pool?" Unfortunately, .NET has only one thread pool internally and it is
                used by ASP.NET. That’s why using <code>ThreadPool.QueueUserWorkItem</code> does not work. Our task now is the creation
                of our own thread pool. Several people have done this successfully. Mike
                Woodring wrote a version which is useful and fits our needs, using the code in
                an asynchronous handler. The original version can be found on his page:
              </p>

              <p class="Query">http://www.bearcanyon.com/</p>

              <p>
                I have adapted his code to suit
                our needs for a handler.
              </p>

              <p>
                There are several clever aspects
                to this code. The usage of <code>HttpContext</code> is much
                simpler. In the previous example, a reference to the context object was stored
                and the use of <code>HttpContext.Current</code> was forbidden. It is
                not good programming practice to change well known method calls.
              </p>

            </Element>
            <Element Type="Listing" Name="Delegates and base interface for the thread pool">

              public delegate void WorkRequestDelegate(object state,  style='font-family:Wingdings'> DateTime requestEnqueueTime );
              public delegate void ThreadPoolDelegate();

              #region IWorkRequest interface
              public interface IWorkRequest
              {
                  bool Cancel();
              }
              #endregion
            </Element>
            <Element Type="Text">

              <p>
                The following code shows the
                implementation in several steps. The core functionality is explained inline.
              </p>

            </Element>
            <Element Type="Listing" Name="The basic thread pool implementation">

              public sealed class ThreadPool : WaitHandle
              {
                  #region ThreadPool constructors                  public ThreadPool( int initialThreadCount, int maxThreadCount, string poolName )
                      : this( initialThreadCount, maxThreadCount, poolName,
                              DEFAULT_NEW_THREAD_TRIGGER_TIME,
                              DEFAULT_DYNAMIC_THREAD_DECAY_TIME,
                              DEFAULT_THREAD_PRIORITY,
                              DEFAULT_REQUEST_QUEUE_LIMIT )
                  {
                  }

                  public ThreadPool( int initialThreadCount,
              int maxThreadCount, string poolName,
                                     int newThreadTrigger, int dynamicThreadDecayTime,
                                     ThreadPriority threadPriority, int requestQueueLimit )
                  {

                      Handle = stopCompleteEvent.Handle;

                      if( maxThreadCount &lt; initialThreadCount )
                      {
                          throw new ArgumentException(&quot;Maximum thread count must be &gt;= initial style='font-family:Wingdings'>
                                                       thread count.&quot;, &quot;maxThreadCount&quot;);
                      }

                      if( dynamicThreadDecayTime &lt;= 0 )
                      {
                          throw new ArgumentException(&quot;Dynamic thread decay time cannot be &lt;= 0.&quot;
                                                   , &quot;dynamicThreadDecayTime&quot;);
                      }

                      if( newThreadTrigger &lt;= 0 )
                      {
                          throw new ArgumentException(&quot;New thread trigger time cannot be &lt;= 0.&quot;
                                                     , &quot;newThreadTrigger&quot;);
                      }
                      this.initialThreadCount = initialThreadCount;
                      this.maxThreadCount = maxThreadCount;
                      this.requestQueueLimit = (requestQueueLimit &lt; 0 ?  style='font-family:Wingdings'>
                                                DEFAULT_REQUEST_QUEUE_LIMIT : requestQueueLimit);
                      this.decayTime = dynamicThreadDecayTime;
                      this.newThreadTrigger = new TimeSpan(TimeSpan.TicksPerMillisecond   style='font-family:Wingdings'>
                                                            newThreadTrigger);
                      this.threadPriority = threadPriority;
                      this.requestQueue = new Queue(requestQueueLimit &lt; 0 ?  style='font-family: Wingdings'>
                                                     4096 : requestQueueLimit);
                      if( poolName == null )
                      {
                          throw new ArgumentNullException(&quot;poolName&quot;,  style='font-family:Wingdings'>
                                                          &quot;Thread pool name cannot be null&quot;);
                      }
                      else
                      {
                          this.threadPoolName = poolName;
                      }
                  }

            </Element>
            <Element Type="Text">

              <p>
                The next region sets several ThreadPool
                properties. The <code>Priority</code> and the
                <code>DynamicThreadDecay</code> properties are not thread safe. They can only be set before
                <code>Start</code> is called.
              </p>

            </Element>
            <Element Type="Listing">

                  public ThreadPriority Priority
                  {
                      get { return(threadPriority); }
                      set
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Cannot adjust thread  style='font-family:Wingdings'>
                                              priority after pool has been started.&quot;);
                          }

                          threadPriority = value;
                      }
                  }

                  public int DynamicThreadDecay
                  {
                      get { return(decayTime); }
                      set
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Cannot adjust dynamic thread style='font-family:Wingdings'>
                                                decay time after pool has been started.&quot;);
                          }

                          if( value &lt;= 0 )
                          {
                              throw new ArgumentException(&quot;Dynamic thread decay time cannot   style='font-family:Wingdings'>
                                                            be &lt;= 0.&quot;, &quot;value&quot;);
                          }

                          decayTime = value;
                      }
                  }
                  public int NewThreadTrigger
                  {
                      get { return((int)newThreadTrigger.TotalMilliseconds);}
                      set
                      {
                          if( value &lt;= 0 )
                          {
                              throw new ArgumentException(&quot;New thread trigger time cannot  style='font-family:Wingdings'>
                                                            be &lt;= 0.&quot;, &quot;value&quot;);
                          }

                          lock( this )
                          {
                              newThreadTrigger = new TimeSpan(TimeSpan.TicksPerMillisecond   style='font-family:Wingdings'>
                                                              value);
                          }
                      }
                  }

                  public int RequestQueueLimit
                  {
                      get { return(requestQueueLimit); }
                      set { requestQueueLimit = (value &lt; 0 ? DEFAULT_REQUEST_QUEUE_LIMIT : value);
                  }

                  public int AvailableThreads
                  {
                      get { return(maxThreadCount - currentThreadCount); }
                  }

                  public int MaxThreads
                  {
                      get { return(maxThreadCount); }

                      set
                      {
                          if( value &lt; initialThreadCount )
                          {
                              throw new ArgumentException(&quot;Maximum thread count must be  style='font-family:Wingdings'>
                                                          &gt;= initial thread count.&quot;,  style='font-family:Wingdings'>
                                                          &quot;MaxThreads&quot;);
                          }
                          maxThreadCount = value;
                      }
                  }

                  public bool IsStarted
                  {
                      get { return(hasBeenStarted); }
                  }

                  public bool PropogateThreadPrincipal
                  {
                      get { return(propogateThreadPrincipal); }
                      set { propogateThreadPrincipal = value; }
                  }

                  public bool PropogateCallContext
                  {
                      get { return(propogateCallContext); }
                      set { propogateCallContext = value; }
                  }

                  public bool PropogateHttpContext
                  {
                      get { return(propogateHttpContext); }
                      set { propogateHttpContext = value; }
                  }

                  public bool PropogateCASMarkers
                  {
                      get { return(propogateCASMarkers); }

                      // When CompressedStack get/set is opened up,
                      // add the following setter back in.
                      //
                      // set { propogateCASMarkers = value; }
                  }

                  public bool IsBackground
                  {
                      get { return(useBackgroundThreads); }

                      set
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Cannot adjust background  style='font-family:Wingdings'>
                                                      status after pool has been started.&quot;);
                          }

                          useBackgroundThreads = value;
                      }
                  }
                  #endregion                  #region ThreadPool events
                  public event ThreadPoolDelegate Started;
                  public event ThreadPoolDelegate Stopped;
                  #endregion                  public void Start()
                  {
                      lock( this )
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Pool has already  style='font-family:Wingdings'> been started.&quot;);
                          }

                          hasBeenStarted = true;

            </Element>
            <Element Type="Text">

              <p>
                Next, we have to check to see if there
                were already items posted to the queue before <code>Start</code> was
                called.  If this is the case, we’ll reset their timestamps to the current time.
              </p>

            </Element>
            <Element Type="Listing">

                          if( requestQueue.Count &gt; 0 )
                          {
                              ResetWorkRequestTimes();
                          }

                          for( int n = 0; n &lt; initialThreadCount; n++ )
                          {
                              ThreadWrapper thread = style='font-family:Wingdings'>
                                  new ThreadWrapper( this, true, threadPriority,  style='font-family:Wingdings'>
                                                 string.Format(&quot;{0} (static)&quot;, threadPoolName) );
                              thread.Start();
                          }

                          if( Started != null )
                          {
                              Started();
                          }
                      }
                  }
            </Element>
            <Element Type="Text">

              <p>
                The <code>Stop</code> method
                can be used to stop the whole pool immediately. The <code>StopAndWait</code> method lets all threads run until they end normally and then stops
                the pool. The overloaded version defines a timeout to prevent the method
                blocking due to threads held in a deadlock.
              </p>

            </Element>
            <Element Type="Listing">

                  public void Stop()
                  {
                      InternalStop(false, Timeout.Infinite);
                  }

                  public void StopAndWait()
                  {
                      InternalStop(true, Timeout.Infinite);
                  }

                  public bool StopAndWait( int timeout )
                  {
                      return InternalStop(true, timeout);
                  }

            </Element>
            <Element Type="Text">

              <p>
                <code>InternalStop</code> is the method that
                completes the order. After checking that there is something to stop we set the
                property that exposes the stopping process. <code>Monitor.PulseAll</code> informs all threads that the state of the object has changed.
              </p>

              <p>
                If the wait option is set, the thread is
                waiting using <code>WaitOne</code>. This method is defined in the
                base class <code>WaitHandle</code>.
              </p>

            </Element>
            <Element Type="Listing">

                  private bool InternalStop( bool wait, int timeout )
                  {
                      if( !hasBeenStarted )
                      {
                          throw new InvalidOperationException(&quot;Cannot stop a thread pool style='font-family:Wingdings'> that has not been started yet.&quot;);
                      }

                      lock(this)
                      {
                          stopInProgress = true;
                          Monitor.PulseAll(this);
                      }

                      if( wait )
                      {
                          bool stopComplete = WaitOne(timeout, true);

                          if( stopComplete )
                          {
                              hasBeenStarted = false;
                              stopInProgress = false;
                              requestQueue.Clear();
                              stopCompleteEvent.Reset();
                          }

                          return(stopComplete);
                      }

                      return(true);
                  }

                  #endregion                  #region ThreadPool.PostRequest(early bound)

                  // Overloads for the early bound WorkRequestDelegate-based targets.
                  //
                  public bool PostRequest( WorkRequestDelegate cb )
                  {
                      return PostRequest(cb, (object)null);
                  }

                  public bool PostRequest( WorkRequestDelegate cb, object state )
                  {
                      IWorkRequest notUsed;
                      return PostRequest(cb, state, out notUsed);
                  }

                  public bool PostRequest( WorkRequestDelegate cb, object state,  style='font-family:Wingdings'>
                                           out IWorkRequest reqStatus )
                  {
                      WorkRequest request =
                          new WorkRequest( cb, state,
                                           propogateThreadPrincipal, propogateCallContext,
                                           propogateHttpContext, propogateCASMarkers );
                      reqStatus = request;
                      return PostRequest(request);
                  }

                  #endregion                  #region ThreadPool.PostRequest(late bound)

                  // Overloads for the late bound Delegate.DynamicInvoke-based targets.
                  //
                  public bool PostRequest( Delegate cb, object[] args )
                  {
                      IWorkRequest notUsed;
                      return PostRequest(cb, args, out notUsed);
                  }
               
                 public bool PostRequest( Delegate cb, object[] args, out IWorkRequest reqStatus )
                  {
                      WorkRequest request =
                          new WorkRequest( cb, args,
                                          propogateThreadPrincipal, propogateCallContext,
                                          propogateHttpContext, propogateCASMarkers );
                      reqStatus = request;
                      return PostRequest(request);
                  }

                  #endregion                  // The actual implementation of PostRequest.
                  //
                  bool PostRequest( WorkRequest request )
                  {
                      lock(this)
                      {

            </Element>
            <Element Type="Text">

              <p>
                A <code>requestQueueLimit</code> of -1 means the queue is “unbounded" and that there is no explicit
                limit on the maximum number of requests allowed in the queue.
              </p>

            </Element>
            <Element Type="Listing">

                          if( (requestQueueLimit == -1) ||  style='font-family:Wingdings'>
                              (requestQueue.Count &lt; requestQueueLimit) )
                          {
                              try
                              {
                                  requestQueue.Enqueue(request);
                                  Monitor.Pulse(this);
                                  return(true);
                              }
                              catch
                              {
                              }
                          }
                      }

                      return(false);
                  }

                  void ResetWorkRequestTimes()
                  {
                      lock( this )
                      {
                          DateTime newTime = DateTime.Now;
                          foreach( WorkRequest wr in requestQueue )
                          {
                              wr.workingTime = newTime;
                          }
                      }
                  }
            </Element>
            <Element Type="Text">

              <p>
                The class comes with few default
                parameters. The time values are provided in milliseconds. The constant
                <code>DEFAULT_DYNAMIC_THREAD_DECAY_TIME</code> is set to five minutes.
              </p>
            </Element>
            <Element Type="Listing">
                  const int DEFAULT_DYNAMIC_THREAD_DECAY_TIME = 5  60  1000;
                  const int DEFAULT_NEW_THREAD_TRIGGER_TIME = 500;
                  const ThreadPriority DEFAULT_THREAD_PRIORITY = ThreadPriority.Normal;
                  const int DEFAULT_REQUEST_QUEUE_LIMIT = -1; // unbounded
                  #endregion                  #region Private ThreadPool member variables                  private bool                hasBeenStarted = false;
                  private bool                stopInProgress = false;
                  private readonly string     threadPoolName;
                  private readonly int        initialThreadCount;     // Initial # of threads to create (called &quot;static threads&quot; in this class).
                  private int                 maxThreadCount;         // Cap for thread count.  Threads added above initialThreadCount are called &quot;dynamic&quot; threads.
                  private int                 currentThreadCount = 0; // Current # of threads in the pool (static + dynamic).
                  private int                 decayTime;              // If a dynamic thread is idle for this period of time w/o processing work requests, it will exit.
                  private TimeSpan            newThreadTrigger;       // If a work request sits in the queue this long before being processed, a new thread will be added to queue up to the max.
                  private ThreadPriority      threadPriority;
                  private ManualResetEvent    stopCompleteEvent = new ManualResetEvent(false); // Signaled after Stop called and last thread exits.
                  private Queue               requestQueue;
                  private int                 requestQueueLimit;      // Throttle for maximum # of work requests that can be added.
                  private bool                useBackgroundThreads = true;
                  private bool                propogateThreadPrincipal = false;
                  private bool                propogateCallContext = false;
                  private bool                propogateHttpContext = false;
                  private bool                propogateCASMarkers = false;

            </Element>
            <Element Type="Listing" Name="Private embedded class that holds thread information">

                  class ThreadInfo
                  {
                      public static ThreadInfo Capture( bool propogateThreadPrincipal, bool propogateCallContext,
                                                        bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          return new ThreadInfo( propogateThreadPrincipal, propogateCallContext,
                                                 propogateHttpContext, propogateCASMarkers );
                      }

                      public static ThreadInfo Impersonate( ThreadInfo ti )
                      {
                          if( ti == null ) throw new ArgumentNullException(&quot;ti&quot;);

                          ThreadInfo prevInfo = Capture(true, true, true, true);
                          Restore(ti);
                          return(prevInfo);
                      }

                      public static void Restore( ThreadInfo ti )
                      {
                          if( ti == null ) throw new ArgumentNullException(&quot;ti&quot;);
                          if( miSetLogicalCallContext != null )
                          {
                             miSetLogicalCallContext.Invoke(Thread.CurrentThread, style='font-family:Wingdings'> new object[]{ti.callContext});
                          }

            </Element>
            <Element Type="Text">

              <p>
                Restore <code>HttpContext</code> assigns
                the stored context as current one.
              </p>

            </Element>
            <Element Type="Listing">

                         CallContext.SetData(HttpContextSlotName, ti.httpContext);

            </Element>
            <Element Type="Text">

              <p>
                The thread identity is restored.  It's
                important that this is done after restoring call context, since restoring call
                context also overwrites the current thread principal setting. If <code>
                  propogateCallContext
                </code> and <code>
                  propogateThreadPrincipal
                </code> are both true, then the following is redundant. However, since propagating
                call context requires the use of reflection to capture and restore call
                context, the author wanted that behavior to be independently switchable so that
                it could be disabled. The thread principal
                12.0pt'> is still allowed to be propagated.
                In the event that call context  12.0pt'> propagation changes it no longer propagates the
                thread principal.
              </p>
            </Element>
            <Element Type="Listing">

                          Thread.CurrentPrincipal = ti.principal;
                      }

                      private ThreadInfo( bool propogateThreadPrincipal,  style='font-family:Wingdings'>
                                          bool propogateCallContext,  style='font-family:Wingdings'>
                                          bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          if( propogateThreadPrincipal )
                          {
                              principal = Thread.CurrentPrincipal;
                          }

                          if( propogateHttpContext )
                          {
                              httpContext = HttpContext.Current;
                          }

                          if( propogateCallContext &amp;&amp; (miGetLogicalCallContext != null) )
                          {
                              callContext = style='font-family:Wingdings'>
                                       (LogicalCallContext)miGetLogicalCallContext.Invoke(style='font-family:Wingdings'>
                                                           Thread.CurrentThread, null);
                              callContext = (LogicalCallContext)callContext.Clone();
                          }
                      }

                      IPrincipal principal;
                      LogicalCallContext callContext;
                      HttpContext httpContext;

                      // Cached type information.
                      //
                      const BindingFlags bfNonPublicInstance = BindingFlags.Instance | BindingFlags.NonPublic;
                      const BindingFlags bfNonPublicStatic = BindingFlags.Static | BindingFlags.NonPublic;

                      static MethodInfo miGetLogicalCallContext =
                              typeof(Thread).GetMethod(&quot;GetLogicalCallContext&quot;, bfNonPublicInstance);

                      static MethodInfo miSetLogicalCallContext =
                              typeof(Thread).GetMethod(&quot;SetLogicalCallContext&quot;, bfNonPublicInstance);

                      static string HttpContextSlotName;

                      static ThreadInfo()
                      {
            </Element>
            <Element Type="Text">
              <p>
                Look up the value of <code>HttpContext.CallContextSlotName</code>—if it exists—
                to find the name of the call context slot where <code>HttpContext.Current</code>
                is stored. If this field isn’t present, try for the original “HttpContext"
                slot name.
              </p>
              <pre>
                            FieldInfo fi = typeof(HttpContext).GetField(&quot;CallContextSlotName&quot;, bfNonPublicStatic);
                            if( fi != null )
                            {
                                HttpContextSlotName = (string)fi.GetValue(null);
                            }
                            else
                            {
                                HttpContextSlotName = &quot;HttpContext&quot;;
                            }
                        }
                    }
              </pre>
            </Element>
            <Element Type="Listing" Name="Implementation of the base interface to handle the incoming requests">

                  class WorkRequest : IWorkRequest
                  {
                      internal const int PENDING = 0;
                      internal const int PROCESSED = 1;
                      internal const int CANCELLED = 2;

                      public WorkRequest( WorkRequestDelegate cb, object arg,  style='font-family:Wingdings'>
                                          bool propogateThreadPrincipal,  style='font-family:Wingdings'>
                                          bool propogateCallContext,  style='font-family:Wingdings'>
                                          bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          targetProc = cb;
                          procArg = arg;
                          procArgs = null;

                          Initialize( propogateThreadPrincipal, propogateCallContext,
                                      propogateHttpContext, propogateCASMarkers );
                      }

                      public WorkRequest( Delegate cb, object[] args,  style='font-family:Wingdings'>
                                          bool propogateThreadPrincipal,  style='font-family:Wingdings'>
                                          bool propogateCallContext,  style='font-family:Wingdings'>
                                          bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          targetProc = cb;
                          procArg = null;
                          procArgs = args;

                          Initialize( propogateThreadPrincipal, propogateCallContext,
                                      propogateHttpContext, propogateCASMarkers );
                      }

                      void Initialize( bool propogateThreadPrincipal, bool propogateCallContext,
                                       bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          workingTime = timeStampStarted = DateTime.Now;
                          threadInfo = ThreadInfo.Capture( propogateThreadPrincipal, propogateCallContext,
                                                           propogateHttpContext, propogateCASMarkers );
                      }

                      public bool Cancel()
                      {

            </Element>
            <Element Type="Text">
              <p>
                If the work request was pending, it’s
                marked as cancelled. Otherwise, this method was called too late. Note that this
                call can cancel an operation without any race conditions.  But if the result of
                this test-and-set indicates the request is in the “processed" state, it might
                actually be about to be processed.
              </p>
              <pre>
                           return(Interlocked.CompareExchange(ref state, CANCELLED, PENDING) == PENDING);
                        }

                        internal Delegate      targetProc;         // Function to call.
                        internal object        procArg;            // State to pass to function.
                        internal object[]      procArgs;           // Used with Delegate.DynamicInvoke.
                        internal DateTime      timeStampStarted;   // Time work request was originally enqueued (held constant).
                        internal DateTime      workingTime;        // Current timestamp used for triggering new threads (moving target).
                        internal ThreadInfo    threadInfo;         // Everything we know about a thread.
                        internal int           state = PENDING;    // The state of this particular request.
                    }
              </pre>
            </Element>
            <Element Type="Listing" Name="An internal wrapper class around the pool">

                  class ThreadWrapper
                  {
                      ThreadPool      pool;
                      bool            isPermanent;
                      ThreadPriority  priority;
                      string          name;

                      public ThreadWrapper( ThreadPool pool, bool isPermanent,
                                            ThreadPriority priority, string name )
                      {
                          this.pool = pool;
                          this.isPermanent = isPermanent;
                          this.priority = priority;
                          this.name = name;

                          lock( pool )
                          {
                              // Update the total # of threads in the pool.
                              //
                              pool.currentThreadCount++;
                          }
                      }

                      public void Start()
                      {
                          Thread t = new Thread(new ThreadStart(ThreadProc));
                          t.ApartmentState = ApartmentState.MTA;
                          t.Name = name;
                          t.Priority = priority;
                          t.IsBackground = pool.useBackgroundThreads;
                          t.Start();
                      }

                      void ThreadProc()
                      {
                          bool done = false;
                          while( !done )
                          {
                              WorkRequest wr = null;
                              ThreadWrapper newThread = null;
                              lock( pool )
                              {

            </Element>
            <Element Type="Text">
              <p>
                As long as the request queue is empty
                and a shutdown hasn’t been initiated, wait for a new work request to arrive.
              </p>
              <pre>
                                    bool timedOut = false;

                                    while( !pool.stopInProgress &amp;&amp; !timedOut &amp;&amp; (pool.requestQueue.Count == 0) )
                                    {
                                        if( !Monitor.Wait(pool, (isPermanent ? Timeout.Infinite : pool.decayTime)) )
                                        {
              </pre>
              <p>
                Timed out waiting for something to do. 
                Only dynamically created threads will reach this point, so bail out.
              </p>
              <pre>

                                           //
                                            timedOut = true;
                                        }
                                    }

              </pre>
              <p>
                The loop above exited because one of the
                following conditions was met:
              </p>
              <ul>
                <li>  ThreadPool.Stop was called to initiate a shutdown.</li>
                <li>  A dynamic thread timed out waiting for a work request to arrive.</li>

                <li>  There were items in the work queue to process.</li>
              </ul>
              <p>
                If the loop exited because there was work
                to be done, this means that a shutdown hadn’t been initiated, and the code wasn’t
                running in a dynamic thread that timed out. Pull the request off the queue and
                prepare to 12.0pt'> process it:
              </p>
              <pre>

                                    if( !pool.stopInProgress &amp;&amp;  style='font-family: Wingdings'>
                                        !timedOut &amp;&amp; (pool.requestQueue.Count &gt; 0) )
                                    {
                                        wr = (WorkRequest)pool.requestQueue.Dequeue();
                                        Debug.Assert(wr != null);
              </pre>
              <p>
                Check whether this work request
                languished in the queue too long.  If it was in the queue longer than the new
                thread trigger time, and if it hadn’t reached the max thread count cap, add a
                new thread to the pool.
              </p>
              <p>
                If that was the case, create the
                new thread object and update12.0pt'> the current number of threads in the pool, but defer starting the
                new thread until the lock is released.
              </p>
              <pre>
                                        TimeSpan requestTimeInQ =
                                                    DateTime.Now.Subtract(wr.workingTime);

                                        if( (requestTimeInQ &gt;= pool.newThreadTrigger) &amp;&amp;
                                            (pool.currentThreadCount &lt; pool.maxThreadCount) )
                                        {

              </pre>
              <p>
                Note that the constructor for <code>ThreadWrapper</code> will update <code>pool.currentThreadCount</code>.
              </p>
              <pre>

                                            newThread =
                                                new ThreadWrapper( pool, false, priority,
                                                                  string.Format(&quot;{0} (dynamic)&quot;,
                                                                  pool.threadPoolName) );

              </pre>

              <p>
                Since the current request we just
                dequeued is stale, everything else behind it in the queue is also stale.
                Therefore, reset the timestamps of the remaining pending work requests so that
                we don’t start creating threads for every subsequent request.
              </p>

              <pre>

                                           pool.ResetWorkRequestTimes();
                                        }
                                    }
                                    else
                                    {

              </pre>

              <p>
                Code flow should only reach this point if
                this is a dynamic thread that 12.0pt'> timed out waiting for a work request, or if the pool is shutting
                down.
              </p>

              <pre>

                                        pool.currentThreadCount--;
                                        if( pool.currentThreadCount == 0 )
                                        {
              </pre>
              <p>
                If there is no thread running in the
                pool, the pool stops and this is signaled.
              </p>

              <pre>

                                            if( pool.Stopped != null )
                                            {
                                                pool.Stopped();
                                            }

                                            pool.stopCompleteEvent.Set();
                                        }

                                        done = true;
                                    }
                                } // lock
              </pre>
            </Element>
            <Element Type="Text">
              <p>After all this is completed, the lock is no longer required.</p>
            </Element>
            <Element Type="Listing">

                              if( !done &amp;&amp; (wr != null) )
                              {

            </Element>
            <Element Type="Text">

              <p>
                Now check to see if this request has
                been cancelled while stuck in the work queue. If the work request was pending,
                mark it processed and proceed to handle. Otherwise, the request must have been
                cancelled before we plucked it off the request queue.
              </p>

            </Element>
            <Element Type="Listing">

                                  if( Interlocked.CompareExchange(ref wr.state, style='font-family:Wingdings'>
                                       WorkRequest.PROCESSED, WorkRequest.PENDING) !=  style='font-family:Wingdings'>
                                       WorkRequest.PENDING )
                                  {
            </Element>
            <Element Type="Text">

              <p>
                The request was cancelled before flow
                could get here and we have to bail out.
              </p>

            </Element>
            <Element Type="Listing">

                                      continue;
                                  }

                                  if( newThread != null )
                                  {

            </Element>
            <Element Type="Text">

              <p>
                Add a dynamic thread to the pool just by
                starting it.
              </p>

            </Element>
            <Element Type="Listing">

                                      newThread.Start();
                                  }

            </Element>
            <Element Type="Text">

              <p>Dispatch the work request.</p>

            </Element>
            <Element Type="Listing">

                                  ThreadInfo originalThreadInfo = null;

                                  try
                                  {

            </Element>
            <Element Type="Text">

              <p>
                Impersonate as much as possible what we
                know about the thread that issued the work request.
              </p>

            </Element>
            <Element Type="Listing">

                                      originalThreadInfo = ThreadInfo.Impersonate(wr.threadInfo);
                                      WorkRequestDelegate targetProc = wr.targetProc as  style='font-family:Wingdings'>
                                                                      WorkRequestDelegate;

                                      if( targetProc != null )
                                      {
                                          targetProc(wr.procArg, wr.timeStampStarted);
                                      }
                                      else
                                      {
                                          wr.targetProc.DynamicInvoke(wr.procArgs);
                                      }
                                  }
                                  catch( Exception e )
                                  {
                                  }
                                  finally
                                  {

            </Element>
            <Element Type="Text">

              <p>Restore our worker thread's identity.</p>

            </Element>
            <Element Type="Listing">

                                     ThreadInfo.Restore(originalThreadInfo);
                                  }
                              }
                          }

            </Element>
            <Element Type="Text">

              <p>The worker thread is now exiting the pool.</p>

            </Element>
            <Element Type="Listing">

                      }
                  }

              }

            </Element>
          </Element>
          <Element Type="Section" Name="Using the Custom Thread Pool">
            Using the Custom Thread Pool
            <Element Type="Text">

              <p>
                Now that we have a custom thread pool
                implementation, it’s time to
                use it. The following example is simply an extended version of the previous
                one. Instead of using single threads, however, and risking having too many of
                them, we can use the custom thread pool and set some limitations.
              </p>

            </Element>

            <Element Type="Listing" Name="Using the thread pool">

              &lt;!-- File: AsyncPool.ashx --&gt;
              &lt;%@ WebHandler Language=&quot;C#&quot;
                  Class=&quot;Apress.Threading.HttpPipeline.AsyncHandler&quot; %&gt;

              namespace Apress.Threading.HttpPipeline
              {

                public class AsyncHandler : IHttpAsyncHandler
                {
                  static DevelopMentor.ThreadPool _threadPool;

                  static AsyncHandler()
                  {
                    _threadPool =
                      new DevelopMentor.ThreadPool(2, 25, &quot;AsyncPool&quot;);
                    _threadPool.PropogateCallContext = true;
                    _threadPool.PropogateThreadPrincipal = true;
                    _threadPool.PropogateHttpContext = true;
                    _threadPool.Start();
                  }

                  public void ProcessRequest(HttpContext ctx)
                  {
                   // not used
                  }

                  public bool IsReusable
                  {
                    get { return false;}
                  }

                  public IAsyncResult BeginProcessRequest(HttpContext ctx,
                                   AsyncCallback cb, object obj)
                  {
                    AsyncRequestState reqState =
                                   new AsyncRequestState(ctx, cb, obj);
                    _threadPool.PostRequest( new Apress.Threading.CustomThreadPool. style='font-family:Wingdings'>
                                                 WorkRequestDelegate(ProcessRequest),
                                   reqState);

                    return reqState;
                  }

                  public void EndProcessRequest(IAsyncResult ar)
                  {
                  }

                  void ProcessRequest(object state, DateTime requestTime)
                  {
                    AsyncRequestState reqState = state as AsyncRequestState;

                    // Take some time to do it
                    Thread.Sleep(2000);

                    reqState._ctx.Response.Output.Write
                                 &quot;AsyncThreadPool, {0}&quot;,
                                 AppDomain.GetCurrentThreadId);

                    // tell asp.net you are finished processing this request
                    reqState.CompleteRequest();
                  }

                }
              }

            </Element>
            <Element Type="Text">

              <p>
                In theory, this thread pool will never
                run out of threads. However, there are some limitations such as available
                memory, CPU power, and operating system restrictions. This is why the pool was
                designed: so that you can optionally specify limits. The code shown above is a
                good platform for experimenting with threads and thread pools and for monitoring
                the number of threads for your application. If you want to replace the internal
                thread pool, try out the custom pool to learn how ASP.NET requests threads and
                find out where to improve performance.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Pages">
            Asynchronous Pages
            <Element Type="Text">

              <p>
                So far, all of the examples of
                asynchronous request handling have involved building custom handlers. In
                chapter 3, I’ll cover such handlers in more detail.
              </p>

              <p>
                There may be many .aspx pages
                in your ASP.NET applications that are also good candidates for asynchronous
                execution because they perform non-CPU-bound tasks that take significant
                amounts of time. Such pages are also potential bottlenecks for the ASP.NET
                thread pool.
              </p>

              <p>
                Because pages are also managed
                by a handler, it seems easy to let pages execute asynchronously. This is
                already implemented by the framework for us and there is nothing to do but set
                a property.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Define the Right Page Handler">
            Define the Right Page Handler
            <Element Type="Text">

              <p>
                Building asynchronous pages is pretty
                simple. Begin by including an attribute in the page’s <code>@Page</code> directive:
              </p>

              <pre>
                &lt;%@ Page Async=&quot;true&quot; ... %&gt;
              </pre>

            </Element>
            <Element Type="Text">

              <p>
                Behind the scenes, this tells ASP.NET to
                implement <code>IHttpAsyncHandler</code> in the page instead of <code>IHttpHandler</code>
                used regularly. Next, call the <code>AddOnPreRenderCompleteAsync</code> method early in the page’s lifetime. For example, in
                <code>Load</code>, this is early enough. Register a <code>Begin</code> method
                and an <code>End</code> method, as shown in the following code:
              </p>
              <pre>
                AddOnPreRenderCompleteAsync (
                    new BeginEventHandler(MyBeginMethod),
                    new EndEventHandler (MyEndMethod)
                );
              </pre>
              <p>
                The page runs through its normal
                processing lifecycle until shortly after the <code>
                  PreRender
                </code>
                event fires. Then ASP.NET calls the <code>
                  Begin
                </code> method
                that you registered using <code>
                  AddOnPreRenderCompleteAsync
                </code>. The <code>Begin</code> method launches
                an asynchronous operation and returns immediately. This is a lengthy operation which
                might require more time, such as a database query or a webservice call to
                another server. At this point, the thread assigned to the request returns to
                the thread pool. Furthermore, the <code>Begin</code> method
                returns an <code>IAsyncResult</code> that allows ASP.NET to determine
                when the asynchronous operation has been completed. ASP.NET then extracts a
                thread from the thread pool and calls your <code>End</code> method.
                After <code>End</code> returns, it executes the remaining portion of the page’s lifecycle.
                This might sound confusing—getting the thread back from thread pool would again
                block the thread. But between the time <code>Begin</code>
                returns and <code>End</code> gets called, the request-processing
                thread is free to service other requests. Keep in mind that the page processing
                usually takes only a few milliseconds. The time-consuming operation in the
                asynchronous handler might run for seconds. The process of freeing the thread
                pool thread for this time allows ASP.NET to process hundreds if not thousands
                of regular pages on this very same thread. However, until <code>End</code> is called, the rendering of the current asynchronous page is
                delayed. This is the same as in the previous example. It improves the situation
                not only for one user, but for all users. In the sample code, you might look
                for the <code>IAsyncResult</code> implementation. Instead of implementing our own version, we take
                one that the Framework implements for us.
              </p>

            </Element>
            <Element Type="Image" Name="Synchronous vs. Asynchronous Page Processing">
              ASPNETEXT_Chapter_02_V1.0-Dateien/image001.gif
            </Element>
            <Element Type="Text">

              <p>
                Figure 2-12 illustrates the difference between a synchronous page and an
                asynchronous page. When a synchronous page is requested, ASP.NET assigns the
                request a thread from the thread pool and executes the page on that thread.
              </p>

              <p>
                That’s enough theory for now.
                It’s time to look at some samples to get a better appreciation of how to
                implement asynchronous pages. The two examples address two common problems:
              </p>
              <ul>
                <li>Call a database operation asynchronously</li>
                <li>
                  Call a webservice—a current exchange rate service that converts between US$ and Euro.
                </li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Data Binding">
            Asynchronous Data Binding
            <Element Type="Text">

              <p>
                It is a common task to query databases
                and data bind the results. Using asynchronous pages to perform asynchronous
                data binding seems like a perfect symbiosis. The code behind class in Listing
                2-21 shows one way to go.
              </p>

            </Element>
            <Element Type="Listing" Name="Asynchronous binding to a data source (AsyncDataBind.aspx.cs)">

              using System;
              using System.Data;
              using System.Data.SqlClient;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;
              using System.Web.Configuration;

              public partial class AsyncDataBind : System.Web.UI.Page
              {
                  private SqlConnection _connection;
                  private SqlCommand _command;
                  private SqlDataReader _reader;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                      if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          // Register async methods
                          AddOnPreRenderCompleteAsync(
                              new BeginEventHandler(BeginAsyncOperation),
                              new EndEventHandler(EndAsyncOperation)
                          );
                      }
                  }
                  IAsyncResult BeginAsyncOperation (object sender, EventArgs e,
                      AsyncCallback cb, object state)
                  {
                      string connect = WebConfigurationManager.ConnectionStrings
                         [&quot;PubsConnectionString&quot;].ConnectionString;
                      _connection = new SqlConnection(connect);
                      _connection.Open();
                      _command = new SqlCommand
                          &quot;SELECT title_id, title, price FROM titles&quot;, _connection);
                      return _command.BeginExecuteReader (cb, state);
                  }
                  void EndAsyncOperation(IAsyncResult ar)
                  {
                      _reader = _command.EndExecuteReader(ar);

                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _reader;
                      Output.DataBind();
                  }

                  public override void Dispose()
                  {
                      if (_connection != null) _connection.Close();
                      base.Dispose();
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                The <code>AsyncDataBind</code> class uses the <code>AddOnPreRenderCompleteAsync</code> pattern. In its
                <code>BeginAsyncOperation</code>
                method, it calls <code>SqlCommand.BeginExecuteReader</code> to perform an asynchronous database query. When the call is
                completed, <code>EndAsyncOperation</code> calls
                <code>SqlCommand.EndExecuteReader</code> to get a <code>SqlDataReader</code>, which it
                stores in a private field. In an event handler for the <code>PreRenderComplete</code> event, which fires after the asynchronous operation completes but
                before the page is rendered, it binds the <code>SqlDataReader</code> to the Output <code>GridView</code> control. On
                the outside, the page looks like a normal synchronous page that uses a <code>GridView</code> to render the results of a database query. On the inside, this page
                is much more scalable >because it
                doesn't tie up a thread-pool thread waiting for the query to return.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Calling Web Services Asynchronously">
            Calling Web Services Asynchronously
            <Element Type="Text">

              <p>
                Another I/O-related task
                commonly performed by ASP.NET Web pages is calling to a Web service. Since Web
                service calls can take a long time to return, pages that execute them are ideal
                candidates for asynchronous processing.
              </p>

              <p>
                Listing 2-22 shows one way to build an asynchronous
                page that calls a Web service. It uses the same <code>AddOnPreRenderCompleteAsync</code> mechanism featured in this section. The page’s <code>Begin</code> method launches an asynchronous Web service call by calling the Web
                service proxy’s asynchronous <code>Begin</code> method. The page’s
                <code>End</code> method caches in a private field a reference to the <code>DataSet</code> returned by the Web method, and the <code>
                  PreRenderComplete
                </code> handler binds the <code>DataSet</code> to a
                <code>GridView</code>. For reference, the Web method targeted by the call is shown in the
                following code:
              </p>

            </Element>
            <Element Type="Listing" Name="Calling a webservice from an ASP.NET page asynchronously">

              [WebMethod]
              public DataSet GetTitles ()
              {
                  string connect = WebConfigurationManager.ConnectionStrings
                      [&quot;PubsConnectionString&quot;].ConnectionString;
                  SqlDataAdapter adapter = new SqlDataAdapter
                      (&quot;SELECT title_id, title, price FROM titles&quot;, connect);
                  DataSet ds = new DataSet();
                  adapter.Fill(ds);
                  return ds;
              }

            </Element>
            <Element Type="Listing" Name="AsyncWSInvoke1.aspx.cs">

              using System;
              using System.Data;
              using System.Configuration;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;

              public partial class AsyncWSInvoke1 : System.Web.UI.Page
              {
                  private WS.PubsWebService _ws;
                  private DataSet _ds;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                      if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          // Register async methods
                          AddOnPreRenderCompleteAsync(
                              new BeginEventHandler(BeginAsyncOperation),
                              new EndEventHandler(EndAsyncOperation)
                          );
                      }
                  }

                  IAsyncResult BeginAsyncOperation (object sender, EventArgs e,
                      AsyncCallback cb, object state)
                  {
                      _ws = new WS.PubsWebService();
                      // Fix up URL for call to local VWD-hosted Web service
                      _ws.Url = new Uri(Request.Url, &quot;Pubs.asmx&quot;).ToString();
                      _ws.UseDefaultCredentials = true;
                      return _ws.BeginGetTitles (cb, state);
                  }

                  void EndAsyncOperation(IAsyncResult ar)
                  {
                      _ds = _ws.EndGetTitles(ar);
                  }

                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _ds;
                      Output.DataBind();
                  }

                  public override void Dispose()
                  {
                      if (_ws != null) _ws.Dispose();
                      base.Dispose();
                  }
              }

            </Element>
            <Element Type="Text">
              <p>
                This is one way to do it, but
                it’s not the only way. The Web service proxy supports two mechanisms for
                placing asynchronous calls to Web services. One is the per-method <code>Begin</code>
                and <code>End</code> . The other is the
                new <code>MethodAsync</code> methods and <code>MethodCompleted</code> events.
                Even if the Begin/End pattern seems to be easy to read and adopt, because it is
                similar to the asynchronous pattern of the page’s handler, there are a few
                advantages to using the other pattern.
              </p>

              <p>
                If a Web service has a method
                named <code>Foo</code>, then in addition to having methods named
                <code>Foo</code>, <code>BeginFoo</code>, and
                <code>EndFoo</code>, a Web service proxy includes a method named
                <code>FooAsync</code> and an event named <code>FooCompleted</code>. You can
                call <code>Foo</code> asynchronously by registering a handler for the
                <code>FooCompleted</code> event and calling <code>FooAsync</code>, like this:
              </p>
              <pre>
                proxy.FooCompleted += new FooCompletedEventHandler (OnFooCompleted);
                proxy.FooAsync (...);
                ...
                void OnFooCompleted (Object source, FooCompletedEventArgs e)
                {
                    // Called when Foo completes
                }
              </pre>
              <p>
                The asynchronous call begins
                when <code>FooAsync</code> completes, and a <code>FooCompleted</code> event
                fires then, causing your <code>FooCompleted</code> event
                handler to be called. Both the delegate wrapping the event handler (<code>FooCompletedEventHandler</code>) and the second parameter passed to it (
                <code>FooCompletedEventArgs</code>) are generated with the Web service proxy. You can access
                <code>Foo’s</code> return value through <code>FooCompletedEventArgs.Result</code>.
              </p>

              <p>
                Listing 2-24 presents a code behind
                class that calls a Web service's GetTitles method asynchronously using the
                <code>MethodAsync</code> pattern. Functionally, this page is identical to the one shown in
                Listing 2-23. Internally, it’s quite different. AsyncWSInvoke2.aspx includes a
                <code>Page</code> directive with property <code>Async</code> set to
                true. But it doesn’t call <code>AddOnPreRenderCompleteAsync</code>; it registers a handler for <code>
                  GetTitlesCompleted
                </code> events and calls <code>GetTitlesAsync</code> on the
                Web service proxy. ASP.NET still delays rendering the page until
                <code>GetTitlesAsync</code> completes. Under the hood, it uses an instance of
                <code>System.Threading.SynchronizationContext</code>
                , a class that receives notifications when the asynchronous calls
                begin and when they complete.
              </p>

            </Element>

            <Element Type="Listing" Name="AsyncWSInvoke2.aspx.cs">

              using System;
              using System.Data;
              using System.Configuration;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;

              public partial class AsyncWSInvoke2 : System.Web.UI.Page
              {
                  private WS.PubsWebService _ws;
                  private DataSet _ds;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                     if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          // Call the Web service asynchronously
                          _ws = new WS.PubsWebService();
                          _ws.GetTitlesCompleted += new
                              WS.GetTitlesCompletedEventHandler(GetTitlesCompleted);
                          _ws.Url = new Uri(Request.Url, &quot;Pubs.asmx&quot;).ToString();
                          _ws.UseDefaultCredentials = true;
                          _ws.GetTitlesAsync();
                      }
                  }

                  void GetTitlesCompleted(Object source,
                      WS.GetTitlesCompletedEventArgs e)
                  {
                      _ds = e.Result;
                  }

                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _ds;
                      Output.DataBind();
                  }

                  public override void Dispose()
                  {
                      if (_ws != null) _ws.Dispose();
                      base.Dispose();
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                There are two advantages to using <code>MethodAsync</code> rather than <code>
                  AddOnPreRenderCompleteAsync
                </code> to implement asynchronous pages. Firstly,
                <code>MethodAsync</code> supports forwarding impersonation, culture, and
                <code>HttpContext.Current</code> to the <code>
                  MethodCompleted
                </code> event
                handler. Secondly, if the page makes multiple asynchronous calls and must delay
                rendering until all calls have been completed, using
                <code>AddOnPreRenderCompleteAsync</code> requires you to compose an <code>
                  IAsyncResult
                </code>
                that remains unsignaled until all the calls are finished. This is not necessary
                in <code>MethodAsync</code>; simply place the calls, as many of them as you like, and the
                ASP.NET engine will delay the rendering phase until the final call returns.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Tasks">
            Asynchronous Tasks
            <Element Type="Text">

              <p>
                <code>MethodAsync</code> is a convenient way to make
                multiple asynchronous Web service calls from an asynchronous page and delay the
                rendering phase until all the calls complete. Calling a Web service is not the
                only task that requires asynchronous programming. I/O-operations can be slow, too,
                especially when the server comes under pressure.
              </p>
            </Element>
            <Element Type="Section" Name="Register Asynchronous Tasks">
              <Element Type="Text">

                <p>
                  The <code>Page</code> class
                  introduces another method of facilitating asynchronous operations:
                  <code>RegisterAsyncTask</code>. <code>
                    RegisterAsyncTask
                  </code> has several advantages.
                  In addition to <code>Begin</code> and <code>End</code> methods,
                  <code>RegisterAsyncTask</code> lets you register a timeout method that’s called if an asynchronous
                  operation takes too long to complete. You can set the timeout declaratively by
                  including an <code>AsyncTimeout</code> attribute in the page’s
                  <code>Page</code> directive. For example, to set the timeout to ten seconds:
                </p>
                <pre>
                  AsyncTimeout=&quot;10&quot;
                </pre>
                <p>
                  The second advantage is that
                  you can call <code>RegisterAsyncTask</code> several times in one
                  request to register several asynchronous operations. As with
                  <code>MethodAsync</code> and all other solutions, ASP.NET delays rendering the page until
                  all operations have been completed. Thirdly, you can use the fourth parameter
                  of <code>RegisterAsyncTask</code> to pass the state to your <code>
                    Begin
                  </code>
                  methods. Finally, <code>RegisterAsyncTask</code> forwards
                  impersonation, culture, and <code>HttpContext.Current</code> to
                  the <code>End</code> and <code>Timeout</code> methods for
                  easy and transparent access. As mentioned earlier, the same is not true of an
                  <code>End</code> method registered with <code>AddOnPreRenderCompleteAsync</code>.
                </p>

                <p>
                  In other respects, an
                  asynchronous page that relies on <code>RegisterAsyncTask</code> is similar to one that relies on <code>
                    AddOnPreRenderCompleteAsync
                  </code>. The attribute in the page directive <code>
                    Async=&quot;true&quot;
                  </code> is still required, and it still executes as normal through the
                  <code>PreRender</code> event. Listing 2-25 demonstrates <code>
                    RegisterAsyncTask
                  </code> in a short example.
                </p>

              </Element>
              <Element Type="Listing" Name="AsyncPageTask.aspx.cs">

                using System;
                using System.Web;
                using System.Web.UI;
                using System.Web.UI.WebControls;
                using System.Net;
                using System.IO;
                using System.Text;
                using System.Text.RegularExpressions;

                public partial class AsyncPageTask : System.Web.UI.Page
                {
                    private WebRequest _request;

                    protected void Page_Load(object sender, EventArgs e)
                    {
                        PageAsyncTask task = new PageAsyncTask
                            new BeginEventHandler(BeginAsyncOperation),
                            new EndEventHandler(EndAsyncOperation),
                            new EndEventHandler(TimeoutAsyncOperation),
                            null
                        );
                        RegisterAsyncTask(task);
                    }

                   IAsyncResult BeginAsyncOperation(object sender, EventArgs e,
                        AsyncCallback cb, object state)
                    {
                        _request = WebRequest.Create(&quot;http://msdn.microsoft.com&quot;);
                        return _request.BeginGetResponse(cb, state);
                    }
                    void EndAsyncOperation(IAsyncResult ar)
                    {
                        string text;
                        using (WebResponse response = _request.EndGetResponse(ar))
                        {
                            using (StreamReader reader =
                                new StreamReader(response.GetResponseStream()))
                            {
                                text = reader.ReadToEnd();
                            }
                        }

                        Regex regex = new Regex(&quot;href\\s=\\s\&quot;([^\&quot;])\&quot;&quot;,
                            RegexOptions.IgnoreCase);
                        MatchCollection matches = regex.Matches(text);

                        StringBuilder builder = new StringBuilder(1024);
                        foreach (Match match in matches)
                        {
                            builder.Append(match.Groups[1]);
                            builder.Append(&quot;&lt;br/&gt;&quot;);
                        }
                        Output.Text = builder.ToString();
                    }

                    void TimeoutAsyncOperation(IAsyncResult ar)
                    {
                        Output.Text = &quot;Data temporarily unavailable&quot;;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  The primary advantage of <code>RegisterAsyncTask</code> is that it allows asynchronous pages to fire off multiple
                  asynchronous calls and delays rendering until all the calls have been completed.
                  It works equally well for one asynchronous call, and it offers a timeout option
                  that <code>AddOnPreRenderCompleteAsync</code>
                  does not provide. If you build an asynchronous page which makes
                  just one asynchronous call, you can use <code>AddOnPreRenderCompleteAsync</code> or
                  <code>RegisterAsyncTask</code>. But for asynchronous
                  pages that place two or more such calls, <code>RegisterAsyncTask</code> simplifies your life considerably.
                </p>

              </Element>
              <Element Type="Section" Name="Setting Properties">
                Setting Properties
                <Element Type="Text">

                  <p>
                    There are a number of relevant properties
                    that can be set programmatically. (It was not possible to demonstrate all
                    aspects in the sample code.) Please refer to the documentation to see what else
                    is possible and how to modify its behavior. The intention of this chapter is to
                    show ways to improve the overall performance of a web server through
                    understanding the basics of thread pooling and request handling.
                  </p>

                </Element>
              </Element>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Summary">
        Summary
        <Element Type="Text">
          <p>
            In this chapter you got in-depth
            information about the internal request processing and how to tweak the worker
            process and the threading. You got an idea how the thread pool works and how to
            extend the behavior. Using asynchronous process might increase performance and
            handle high workload. A custom thread pool was introduced to demonstrate how to
            change internal parts of the processing pipeline transparently. In a anticipation
            to Chapter 3 you got a first look into asynchronous handlers and there usage.
          </p>
        </Element>
      </Element>
    </Element>
  </Element>
</Content>