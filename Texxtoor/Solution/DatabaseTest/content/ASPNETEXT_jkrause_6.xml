<?xml version="1.0" encoding="utf-8" ?>
<Content>
  <Element Type="Opus" Name="ASP.NET Extensibility" Short="Explore how to break through ASP.NET's boundaries" Description="Pro ASP.NET Extensibility, a book for advanced users of ASP.NET.">
    ASP.NET Extensibility
    <Element Type="Section" Name="Understanding ASP.NET">
      Understanding ASP.NET
      <Element Type="Text">
        <p>In this chapter, we look under the covers of ASP.NET. Many fundamentals of ASP.NET just scratch the surface but to get the most out of the framework it is a good idea to look much deeper. </p>
        <p>Objectives in this chapter:</p>
        <ul>
          <li>Explain how ASP.NET works internally and highlight the relevant features needed for your everyday tasks.</li>
          <li>Outline the behind-the-scenes concepts: the application life cycle, the page life cycle and the control creation process.</li>
          <li>Cover the steps taken to translate your *.aspx and *.cs files into compiled code.</li>
          <li>Delve beyond the common ASP.NET features such as form stickiness and view state.</li>
        </ul>
      </Element>
      <Element Type="Section" Name="A Promise in Advance">
        A Promise in Advance
        <Element Type="Text">
          <p>
            ASP.NET is a powerful and flexible
            architecture for building web applications. The high level parts – WebForms and
            WebServices – are well-known. However, as your applications scale up in real
            life, sooner or later you encounter performance issues, or find that things which
            seemed easy become challenging. That is what this book provides – a look beyond
            the big picture. The little details are harder to understand and sometimes more
            abstract; less fun for more work. But let me begin with a promise: it’s worth
            the effort.
          </p>
        </Element>
      </Element>
      <Element Type="Section" Name="The Low Level Architecture of Request Handling">
        The Low Level Architecture of Request Handling
        <Element Type="Text">
          <p>
            Understanding the innermost parts of a
            platform is highly satisfying. You will feel confident knowing that you can
            write better applications and recognizing why they work. In this section we will
            examine the system level of ASP.NET in order to understand how requests flow
            through the processing pipeline. This is not aimed at those learning the basics
            or creating a simple interactive page. This is what you need to know when you
            write or build large sites which involve hundreds of pages handling requests
            from thousands of users.
          </p>
          <p>
            WebForms and WebServices are both
            sophisticated, high level implementations of HTTP handlers. They are built on
            top of the ASP.NET framework and exposed as default project templates. Most
            developers are happy with these project types, and are ignorant of, or
            misunderstand, the additional potential that exists. The basic HTTP handlers
            are built with managed code. This means that you can get highly customized
            behavior processing requests through the pipeline by using your very own code.
          </p>
        </Element>
        <Element Type="Section" Name="What is ASP.NET">
          What is ASP.NET
          <Element Type="Text">
            <p>
              In general terms, ASP.NET is a request
              processing engine. It takes an incoming request and passes it through its
              internal pipeline to an end point, where you as a developer can attach code to
              process that request. This engine is completely separate from HTTP runtime or
              the Web Server. In fact, the HTTP runtime is a component that you can host in
              your own applications outside of Internet Information Services (IIS) or any
              server side application altogether. Visual Studio and the integrated
              development server is a good example of an implementation that bypasses IIS.
            </p>

            <p>
              The HTTP runtime is responsible
              for routing requests through this pipeline, a complex yet very elegant
              mechanism. Several interrelated objects, extensible via subclassing or through
              interfaces, are available for customization work. This makes the framework
              highly adaptable. In this book I’ll cover most of these extensibility points and
              show that there are virtually no limits when using ASP.NET.
            </p>

            <p>
              Through this mechanism it’s
              possible to hook into low-level interfaces such as authentication,
              authorization, and caching. You can even filter content by routing incoming
              requests that match a specific signature directly to your code. Of course,
              there are a lot of different ways to accomplish the same thing – but all of the
              approaches are straightforward to implement.
            </p>

            <p>
              The ASP.NET engine was written
              entirely in managed code and all of the extensibility functionality is provided
              via “managed code extensions". The impressive part of ASP.NET is that it is very
              powerful but simple to work with. Despite its breadth and complexity, accomplishing
              your desired outcomes is easy. ASP.NET enables you to perform tasks that were previously
              the domain of ISAPI extensions and filters on IIS. ISAPI is a low-level Win32
              API that has a very spartan interface. It was very difficult to develop
              anything on top of this interface. Since ISAPI is low-level, it is very fast.
              But writing ISAPI filters in C++ is not included in most current application
              level development. Thus, for some time ISAPI development has been largely relegated
              to providing bridge interfaces to other application or platforms, such as PHP.
              But ISAPI did not become obsolete with the appearance of ASP.NET. The ASP.NET engine
              interfaces with IIS through an ISAPI extension. This extension hosts .NET
              through the ASP.NET runtime.
            </p>

            <p>
              ISAPI provides the core
              interface from the Web Server and ASP.NET uses the unmanaged ISAPI code portion
              to retrieve input and send output back to the client. The content that ISAPI
              provides is passed using common objects like<code>HttpRequest</code>
              and <code>HttpResponse</code> that expose the unmanaged data as managed objects. Back in the .NET
              world it becomes very easy to use these objects in your own code.
              I’ll later explain how the umanaged and managed world interoperate.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="The Lifetime of a Request">
          The Lifetime of a Request
          <Element Type="Text">

            <p>
              The lifetime starts with an ASP.NET
              request. Whenever the user types in a URL, clicks on a hyperlink, or submits an
              HTML form on the browser, a request is sent to the server.
            </p>

          </Element>
          <Element Type="Sidebar" SidebarType="Note">

            <header>Note</header>
            <aside>
              It’s essentially the same
              for web services. A client application calls an ASP.NET based Web Service by
              sending a request. Therefore, I refer to the term Request and don’t differentiate
              between Web Service and browser requests. You can assume that the examples given
              are intended to run in a browser environment.
            </aside>

          </Element>
          <Element Type="Text">
            <p>
              For the sake of clarity, we left out the
              steps made behind the scenes in the browser and through the protocol stacks. This
              includes port assignment within the TCP/IP stack and name resolution using the
              DNS protocol. As long as we’re talking about ASP.NET we have no direct
              influence on DNS, so let’s keep this in mind but not complicate the description
              with side effects.
            </p>

          </Element>
          <Element Type="Sidebar" SidebarType="Box" Name="Domain NAME SYSTEM">

            <header>Domain NAME SYSTEM</header>
            <aside>
              <p>
                The Domain Name System (DNS) is
                hierarchical naming system for internet resources. Mainly these are computers
                that get human readable names—the hostnames—the DNS translates into IP
                addresses. Beginning with some root servers the DNS is a hierarchy of name
                resolution servers for particular levels of the hostname. The protocol running
                between the servers and clients is called DNS protocol.
              </p>
              <p>
                The .NET Framework supports DNS with several
                classes. However, for ASP.NET applications usually there is no need to program
                directly against this low level protocol. The request we focus on begins when
                the name resolution process is done.
              </p>
            </aside>

          </Element>
          <Element Type="Text">
            <p>
              On the server side the web
              server picks up the request. In this description we focus mainly on ISS7 with
              some words for IIS6, which is still widely used. However, most parts will not
              refer to a specific version, so the term IIS covers all from IIS5 to IIS7 (and
              beyond, probably). Within IIS the request is usually routed to the aspx page.
              How this process works internally depends entirely on the HTTP handler that
              handles the request. The mapping between the .aspx extension and the ISAPI DLL,
              aspnet_isapi.dll, is responsible for this. Every request that handles
              applications extensions which we want to be served by ASP.NET must be routed
              that way. This means that the extension is a pre-defined, yet voluntary, definition.
              Imagine if you mapped .html pages to be processed by ASP.NET as well — it wouldn’t
              be obvious that ASP.NET was doing the trick.
            </p>

            <p>
              This means, too, that
              different extensions might route to different handlers. For instance, the .asmx
              extension is routed to the web service handler. Instead of opening a page and
              starting a page parser, this request does not open a file but a specially
              attributed class that identifies the implementation. Many other handlers are
              installed with ASP.NET and you are also able to define your own. All these
              handlers are mapped to the ASP.NET ISAPI extension and configured in web.config
              to get routed to a specific implementation.
            </p>

            <p>
              In coding terms the handler is a
              type, implemented by a .NET class that handles a specific extension. You can
              also attach your own handlers to existing extensions and route the request
              through both your own and the default implementation. The extension is the
              basic mapping where the processing starts. The basic mappings already available
              are shown in Table 1
            </p>

          </Element>
          <Element Type="Table" Name="Application mappings assigned to aspnet_isapi.dll">
            <table>
              <tr>
                <th>Extension</th>
                <th>Resource</th>
                <th>Type</th>
                <th>Comments</th>
              </tr>
              <tr>
                <td>.asax</td>
                <td>ASP.NET application files.</td>
                <td>Usually the global.asax file only.</td>
                <td></td>
              </tr>
              <tr>
                <td>.ascx</td>
                <td>ASP.NET user control files.</td>
                <td>Usually these files are not called directly.</td>
                <td></td>
              </tr>
              <tr>
                <td>.ashx</td>
                <td>HTTP handlers.</td>
                <td>The managed counterpart of ISAPI extensions; see chapter 3 for details.</td>
                <td></td>
              </tr>
              <tr>
                <td>.asmx</td>
                <td>ASP.NET web services.</td>
                <td>Obsolete since the appearance of Windows Communication Foundation (WCF).</td>
                <td></td>
              </tr>
              <tr>
                <td>.aspx</td>
                <td>ASP.NET web pages.</td>
                <td>The regular page handler.</td>
                <td></td>
              </tr>
              <tr>
                <td>.axd</td>
                <td>ASP.NET internal HTTP handler.</td>
                <td>Used for embedded resources like JavaScript or images pulled from compiled code.</td>
                <td></td>
              </tr>
              <tr>
                <td>.svc</td>
                <td>Web service handler.</td>
                <td>WCF based services now have its own extension.</td>
                <td></td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              Let’s talk about the asmx extension
              shown in the table. With the introduction of .NET 3.0, Microsoft moved all the
              communication stuff like .NET remoting and web services to Windows
              Communication Foundation (WCF) base library.
              This means that the ASP.NET based webservices are superseded. Even though they
              are still fully supported it makes sense to consider moving web service
              projects from ASP.NET platform to WCF. It’s not a significant change, as most
              classes are similar and WCF has some more powerful approaches. However, I don’t
              cover WCF in this book and therefore the following description is limited to
              the ASP.NET portion.
            </p>

          </Element>
          <Element Type="Section" Name="From ISAPI to ASP.NET">
            From ISAPI to ASP.NET
            <Element Type="Text">
              <p>
                The Internet Service API (ISAPI) is a common
                Win32 API to access IIS on a very low level. This means that it’s both fast and
                “unfriendly". The interface is optimized for performance but it’s also very
                simple and straightforward. For developers with .NET experience it’s pretty
                hard to use, because the coding style you use in .NET to, say, create sophisticated
                infrastructure solutions, is the opposite of the style you see when coding
                ISAPI extensions in C++. Many high level web development languages (such as
                PHP, Perl, and even ASP.NET) are built on top of ISAPI.
              </p>

              <p>
                ISAPI is good for writing such
                environments. For application developers it’s not the best way to write our
                sites on time and within budget. However, ISAPI is the layer our ASP.NET engine
                is built on and a good understanding is helpful for getting the most out of
                ASP.NET. For ASP.NET the ISAPI level is just acting as a routing layer. The
                heavy stuff, such as processing and request management, occurs inside the
                ASP.NET engine and is mostly done in managed code.
              </p>

              <p>
                You can think of ISAPI as a sort of
                protocol. This protocol supports two flavors, ISAPI extensions and ISAPI
                filters. Extensions act as a transaction interface; they handle the flow of
                data in to and out of the web server. Each request coming down the pipeline is
                going through the extensions and the code decides how they are treated. As you
                might imagine, ASP.NET is such an extension. ASP.NET has several ways to give
                you as much control as possible to hook into this extension and modify the
                default behavior. The low level ISAPI interfaces are now available as high
                level .NET interfaces, named IHttpHandler and IHttpModule. This is very
                powerful and still provides good performance, because it’s a well written balance
                between lean access to the lower level and an easy-to-use high level API.
              </p>

              <p>
                Like any other ISAPI extension the code
                is provided as a DLL and is hooked into the IIS management. You can find this
                DLL here:
              </p>

              <pre>&lt;.NET FrameworkDir&gt;\aspnet_isapi.dll</pre>

              <p>
                If you have several versions of .NET
                framework installed you may wonder why there is just one such DLL in the tree.
                I predict that you will find this in the v2.0.50727 folder or at least in one
                with v2.0 at the beginning. If you have .NET 1 installed, another version might
                reside in a folder named v1.1.x.  The reason is that Microsoft has added a lot
                of features in .NET 3.0 and .NET 3.5 regarding ASP.NET, but the low level
                interfaces are still the same. All new functionality is completely written in
                managed code. This is indeed a transition as it shows that it’s possible to
                write infrastructure components in managed code. With powerful hardware the
                performance loss is not that critical whereas the benefits regarding security,
                reliability, and shorter development cycles matter.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Note">
              <header>Note</header>
              <aside>
                With the upcoming .NET 4.0
                a new engine appears on the horizon that is closer to IIS7 and has several
                internal improvements. For now, it seems as though most of the techniques and
                internal behaviors described here have barely changed.
              </aside>
            </Element>
          </Element>
          <Element Type="Section" Name="The Extension mapping">
            The Extension mapping
            <Element Type="Text">

              <p>
                As you have already seen, the web
                server recognizes resource requests by analyzing the file extension. The first
                step to get the ASP.NET ISAPI extension running is a mapping between the
                several file types and the DLL I mentioned earlier. In IIS7 you can see this by
                following these steps:
              </p>
              <ul>
                <li>
                  Open Internet Information
                  Services (IIS) Manager
                </li>
                <li>Choose the server node</li>
                <li>
                  In the right pane scroll to the IIS
                  table
                </li>
                <li>Double click Handler Mappings</li>
              </ul>
              <p>
                In the table you will see a column Path
                with the extensions already assigned. In the column Handler you will see the
                assigned module. For the *.aspx extension there are these mappings:
              </p>
              <p>
                <ul>
                  <li>PageHandlerFactory-Integrated</li>
                  <li>PageHandlerFactory-ISAPI-2.0</li>
                </ul>
                <p>
                  Additionally, with .NET 4.0, two
                  additional mappings are installed (on a 32-bit machine):
                </p>
                <ul>
                  <li>PageHandlerFactory-Integrated-4.0</li>
                  <li>PageHandlerFactory-ISAPI-4.0_32bit</li>
                </ul>
              </p>

              <p>
                For the unmanaged side you will see the
                IsapiModule handler and for the managed one .NET types used to handle the
                pages.
              </p>

            </Element>
            <Element Type="Image" Name="IIS7 maps extensions like *.aspx to ISAPI extensions">
              images/19835f0101.png
            </Element>
            <Element Type="Text">
              <p>
                If the mapping isn’t there, ASP.NET is
                probably not correctly installed. Don’t try to map this by hand. There is a lot
                of configuration that happens behind the scenes. To register or re-register the
                mappings just invoke the following command:
              </p>
              <pre>cd &lt;.NetFrameworkDirectory&gt;</pre>
              <pre>aspnet_regiis - i</pre>
              <p>
                Again, this command is not available
                for all .NET framework versions. Version 2.0 will do the trick, even if you run
                3.0 or 3.5. With ASP.NET 4.0, a new ISAPI DLL will be introduced — but backward
                compatibility is still guaranteed. If you still have version 1.x sites running,
                there is another version available. It’s a bit tricky, but in order to run two
                different ASP.NET versions, just register with the highest available. In IIS6
                the properties of a specific site of a web server let you choose the right
                framework. In IIS7 it has been moved to the application pool settings dialog.
                Each application pool can run only one version of the runtime. To set another
                framework for a specific site, you have to create another application pool, set
                the appropriate framework version, and assign the application pool to the site.
              </p>
            </Element>
            <Element Type="Image" Name="Adding a new application pool and get the right framework there">
              images/19835f0102.png
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="The request comes in">
          The Request Comes in
          <Element Type="Text">
            <p>
              When a request comes in, IIS checks for
              the script map and routes the request to the associated extension. In case of
              ASP.NET we assume that the request is something like Default.aspx, so it’s
              being routed to aspnet_isapi.dll.
            </p>
          </Element>
          <Element Type="Image" Name="">
            images/19835f0103.png
          </Element>
          <Element Type="Text">
            <p>
              I assume that you have already worked
              with and probably configured the application pool. The application pool was
              introduced with IIS6 and allows the complete isolation of applications from
              each other. This means that IIS is able to completely separate things happening
              in one application from those in another. Putting applications together in one
              pool could still make sense, because another pool would create its own worker
              process and, as shown in Figure 1-3, could use up many resources. Separate applications make the web
              server more reliable. If an application hangs, consumes too much CPU time, or
              behaves unpredictably, it influences its entire pool. Other application pools
              (and the applications within them) will continue to run. Additionally, the
              application pools are highly configurable. You’ve already learned that the
              framework version can be different for each pool, which is very useful for
              migration scenarios. You can configure the security environment by choosing the
              impersonation level and customizing the rights given to a web application.
              Application pools are executables that run as any other program. This makes them
              easy to monitor and configure. Although this does not sound very “low level", application
              pools are highly optimized to talk directly to the kernel mode driver http.sys.
              Incoming requests are directly routed to the pool attached to the application.
              At this point you might be wondering where InetInfo is gone. It is still there,
              but it is basically just an administration and configuration service. The flow
              of data through the IIS system goes as directly and quickly as possible,
              straight down from http.sys to the application pools. This is one reason why
              IIS7 is much faster and more reliable than any other IIS before it.
            </p>

            <p>
              An IIS7 application pool also
              has intrinsic knowledge of ASP.NET and in turn ASP.NET can communicate with the
              new low level APIs that allow direct access to the HTTP Cache APIs. This can
              offload caching from the ASP.NET level directly into the Web Server’s cache,
              which again will improve performance drastically.
            </p>

            <p>
              In IIS7, ISAPI extensions run in
              the Application Pool’s worker process. The .NET Runtime also runs in this same
              process, and consequently communication between the ISAPI extension and the
              .NET runtime runs “in-process", which is inherently more efficient.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Getting into the .NET runtime">
          Getting into the .NET runtime
          <Element Type="Text">

            <p>
              Now let’s look at what happens to the
              request when accessing the managed level. The worker process w3wp.exe hosts the
              .NET runtime, and the ISAPI DLL calls into a small set of unmanaged interfaces
              via low level COM.
              Unfortunately, there is not much information available from Microsoft. Apart
              from a few blogs that we can’t always trust, it’s hard to say how the
              interaction between ASP.NET and ISAPI is made. Reading the manual doesn’t help
              either. Microsoft states that the API “supports the .NET Framework
              infrastructure and is not intended to be used directly from your code", which
              confirms the existence of the interface but nothing more.
            </p>

            <p>
              Using a disassembly tool like .NET Reflector
              (from red-gate.com) is one way to look into the details. Let’s examine the
              System.Web DLL, which contains everything we’d like to know. First, the entry
              point is the namespace System.Web.Hosting, where you’ll see how the runtime
              interacts with the ISAPI part.
            </p>

          </Element>
          <Element Type="Image" Name="If there is no information available we can use Reflector to reveal the internal code">
            images/19835f0104.png
          </Element>
          <Element Type="Text">
            <p>
              If the runtime handles a request, it
              calls the <code>ProcessRequest</code> method of the <code>IISAPIRuntime</code>interface.
              The interface is part of ISAPI and exposed as COM. The first parameter will
              return a pointer which gives access to the ISAPI module.
            </p>
          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" Name="Definition of the ProcessRequest method">
            [return: MarshalAs(UnmanagedType.I4)]
            int ProcessRequest([In] IntPtr ecb,
            [In, MarshalAs(UnmanagedType.I4)] int useProcessModel);
          </Element>
          <Element Type="Text">
            <p>
              The parameter called “ecb" returns the
              ISAPI Extension Control Block (ECB, (Microsoft)) that is passed as an unmanaged
              resource. The method takes the ECB and uses it as the base input and output
              interface used with the Request and Response objects. An ISAPI ECB contains all
              low level request information. This includes server variables, an input stream
              for form variables as well as an output stream that is used to write data back
              to the client. The output is later accessible via the Response objects, but you
              can see the tight relation between incoming request and outgoing response. The
              ecb pointer basically provides access to the functionality of an ISAPI request.
              The <code>ProcessRequest</code> method is the entry and exit point where this resource initially enters
              the street up to our managed code world and where the managed processing ends.
            </p>
          </Element>
          <Element Type="Section" Name="Threads and processes">
            Threads and processes
            <Element Type="Text">
              <p>
                So far things are not quite easy but
                the flow of the request through the code is straight. However, in real life
                things tend to become more complex. The ISAPI extension runs requests
                asynchronously. This means that the ISAPI extension immediately returns on the
                calling worker process or IIS thread, but keeps the ECB for the current request
                alive. The ECB then includes a mechanism for letting ISAPI know when the
                request is complete. This asynchronous processing releases the ISAPI worker
                thread immediately, and forwards processing to a separate thread that is
                managed by ASP.NET. We’ll look into threading later to understand what ASP.NET
                is doing. For now, ASP.NET receives this ECB reference and uses it internally
                to retrieve information about the current request.
              </p>
              <p>
                This includes such information as
                server variables, POST data, and output returning to the server. The ECB data
                block stays alive until the request finishes or times out in IIS. The ASP.NET
                engine continues to communicate with it until the request is done. Any output
                is written into the ISAPI output stream using the appropriate method call and
                when the request is done, the ISAPI extension is notified of request
                completion. The extension will then free the ECB from memory. Just remember
                that in this cruel unmanaged world the code is responsible for handling all
                in-memory actions, and not releasing memory leads to memory leaks. However, the
                implementation is very efficient as the .NET classes essentially act as a thin
                wrapper around ISAPI.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name="Loading the .NET runtime">
            Loading the .NET runtime
            <Element Type="Text">
              <p>
                Again, there is not much information
                available about the loading procedure. I assume that the runtime is loaded, if
                not yet present, when the first request to ASP.NET is made by a mapped
                extension. The managed <code>ISAPIRuntime</code> is then
                instantiated and starts talking to the unmanaged world. For isolation purposes,
                each virtual directory creates a new application domain (AppDomain). Within
                this AppDomain the <code>ISAPIRuntime</code> resides.
                Starting the application is also the beginning of the application’s life cycle,
                which we’ll look into later in this chapter. It’s also likely that the
                instantiation is made by the unmanaged part, because the wrapper interface is
                exposing the <code>ComVisible</code> attribute. This makes it
                available from the other side.
              </p>

              <p>
                To create the ISAPIRuntime instance the
                <code>AppDomainFactory.Create</code> method is called. The following code snippet, created with
                Reflector, shows how it’s done internally.
              </p>

            </Element>
            <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="The code of the AppDomainFactory.Create method">
              [return: MarshalAs(UnmanagedType.Interface)]
              public object Create(string appId, string appPath)
              {
              object obj2;
              try
              {
              if (appPath[0] == '.')
              {
              FileInfo info = new FileInfo(appPath);
              appPath = info.FullName;
              }
              if (!StringUtil.StringEndsWith(appPath, '\\'))
              {
              appPath = appPath + @&quot;\&quot;;
              }
              ISAPIApplicationHost appHost = new ISAPIApplicationHost(appId, appPath, false);
              ISAPIRuntime o = (ISAPIRuntime) this._appManager.CreateObjectInternal(style='font-family: Wingdings'>
              appId, typeof(ISAPIRuntime),
              appHost, false, null);
              o.StartProcessing();
              obj2 = new ObjectHandle(o);
              }
              catch (Exception)
              {
              throw;
              }
              return obj2;
              }
            </Element>
            <Element Type="Text">
              <p>
                Even if it is not visible in this code
                snippet, internally the appId is used to cache the relation with the requested
                virtual directory. Therefore subsequent calls do not start the application
                again but process the existing <code>AppDomain</code>. Finally, in
                this code <code>StartProcessing</code> forces ISAPI to process the request, and, because it is
                asynchronous, the call returns immediately and the method returns the ECB as type
                <code>object</code>.
              </p>
            </Element>
            <Element Type="Image" Name="Behind the scenes the first request is responsible for the creation of a new application">
              images/19835f0105.png
            </Element>
          </Element>
          <Element Type="Section" Name="Handle the Request within the Runtime">
            Handle the Request within the Runtime
            <Element Type="Text">
              <p>
                The managed part is now alive and ISAPI
                is able to call it whenever there is something available for processing. In
                basic ASP.NET terms everything begins here. The AppDomain, the application life
                cycle and the first page cycle are born here and live for varying lengths of
                time. From now on, we’re back in the managed world. But there is a bit more you
                should know about the whole procedure. IIS is a multithreaded host and so is
                ISAPI. Each request is processed asynchronously, running in its own thread.
                Again, a look into the code using Reflector reveals what ASP.NET is doing here.
                The <code>ProcessRequest</code> method receives an ISAPI ecb object and server type as parameters.
                The method is thread safe, so multiple ISAPI threads can safely call this
                single returned object instance simultaneously.
              </p>

            </Element>
            <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >
              public int ProcessRequest(IntPtr ecb, int iWRType)
              {
              IntPtr zero = IntPtr.Zero;
              if (iWRType == 2)
              {
              zero = ecb;
              ecb = UnsafeNativeMethods.GetEcb(zero);
              }
              ISAPIWorkerRequest wr = null;
              try
              {
              bool useOOP = iWRType == 1;
              wr = ISAPIWorkerRequest.CreateWorkerRequest(ecb, useOOP);
              wr.Initialize();
              string appPathTranslated = wr.GetAppPathTranslated();
              string appDomainAppPathInternal = HttpRuntime.AppDomainAppPathInternal;
              if ((appDomainAppPathInternal == null)
              || StringUtil.EqualsIgnoreCase(appPathTranslated, appDomainAppPathInternal))
              {
              HttpRuntime.ProcessRequestNoDemand(wr);
              return 0;
              }
              HttpRuntime.ShutdownAppDomain( ApplicationShutdownReason.PhysicalApplicationPathChanged,
              SR.GetString(&quot;Hosting_Phys_Path_Changed&quot;, new object[] { appDomainAppPathInternal, appPathTranslated }));
              return 1;
              }
              catch (Exception exception)
              {
              // removed for sake of clarity
              }
              }
            </Element>
            <Element Type="Text">

              <p>
                The code is just a part of the complete
                method. I have removed the catch block to focus on the working code. The method
                receives the pointer to an ECB data block and passes it to the <code>CreateWorkerRequest</code>
                method. This method is responsible for creating the <code>ISAPIWorkerRequest</code>
                object. From now on we have a <code>Request</code>
                object available that is able to talk directly to the ISAPI layer.
              </p>

              <p>
                The <code>ISAPIWorkerRequest</code> (defined in the <code>System.Web.Hosting</code>
                namespace) class is an abstract subclass of <code>HttpWorkerRequest</code>. This class holds all the knowledge to talk HTTP. It’s a piece of
                cake, and although it would take too much time to go into here, it’s worth a
                closer look if you like. I’d encourage you to go on and find out how things
                work under the hood. Just open the method <code>ProcessRequest</code> in Reflector, click on <code>ISAPIWorkerRequest</code>
                and then on the HttpWorkerRequest subclass. At the end of the
                listing of signatures of either class click on the link Expand Methods and there
                you have it. Because we have an abstract class, eventually there must be some
                implementation elsewhere. The factory method that creates the type using <code>CreateWorkerRequest</code>
                method, is able to return one of the following four types
                available:
              </p>
              <ul>
                <li>
                  <code>ISAPIWorkerRequestInProcForIIS7</code>
                </li>
                <li>
                  <code>ISAPIWorkerRequestInProcForIIS6</code>
                </li>
                <li>
                  <code>ISAPIWorkerRequestInProc</code>
                </li>
                <li>
                  <code>ISAPIWorkerRequestOutOfProc</code>
                </li>
              </ul>
              <p>
                It’s a Bit in the ECB that drives the
                decision. This means that finally the ISAPI module controls the way ASP.NET
                handles requests. Because ASP.NET is not limited to IIS, it’s simply the
                version of IIS that is responsible. <code>ISAPIWorkerRequestInProc</code> is for all IIS versions up to and including version 6 and IIS7
                serves all versions from 7 and above. This sounds silly—there is no IIS8 in
                existence—but the ASP.NET engine would be robust against new versions as long
                as the ISAPI module is able to emulate IIS7 behavior.
              </p>

              <p>
                Whenever you have trouble understanding
                what is going on in your application, whether it’s with creating and sending
                headers, receiving weird stuff, or getting wrong data down the wire, it’s worth
                taking a closer look here. <code>HttpWorkerRequest</code> is
                meant to provide a high level abstraction around the low level interfaces,
                regardless of the source of the data. However, reading and understanding are two
                different things. Let’s take an example of how to deal with all the internals.
                The next listing shows you how the well known QueryString is retrieved from the
                ECB. Moving down the class hierarchy, we find that it’s partly implemented in
                the base class and partly in the <code>ISAPIWorkerRequestInProc</code> class. For IIS6 and IIS7 there is no distinct change here, so we
                can skip these classes for now.
              </p>

            </Element>
            <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >
              internal override int GetQueryStringRawBytesCore(byte[] buffer, int size)
              {
              if (base._ecb == IntPtr.Zero)
              {
              return 0;
              }
              return
              UnsafeNativeMethods.EcbGetQueryStringRawBytes(base._ecb, buffer, size);
              }
              [DllImport(&quot;webengine.dll&quot;)]
              internal static extern int EcbGetQueryStringRawBytes(IntPtr pECB, byte[] buffer, int size);
            </Element>
            <Element Type="Text">

              <p>
                Again, there is nothing thrilling here.
                These classes are all very thin wrappers around native method calls. In fact,
                ASP.NET does not provide any significant overhead to the request procedure.
                That means ASP.NET is extremely fast — as fast as IIS with native code. If you
                feel (or know) that your application is slow, then you know that in most cases it
                will be a problem in your code. Let’s focus on the managed side of the world
                and learn more about what’s going on here.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="HttpContext and HttpApplication">
          HttpContext and HttpApplication
          <Element Type="Text">
            <p>
              You’re probably already familiar with
              the HttpContext and HttpApplication classes. Instances of these classes are
              created whenever a request hits the engine. At a glance, the steps are:
            </p>
            <ul>
              <li>
                Create a new <code>HttpContext</code> instance for the request
              </li>
              <li>
                Retrieve an <code>HttpApplication</code> instance (or create one, if it’s the first request)
              </li>
              <li>
                Call <code>HttpApplication.Init</code> to set up pipeline events
              </li>
              <li>
                Call <code>HttpApplication.ResumeProcessing</code> to start the ASP.NET pipeline processing
              </li>
            </ul>
          </Element>
          <Element Type="Section" Name="Wrapping the Request: HttpContext">
            Wrapping the Request: HttpContext
            <Element Type="Text">
              <p>
                The context of an HTTP request is
                available throughout the lifetime of the request. For ease of use it’s always
                accessible through the static <code>HttpContext.Current</code>
                property. Because every request usually starts a new thread, your code runs in
                that thread. In chapter 2 I’ll explain in more detail the thread and processing
                behavior. For now, this isn’t needed to understand the request processing on the
                context level. The current context has a one-to-one relation to the request for
                that thread. This context object is also the place where all other objects
                required to process the request are stored: <code>Request</code>, <code>Response</code>,
                <code>Application</code>, <code>Server</code>, and
                <code>Cache</code>. At any time
                during request processing <code>HttpContext.Current</code>
                gives you access to all these. There are several shortcuts, so you may use the Page’s
                property <code>Context</code> instead, but it’s exactly the same object.
              </p>

              <p>
                You may already use several collections
                available in the <code>Application</code>, <code>Session</code>,
                and <code>Cache</code> objects. Even the
                <code>HttpContext</code> class contains a useful collection that provides a store for
                request specific data. The big difference to the other data collections is the
                life time. The <code>HttpContext</code> represents exactly the
                current request. If the processing is finished and the data sent to the server,
                then the collections are also disposed of. However, the Context exists before
                the page’s life span begins and ends after it finishes. This data storage is therefore
                a bit more powerful than simple page members.
              </p>

              <p>
                The following sample shows how to use <code>Context.Items</code>
                to get information about the request processing elapsed time. At
                the <code>BeginRequest</code> event a timestamp is stored and retrieved later at
                <code>EndRequest</code>.
              </p>
              <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Get request information using events in global.asax">
                Application_BeginRequest(object sender, EventArgs e)
                {
                if (Settings.Default.Logging)
                {
                Context.Items.Add(&quot;LogTime&quot;, DateTime.Now);
                }
                }

                protected void Application_EndRequest(object sender, EventArgs e)
                {
                if (Settings.Default.Logging)
                {
                DateTime end = DateTime.Now;
                TimeSpan span = end.Subtract((DateTime) Context.Items[&quot;LogTime&quot;]);
                System.Diagnostics.Debug.WriteLine(span.TotalMilliseconds, &quot;RequestTime&quot;);
                }
                }
              </Element>
              <Element Type="Text">
                <p>
                  This sample uses two events defined in
                  the global.ascx code behind file. You might be thinking of how to put the
                  results into a database or log file, but for now the output to a Visual Studio
                  console window will do.
                </p>
              </Element>
              <Element Type="Image" Name="Get time information about the request while debugging">
                images/19835f0106.png
              </Element>
              <Element Type="Text">

                <p>
                  If you feel that the values shown in
                  the figure are too high, you need to be aware that I’m running the entire
                  environment in a Virtual PC console, and that the timestamps shown are expressed
                  in milliseconds.
                </p>

              </Element>
            </Element>
          </Element>
          <Element Type="Section" Name="The most basic type: HttpApplication">
            The most basic type: HttpApplication
            <Element Type="Text">

              <p>
                The <code>HttpApplicationFactory</code> is responsible for creating an appropriate number of <code>HttpApplication</code> objects.
                The load and the number of threads required affect how it handles
                incoming requests. The size of the pool is limited to the <code>MaxWorkerThreads</code>
                setting in the ProcessModel key in the machine.config, which by
                default is 20. Since the days of .NET 2.0 it’s still an auto-configured entry:
              </p>
              <pre>
                &lt;processModel
                autoConfig=&quot;true&quot; /&gt;
              </pre>
              <p>Change this to the following:</p>

              <pre>
                &lt;processModel
                autoConfig=&quot;false&quot; maxWorkerThreads=&quot;30&quot; /&gt;
              </pre>

              <p>
                You can find more information about
                threading in chapter 2.
              </p>

              <p>
                The pool starts out with a smaller
                number— usually one — and it then grows as multiple simultaneous requests are processed.
                The pool is monitored so that under load it grows to a maximum number of
                instances. Later the pool is scaled back to a smaller number as the load drops.
                Once we have the right number of instances of <code>HttpApplication,</code> we have the real entry point within the managed world for an
                incoming request. <code>HttpApplication</code> is like
                an outer container for the whole application. For easy access the events
                related to the application are mapped in the global.asax file, which is the
                declarative expression of this class. The definition of global.asax in
                global.asax.cs reveals:
              </p>

              <pre>
                public class Global :
                System.Web.HttpApplication
              </pre>

              <p>
                The pipeline the request is going
                through fires several events to let you control and intercept the various states
                of the application’s life cycle. The following list shows all of them, even if
                the majority are never used in an application. In the next few sections I’ll
                dig deeper into the world of application events.
              </p>

            </Element>
            <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Events available on application level (pulled from HttpApplication)">
              public event EventHandler AcquireRequestState;
              public event EventHandler AuthenticateRequest;
              public event EventHandler AuthorizeRequest;
              public event EventHandler BeginRequest;
              public event EventHandler Disposed;
              public event EventHandler EndRequest;
              public event EventHandler Error;
              public event EventHandler LogRequest;
              public event EventHandler MapRequestHandler;
              public event EventHandler PostAcquireRequestState;
              public event EventHandler PostAuthenticateRequest;
              public event EventHandler PostAuthorizeRequest;
              public event EventHandler PostLogRequest;
              public event EventHandler PostMapRequestHandler;
              public event EventHandler PostReleaseRequestState
              public event EventHandler PostRequestHandlerExecute;
              public event EventHandler PostResolveRequestCache;
              public event EventHandler PostUpdateRequestCache;
              public event EventHandler PreRequestHandlerExecute;
              public event EventHandler PreSendRequestContent;
              public event EventHandler PreSendRequestHeaders;
              public event EventHandler ReleaseRequestState;
              public event EventHandler ResolveRequestCache;
              public event EventHandler UpdateRequestCache;
            </Element>
            <Element Type="Text">
              <p>
                By writing something like the following
                into the code behind file, you attach a handler:
              </p>

              <pre>
                protected void
                Application_BeginRequest(object sender, EventArgs e)
              </pre>

              <p>
                Avoiding an explicit delegate
                definition is just for the sake of convenience.
              </p>
              <p>
                The whole handling of <code>AppDomain</code>, <code>HttpApplication</code>, and threads might look
                confusing. Remember that the server has to handle multiple incoming requests
                simultaneously. Each ASP.NET application runs in its own AppDomain, where
                several instances of <code>HttpApplication</code> can run
                in parallel, supplied from the pool managed by the factory. To get a better understanding
                of this, let’s examine the information we can extract from related objects.
              </p>

            </Element>
            <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Retrieving information about the application">

              protected void Page_Load(object sender, EventArgs e)
              {
              Guid appId = ((Global) Context.ApplicationInstance).AppId;
              this.appId.Text = appId.ToString();
              this.threadId.Text = Thread.CurrentThread.ManagedThreadId.ToString();
              this.domainId.Text = AppDomain.CurrentDomain.FriendlyName;
              this.threadInfo.Text = Thread.CurrentThread.IsThreadPoolThread ?
              &quot;Pool Thread&quot; : &quot;No Thread&quot;;
              this.threadApart.Text = Thread.CurrentThread.GetApartmentState().ToString();
              Thread.Sleep(4000);
              }

            </Element>
            <Element Type="Text">

              <p>
                The <code>Sleep</code> call
                allows you to open several browser instances and hit F5 to refresh the page
                within the four second period in order to see how it works. This simulates the
                behavior when several requests come in while previous requests are still
                running.
              </p>

              <p>
                An application by definition has no
                internal id. To create one, add the following code to the global.asax code
                behind:
              </p>

              <code>internal Guid AppId = Guid.NewGuid();</code>

              <p>
                Figure 1-7 shows three screens made
                within the four second period using three different browser windows.
              </p>

            </Element>
            <Element Type="Image" Name="The application’s id changes, as the thread id does">
              images/19835f0107.png
            </Element>
            <Element Type="Text">
              <p>
                You can see that the
                application id and the thread id change. If you remove the <code>Sleep</code>
                command and request the pages one by one, the application id is
                always the same. Usually the thread is recycled from the pool and the id is also unchanged.
              </p>
              <p>
                The abbreviation ‘MTA’ for the
                thread’s apartment model stands for Multi Threaded Apartment. You can override
                this apartment state in ASP.NET pages with the <code>ASPCOMPAT=&quot;true&quot;</code> attribute in the <code>@Page</code> directive. <code>ASPCOMPAT</code>
                is meant to provide COM components with a safe environment in which
                to run. <code>ASPCOMPAT</code> uses special Single Threaded Apartment (STA) threads to service
                those requests. STA threads are set aside and pooled separately as they require
                special handling. As long as there you have multi threaded COM component in
                your application only, you can simply ignore this. For single threaded
                components some additional work is required. Usually a well developed COM
                component should support multiple threads.
              </p>
              <p>
                It is a simple fact that all <code>HttpApplication</code>
                objects are in the same AppDomain. This has, however, some
                influence on their behavior. If you change something in the page’s code or
                web.config, the application restarts. To be more precise, it’s actually the
                AppDomain which is being shut down and restarted. This ensures that all currently
                existing <code>HttpApplication</code> instances are also shut down and recreated. To see this behavior in
                action, open the example shown in Listing 1-5 and launch it. Hit F5 several
                times and notice that the Domain ID value is still the same. Now change
                something in the web.config file. This forces a shutdown and therefore the
                creation of a new AppDomain. The Domain ID value is now different.
              </p>
              <p>
                Currently running requests are
                being processed properly, even if the new AppDomain is already up and running.
                To avoid old threads blocking resources, the request has a specific time out
                value. Once timed out, the threads are shut down and the request’s “life" ends.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Flowing through the ASP.NET Pipeline">
          Flowing through the ASP.NET Pipeline
          <Element Type="Text">
            <p>
              You now have a good overview firstly of
              what happens when a request comes in, and secondly of how the objects start up
              as they wait to be used in your code. There are several steps following this
              startup sequence worth investigating further. In each step you’ll find events
              and callbacks to intercept the process and customize or optimize its behavior.
            </p>
            <p>
              Figure 1-8 illustrates what happens
              during the various states. If you look into the code using Reflector, you can
              find the steps in subclass <code>ApplicationStepManager</code>
              and the additional steps for IIS7 in <code>PipelineStepManager</code>.
            </p>

          </Element>
          <Element Type="Image" Name="Events that build the pipeline">
            images/19835f0108.png
          </Element>
          <Element Type="Text">

            <p>
              The most important information here is
              that modules precede handlers. They are loaded and executed at the particular
              state of the processing pipeline, if configured properly in web.config file.
              The figure shows only the minimum number required to execute a page. You’ll
              find a closer look at all these events in the next section. For now, it’s
              enough to know when and why the modules and handlers get executed. This is the
              major part of the pipeline business, and I’ll go into more detail in the next
              section.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Modules and Handlers using HttpModule and HttpHandler">
          Modules and Handlers using HttpModule and HttpHandler
          <Element Type="Text">
            <p>
              <code>HttpApplication</code> and
              <code>HttpContext</code> are merely containers for incoming messages. They build the
              pipeline by forming a chain of events that commence in a defined order, and
              they hold together data related to the request, in order to give other
              instances easy access to the information involved in the process. However, the
              real work is done in other processing units, particularly the modules and
              handlers. Modules are built on top of the <code>HttpModule</code>
              class. Handlers are built on top of the <code>HttpHandlers</code>
              class. Both are abstract classes and need concrete implementations. In
              addition, both are highly configurable and act as a chain of instances. That
              means that you can attach as many modules and handlers as you like and the
              request will flow through all these instances.
            </p>

            <p>
              Several tasks could be handled
              in both levels — however, there is a different intention behind them. Modules
              tend to control tasks on a lower level; their nature is more basic than that of
              handlers. Think of modules as the right place to prepare data being processed
              by handlers or modify data subsequently when the regular treatment by a handler
              is completed. IIS programming aficionados can think of modules as ISAPI
              filters. The good news is that programming ASP.NET modules using .NET is much
              easier than developing filters for IIS. Moving on from IIS, let’s focus on the
              amazing things that become possible as we extend ASP.NET.
            </p>

            <p>
              The natural order of modules and
              handlers is:
            </p>
            <ol>
              <li>Use module to pre-process a request</li>
              <li>Use handler to process the request</li>
              <li>Use module again to post-process the request</li>
            </ol>
            <p>
              ASP.NET comes with several default
              handlers, such as the very basic ones for *.aspx pages or web services. Some default
              modules exist that are responsible for simple tasks like authentication and
              caching. In an ideal world, the modules are transparent to the handlers. This
              means that handlers don’t know about the modules that work before or after their
              own processing. ASP.NET allows several easy ways to create your own modules and
              handlers. This is usually the first approach of extending the standard behavior
              of ASP.NET. Let’s take a closer look at this technique.
            </p>

          </Element>
          <Element Type="Image" Name="Modules and Handlers fit closely in the ASP.NET model">
            images/19835f0109.png
          </Element>
          <Element Type="Text">
            <p>
              In Chapter 3, we’ll take a closer look at
              the process of developing custom modules and custom handlers with some clever examples.
              By now it’s enough to know that several modules process the request one after
              another on both, the request and the reponse path. Whereas only one handler
              processes the request finally, either an internal handler or a custom one.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="The Life Cycles">
          The Life Cycles
          <Element Type="Text">
            <p>
              The life cycle is a term used in almost
              every introduction to ASP.NET. This term is absolutely important for a complete understanding
              and the correct usage of ASP.NET.
            </p>
            <p>
              To break things down we can divide the different
              life cycles into three parts:
            </p>
            <ol>
              <li>
                The application’s life cycle
              </li>
              <li>
                The page’s life cycle
              </li>
              <li>
                The control’s life cycle
              </li>
            </ol>
            <p>
              The following sections covers this
              in-depth. The behavior of the cycles is slightly different between IIS versions
              but the overall description is the same. The following explanations focus on
              IIS7 and Framework 3.5 behavior, which is valid for .NET 2.0 up to the upcoming
              4.0.
            </p>
            <p>
              IIS7 can run in two different modes. The
              IIS integrated mode is the new native one, whereas the classic mode mimics the
              behavior of IIS5 or IIS6. The integrated mode has several advantages and should
              be preferred if there is no explicit requirement to step down.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="The IIS7 integrated pipeline">
        The IIS7 integrated pipeline
        <Element Type="Text">
          <p>
            The IIS7 integrated pipeline is a
            unified request processing pipeline. Each incoming request is handled by this
            pipeline and routed through the internal parts of IIS. The pipeline supports
            both managed and native code modules. You may already know about creating
            managed modules based on the <code>IHttpModule</code> interface.
            Once implemented and hooked into the pipeline, the module receives all events
            used to interact with the request passing through the pipe.
          </p>
          <p>
            The term “unified request processing
            pipeline" needs some more investigation. IIS6 provided two different pipelines:
            one for native and one for managed code. This is obviously for historical
            reasons, because the managed world came after the IIS world. In IIS 7 both
            pipelines united to become the unified request processing pipeline. For ASP.NET
            developers this has several benefits:
          </p>
          <ul>
            <li>
              The integrated pipeline raises
              all exposed events, which enables existing ASP.NET modules to work in the
              integrated mode.
            </li>
            <li>
              Both native-code and managed-code
              modules can be configured at the Web server, Web site, or Web application
              level.
            </li>
            <li>
              Managed-code modules can be invoked
              at any stage in the pipeline.
            </li>
            <li>
              Modules are registered and
              enabled or disabled through an application’s Web.config file.
            </li>
          </ul>
          <p>
            The configuration of modules includes
            the built-in ASP.NET managed-code modules for session state, forms
            authentication, profiles, and role management. Furthermore, managed-code
            modules can be enabled or disabled for all requests, regardless of whether the
            request is for an ASP.NET resource like an .aspx file.
          </p>
          <p>
            Invoking modules at any stage means that
            this may happen before any server processing occurs for the request, after all
            server processing has occurred, or anywhere in between.
          </p>

        </Element>
      </Element>
      <Element Type="Section" Name="The Application’s Pipeline">
        The Application’s Pipeline
        <Element Type="Text">

          <p>
            In more generic terms the pipeline
            describes the flow through several instances within the IIS. Each step
            processes the request in a distinct way and fires appropriate events. This
            forces interactions with the modules and applications attached by
            configuration. The variety of actions you can perform ranges from none to total
            control. However, doing nothing lets the built-in modules accomplish their job
            and handle the basic page processing. From the perspective of the extensibility
            of ASP.NET, “total control" is what we’re looking for.
          </p>

        </Element>
        <Element Type="Image" Name="Application’s life cycle events">
          images/19835f0110.png
        </Element>
        <Element Type="Text">

          <p>
            Two states are new in IIS7: Map Handler
            and Log Request. This gives developers much more control over the request
            process. Some modules are managed whereas others are written in native code.
            You can add your own modules in either way. However, as a .NET developer, you’d
            probably prefer writing in managed code and indeed I would strongly recommend
            this. (Native code is an option if you need to create a high performance module
            which performs simple functions.)
          </p>

        </Element>
        <Element Type="Section" Name="The Request Arrives">
          The Request Arrives
          <Element Type="Text">
            <p>
              The application life cycle begins when a
              request is made for an application resource sent by a client application, such
              as a browser, to the Web server. In integrated mode, the unified pipeline
              handles all requests. When the pipeline receives a request, it’s being passed
              through stages that are common to all requests. These stages are represented internally
              by the <code>RequestNotification</code> enumeration. All request stages can be configured to allow
              developers to take advantage of ASP.NET functionality. That functionality is
              encapsulated in managed-code modules that have access to the request pipeline. For
              instance, even though the .htm filename extension is not mapped by default to
              ASP.NET, a request for an HTML page still invokes ASP.NET modules. This enables
              you to take advantage of ASP.NET authentication and authorization for all
              resources.
            </p>
          </Element>
          <Element Type="Section" Name="The unified pipeline receives the first request">
            The unified pipeline receives the first request
            <Element Type="Text">

              <p>
                When the unified pipeline receives the
                first request for any resource in an application, an instance of the <code>ApplicationManager</code> class is created.
                This builds the application domain (AppDomain) in
                which the request is processed. Application domains provide isolation between
                applications for global variables and enable each application to be unloaded
                separately. In the application domain, an instance of the <code>HostingEnvironment</code> class is created, which provides access
                to information about the application, such as the name of the folder where the application is stored.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Tip">
              <header>Tip</header>
              <aside>
                When an application operates
                in the context of Visual Studio while you run a debug session, the application
                starts with the launch of the integrated web server. When the debug session
                ends and you launch the application again using the F5 key, the integrated web
                server will run the same application domain. This means that between the debug
                sessions no new application life cycle is being started. To force restarting
                the application you can right click the notification icon in the system tray
                and stop the web server.
              </aside>
            </Element>
            <Element Type="Text">

              <p>
                The first request has several additional
                tasks. You will notice this because the elapsed time for the page to be delivered
                is longer than for all subsequent requests. During the first request, top-level
                items in the application are compiled, if required. This includes application
                code in the project. By the way, since the days of Visual Studio 2008, there is
                no longer a special code folder named App_Code. Even if you name a folder this,
                it will have no special function. Code that resides in any folder at any level
                is compiled in one assembly per project.
              </p>

            </Element>
          </Element>
          <Element Type="Section">
            Response objects are created for each request
            <Element Type="Text">

              <p>
                After the application domain has been
                created and the <code>HostingEnvironment</code>
                object has been instantiated, application objects such as <code>HttpContext</code>, <code>HttpRequest</code>, and
                <code>HttpResponse</code> are created and initialized. These objects exist throughout the
                lifetime of the request and give developers full access to all related data.
              </p>

              <p>
                The <code>HttpContext</code>
                class contains objects that are specific to the current application request,
                such as the <code>HttpRequest</code> and <code>HttpResponse</code> objects. The <code>HttpRequest</code> object contains
                information about the current request, which includes cookies and browser
                information. The <code>HttpResponse</code> object
                contains the response that is about to be send to the client, which includes
                all rendered output and header data, such as cookies. <code>HttpContext.Current</code> gives you permanent access to the
                current context through a static method. For easy access the <code>Page</code> class has
                properties like <code>Request</code> and <code>Response</code> that return instances of the very same related objects.
              </p>

            </Element>
            <Element Type="Section">
              Differences between IIS6 and IIS7
              <Element Type="Text">

                <p>
                  We’re currently in the
                  transition period from IIS6 to IIS7. While IIS7 is the best choice for a web
                  server on Microsoft platforms, there are still many servers with IIS6 in
                  production. Because you may already have a deep understanding of processing
                  ASP.NET based on IIS6, the following explanation focuses on the key differences
                  between IIS6 and IIS7, running in both Integrated mode and with the .NET
                  Framework 3.5 or later. The following properties are specific to IIS7 with
                  Integrated mode. You must run IIS7 to take advantage of these.
                </p>

                <p>
                  The <code>HttpResponse</code> object has a new property <code>SubStatusCode</code>. This is useful for setting codes for tracking failed requests.
                  The <code>Headers</code> property of the <code>HttpResponse</code> object
                  provides access to response headers for the response. Two properties of the <code>HttpContext</code> object,
                  <code>IsPostNotification</code> and <code>CurrentNotification</code>, are used when one event handler handles several
                  <code>HttpApplication</code> events. Both the <code>Headers</code> and <code>ServerVariables</code> property of the <code>HttpRequest</code>
                  object are write-enabled. 
                </p>

              </Element>
            </Element>
            <Element Type="Section">
              An HttpApplication object is assigned to the request
              <Element Type="Text">
                <p>
                  After all application objects have been
                  initialized, the application is started by creating an instance of the <code>HttpApplication</code> class. If the application has a Global.asax file,
                  ASP.NET instead creates an instance of the Global.asax class that is derived from the <code>HttpApplication</code> class. It then uses the derived class to represent the application.
                  This way you get access to the application events simply by overwriting the
                  handlers within the global.asax code portion.
                </p>
              </Element>
              <Element Type="Sidebar" SidebarType="Note">
                <header>Note</header>
                <aside>
                  The first time that an
                  ASP.NET page or process is requested in an application, a new instance of the <code>HttpApplication</code>
                  class is created. However, to maximize performance, <code>HttpApplication</code> instances might be reused for multiple requests.
                </aside>
              </Element>
            </Element>
            <Element Type="Section">
              The request is processed by the pipeline
              <Element Type="Text">
                <p>
                  The <code>HttpApplication</code> class performs several tasks while the request is being processed.
                  Each step fires a specific request to allow you to run code when the event is
                  raised. Without any further action, all incoming requests will fire all events
                  and the attached modules will be invoked in sequence. To take advantage of extensibility,
                  some interfaces come into the scope. <code>IHttpModule</code>
                  is the basic interface for custom modules. In IIS7’s integrated mode you can use
                  the module’s <code>Init</code> method to attach the required
                  events.
                </p>
                <p>
                  One step you’re supposed to perform is
                  the request validation. Imagine hackers trying to send malicious markup or
                  other intrusions. The following list of events shows all steps you can run
                  private code in. Validating the request should take place as early as possible,
                  according to the following list in <code>BeginRequest</code>.
                </p>
                <ul>
                  <li>Raise the BeginRequest event. </li>
                  <li>Raise the AuthenticateRequest event. </li>
                  <li>Raise the PostAuthenticateRequest event. </li>
                  <li>Raise the AuthorizeRequest event. </li>
                  <li>Raise the PostAuthorizeRequest event. </li>
                  <li>Raise the ResolveRequestCache event. </li>
                  <li>Raise the PostResolveRequestCache event. </li>
                  <li>
                    Raise the MapRequestHandler event. An
                    appropriate handler is selected based on the filename extension of the
                    requested resource. The handler can be a native code module such as the IIS7
                    StaticFileModule or a managed module such as the <code>PageHandlerFactory</code> class. 
                  </li>
                  <li>Raise the PostMapRequestHandler event. </li>
                  <li>Raise the AcquireRequestState event. </li>
                  <li>Raise the PostAcquireRequestState event. </li>
                  <li>
                    Raise the PreRequestHandlerExecute event. Call
                    either the <code>ProcessRequest</code> method for synchronous
                    calls or the asynchronous version <code>IHttpAsyncHandler.BeginProcessRequest</code> of the appropriate <code>IHttpHandler</code> class.
                  </li>
                  <li>Raise the PostRequestHandlerExecute event.</li>
                  <li>Raise the ReleaseRequestState event. </li>
                  <li>Raise the PostReleaseRequestState event. </li>
                  <li>Perform response filtering if the Filter property is defined. </li>
                  <li>Raise the UpdateRequestCache event. </li>
                  <li>Raise the PostUpdateRequestCache event. </li>
                  <li>Raise the LogRequest event. </li>
                  <li>Raise the PostLogRequest event. </li>
                  <li>Raise the EndRequest event. </li>
                  <li>Raise the PreSendRequestHeaders event. </li>
                  <li>Raise the PreSendRequestContent event. </li>
                </ul>
              </Element>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="The Page’s Life Cycle">
        The Page’s Life Cycle
        <Element Type="Text">
          <p>
            After understanding the application’s
            life cycle, you’re now ready to move further along the path taken by the
            request. The request is now being processed until the resources are prepared
            and ready to be served. For static resources it’s easy; the data is all ready
            to send to the client. (Examples of static resources include images, JavaScript
            files, and embedded objects.) The more exciting information is how dynamic
            resources are processed.
          </p>
          <p>
            The basic steps in the page’s
            life cycle include initialization, instantiating controls, restoring and
            maintaining state, running event handler code, and rendering. As you saw in the
            application’s life cycle, you will be able to interact with the processing and
            change the handling for your intended effects. Some steps during the page’s
            life cycle are more complex and require a closer look in order to take full
            advantage of their customization potential. One major portion is the view state
            handling. I’ll dedicate a whole section to explaining view state later in this
            chapter.
          </p>
          <p>
            It is also important for you to
            understand the page life cycle. As a developer creating custom controls, for
            instance, you must be familiar with the life cycle in order to correctly
            initialize controls, populate control properties with view state data, and run
            any control behavior code. You may have heard of a control life cycle, too. You
            may already know that a page in ASP.NET is a sort of specialized control and
            therefore a control’s life cycle is very similar. However, pages have more
            events available.
          </p>
        </Element>
        <Element Type="Section" Name="What about Master Page Life Cycle?">
          What about Master Page Life Cycle?
          <Element Type="Text">
            <p>
              You might miss information regarding
              master pages here. The master page itself does not have any stages, because
              it’s not an object created and run standalone. The master page hierarchy is
              used to resolve the final construct of the page requested and then the page’s
              life cycle begins. Therefore, the master page is treated like a control, with
              some events related to the page’s life cycle events, but again, not with its
              own life cycle.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name="Page Request">
          Page Request
          <Element Type="Text">
            <p>
              The page request occurs before the page
              life cycle begins. When the page is requested by a client, ASP.NET determines
              whether the page needs to be parsed and compiled, or whether a cached version
              of the page can be sent in response without executing the page. In each case
              the “life" of the page begins.
            </p>
          </Element>
          <Element Type="Section" Name="Start">
            Start
            <Element Type="Text">
              <p>
                In this step, page properties such as <code>Request</code> and <code>Response</code> are set. These
                properties give you access to the current <code>HttpRequest</code>
                and <code>HttpResponse</code> instances created through the application’s life cycle.
              </p>
              <p>
                You can access all information related
                to the request using <code>this.Request.</code> (In later
                stages you can modify the response created and stored in <code>this.Response</code>.) At this stage, the page also determines whether the request
                is a postback or a new request and sets the <code>IsPostBack</code>
                property. This involves two checks: whether the request is done as a POST, and whether
                it comes from the same ASP.NET page. Additionally, during the Start step, the
                page’s <code>UICulture</code> property is set. At this point you can perform any action based on
                the automatically recognized page culture. Alternatively, you can force the
                culture property, so that the correct resources are obtained. (Forcing the
                culture doesn’t work in other steps).
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Page Initialization">
            Page Initialization
            <Element Type="Text">

              <p>
                During page initialization step,
                controls on the page become available and each control’s <code>UniqueID</code> property is set. The <code>UniqueID</code> is
                used later on postbacks to assign control state in order to make forms sticky,
                for instance. Any themes are also applied to the page. If the current request
                is a postback, the postback data has not yet been loaded and control property
                values have not been restored to the values from view state.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Load">
            Load
            <Element Type="Text">

              <p>
                During load, if the current request is
                a postback, control properties are loaded with information recovered from view
                state and control state. For a regular request via GET, view state and control
                state are set to their respective default states.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Validation">
            Validation
            <Element Type="Text">

              <p>
                During this step the <code>Validate</code> method of all validator controls is called. The <code>IsValid</code> property of
                all validator controls is set and as a summary the page’s <code>IsValid</code> property is set, too.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Postback Event Handling">
            Postback Event Handling
            <Element Type="Text">

              <p>
                If the request is a postback, any event
                handlers are called, such as button click events.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Rendering">
            Rendering
            <Element Type="Text">

              <p>
                Before rendering, view state is saved
                for the page and all controls. Rendering is the process that creates the HTML
                that makes the page visible in a browser. Each control is responsible for rendering
                itself. This feature and the extensible design time support is a major opportunity
                for third party control vendors. Their controls can encapsulate all the clever design
                time experience and run time functionality within each control. That means
                during the rendering phase, the page calls the <code>Render</code>
                method for each control, providing a <code>TextWriter</code> instance
                that writes its output to the <code>OutputStream</code> of the
                page’s <code>Response</code> property.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Unload">
            Unload
            <Element Type="Text">

              <p>
                Unload is called after the page has
                been fully rendered, sent to the client, and is ready to be discarded. At this
                point, page properties such as <code>Response</code> and <code>Request</code> are unloaded and any cleanup is performed.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Events Fired Within the Life Cycle">
          Events Fired Within the Life Cycle
          <Element Type="Text">

            <p>
              Within each stage of the life cycle of
              a page, the page raises events that you can handle to run your own code. For
              control events, you bind the event handler to the event, either declaratively
              using attributes such as <code>onclick</code>, or in code.
            </p>

            <p>
              Pages also support automatic
              event wire-up, meaning that ASP.NET looks for methods with particular names and
              automatically runs those methods when certain events are raised. If the <code>AutoEventWireup</code> attribute of the <code>@Page</code>
              directive is set to <code>true</code>, page events are automatically bound to methods that use the naming
              convention that follow the pattern Page_&lt;event&gt;, such as <code>Page_Load</code> and <code>Page_Init</code>.
            </p>

            <p>
              The following table lists all the
              page events. The "Typical Use" column
              indicates the events you usually handle when developing pages and controls. The
              other events are less important but give you more control from the
              extensibility perspective, for instance when you create custom controls that
              require a very specific behavior.
            </p>
          </Element>
          <Element Type="table" Name="Usage of page events">
            <table>
              <tr>
                <th>Page Event </th>
                <th>Typical Use</th>
              </tr>
              <tr>
                <td>PreInit</td> 
                <td>
                  Use this event to check the <code>IsPostBack</code> property to determine whether this is the first time the page is
                  being processed. Create or re-create dynamic controls. You may also set master
                  pages and the <code>Theme</code> property dynamically. Read or set any
                  profile property values.
                </td>
              </tr>
              <tr>
                <td>Init</td>     
                <td>
                  Event is raised after all
                  controls have been initialized and any skin settings have been applied. Use
                  this event to read or initialize control properties.
                </td>
              </tr>
              <tr>
                <td>InitComplete</td>
                <td>
                  This event is raised by the
                  Page object. Use this event for processing tasks that require all
                  initialization be complete.
                </td>
              </tr>
              <tr>
                <td>PreLoad</td>          
                <td>
                  Use this event if you
                  need to perform processing on your page or control before the Load event.
                  Before the Page instance raises this event, it loads view state for itself and
                  all controls, and then processes any post-back data included with the <code>Request</code> instance.
                </td>
              </tr>
              <tr>
                <td>Load</td>   
                <td>
                  The Page calls the <code>OnLoad</code> event method on the <code>Page</code>, then recursively
                  does the same for each child control, which does the same for each of its child
                  controls until the page and all controls are loaded. Use the overridden <code>OnLoad</code> event method to set properties
                  in controls and establish database connections.
                </td>
              </tr>
              <tr>
                <td>Control events</td>  
                <td>
                  Use these events to
                  handle specific control events, such as a Button control's Click event or a
                  TextBox control’s Text-Changed event.
                </td>
              </tr>
              <tr>
                <td>LoadComplete</td>  
                <td>
                  Use this event for tasks
                  that require that all other controls on the page be loaded.
                </td>
              </tr>
              <tr>
                <td>PreRender</td>        
                <td>
                  Before this event occurs,
                  the <code>Page</code> object calls <code>EnsureChildControls</code> for
                  each control and for the page itself. Each data bound control whose <code>DataSourceID</code> property is set calls its <code>DataBind</code>
                  method. The <code>PreRender</code> event occurs for each control
                  on the page. Use the event to make final changes to the contents of the page or
                  its controls.
                </td>
              </tr>
              <tr>
                <td>SaveStateComplete</td>       
                <td>
                  Before this event
                  occurs, view state has been saved for the page and for all controls. Any
                  changes to the page or controls at this point will be ignored. See the section
                  about view state later in this chapter to learn more about its specific
                  behavior. Use this event to perform tasks that require view state to be saved,
                  but that do not make any changes to controls.
                </td>
              </tr>
              <tr>
                <td>Unload</td>
                <td>
                  This
                  event occurs for each control and, when all control events are done, for the
                  page. In controls, use this event to do final cleanup for specific actions,
                  such as closing database connections. For the page itself, use this event to do
                  final cleanup work, such as closing open files and database connections, finishing
                  up logging or other request-specific tasks.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              If the request is a postback,
              the values of the controls have not yet been restored from view state during <code>PreInit</code> state. If you set a control property at this stage,
              its value might be overwritten in the next event.
            </p>
            <p>
              Again, in a postback request
              during <code>Load</code> event, if the page contains validator controls, check the <code>IsValid</code> property of the
              <code>Page</code> and of individual
              validation controls before performing any processing.
            </p>
            <p>
              During the <code>Unload</code> stage, the page and its controls have been rendered, so you cannot
              make further changes to the response stream. If you attempt to call a method
              such as the <code>Response.Write</code> method, the page will
              throw an exception. The render process itself does not have an event; it
              happens after <code>PreRender</code> and before <code>UnLoad</code> and can be intercepted by overwriting the <code>Render</code> method.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name="Additional Page Life Cycle Considerations">
          Additional Page Life Cycle Considerations
          <Element Type="Text">

            <p>
              Server controls have their own life
              cycle that is similar to the page life cycle. For example, a control’s <code>Init</code> and <code>
                Load
              </code> events occur
              during the corresponding page events. Although both <code>Init</code> and <code>
                Load
              </code> recursively occur
              on each control, they happen in reverse order. The <code>Init</code> and also the <code>
                Unload
              </code> event for each
              child control occur before the corresponding event is raised for its container.
              This is clearly the expected behavior, because the <code>Init</code> event on page level indicates that all subsequent <code>Init</code>
              events are completed. You may read the event as “Is Initialized". However, the <code>
                Load
              </code> event for a container occurs before
              the <code>Load</code> events for its child controls, which is the opposite behavior. This
              is so that you can have access to the process before any other processing takes
              place. From perspective of <code>
                Init
              </code> event it doesn’t
              make sense to do anything before it appears, because there is nothing you can
              access in your code.
            </p>
            <p>
              You can customize the appearance or
              content of a control by handling the events for the control, such as the <code>Click</code> event for the <code>
                Button
              </code> control, and the
              <code>SelectedIndexChanged</code> event for the <code>
                ListBox
              </code> control.
            </p>

            <p>
              When inheriting a class from the <code>Page</code> class, in addition to handling events raised by the page, you can
              override methods from the page’s base class. It’s a common technique to create your
              own base page classes that derive from <code>
                Page
              </code> and to handle
              common tasks there. For example, you can override the page’s <code>InitializeCulture</code> method to dynamically set culture information.
              Overriding event handlers or attaching events are two different methods to perform almost the same
              action. If you use the Page_&lt;event&gt; syntax you don’t need to handle the
              base implementation. However, if you override the method you must handle the
              base implementation and therefore call the base method. You can do this at the
              beginning, at the end, or anywhere in between.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Dynamic Controls and Data Binding Events">
        Dynamic Controls and Data Binding Events
        <Element Type="Text">
          <p>
            The page and control life cycles define
            a chain of events to give you maximum control over the creation and runtime of
            the control. However, the control handling has more possibilities than you can
            achieve with such a straightforward model. You will see a different behavior
            when adding controls dynamically. Furthermore data-bound controls work
            internally other than this way.
          </p>

        </Element>
        <Element Type="Section" Name="Dynamic Control Events">
          Dynamic Control Events
          <Element Type="Text">

            <p>
              The page life cycle and control life
              cycle are very similar because of the nature of a <code>Page</code> as a class derived from <code>
                Control
              </code>.
              However, you can add controls dynamically—a feature which doesn’t make sense
              for pages. You might assume that adding controls is not very common in ASP.NET.
              However, imagine that declaratively authored controls within templates of
              data-bound controls are treated like dynamically added controls. Their events
              are not initially synchronized with the other controls on the page. The
              lifetime of such controls begins with their instantiation; they raise the life
              cycle events one after the other until the control has caught up to the event
              during which it was added to the Controls collection.
            </p>

            <p>
              Usually this has no
              implications for developers. Unless you have nested data-bound controls, you
              don’t need to be concerned about this. For nested data-bound controls, this
              behavior is a bit different. If a child control has been data bound, but its
              container control has not yet been bound, the data in the child control and the
              data in its container control can be out of sync.
            </p>

            <p>
              Imagine that you have a GridView
              control and that each row contains a bound DropDownList control. Furthermore,
              assume that the <code>DropDownList</code>’s data
              properties, such as <code>DataSourceID,</code> are set
              declaratively. The <code>DropDownList</code> will now
              bind to its datasource when the <code>DataBinding</code> event of the containing <code>
                GridView
              </code> row occurs. However, the <code>GridView</code> might not yet have raised its <code>
                RowDataBound
              </code>event. In that case the <code>DropDownList</code> and
              containing control are out of sync. To avoid this you simply put the data
              source control—the one you have set in the <code>DataSourceID</code>
              property—within the same template. Additionally, remove the declarative
              assignment and set it programmatically during the <code>RowDataBound</code> event. In this event the container’s data are bound and both
              controls can stay in sync.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Data Binding Events for Data-Bound Controls">
          Data Binding Events for Data-Bound Controls
          <Element Type="Text">

            <p>
              To help you understand the relationship
              between the page life cycle and data binding events, the following table lists
              data-related events in data-bound controls. Remember that not all controls
              support all events shown in the table.
            </p>

          </Element>
          <Element Type="Sidebar" SidebarType="Note">
            <header>Note</header>
            <aside>
              In the description of
              data-bound control’s behavior I often refer to the term “containing control".
              If there is no containing control this assumes that the container is the page.
            </aside>
          </Element>
          <Element Type="table" Name="Relationship between life cycle events and data-bound events">
            <table>
              <tr>
                <th>Event</th>
                <th>Typical behavior</th>
                <th>Usage hints</th>
              </tr>
              <tr>
                <td>DataBinding</td>
                <td>
                  Raised before <code>PreRender</code> of containing control.
                </td>
                <td>This is the beginning of binding procedure. Open database connections here, if required.</td>
              </tr>
              <tr>
                <td>RowCreated</td>
                <td>Raised after each row gets bound.</td>
                <td>Manipulate content that does not depend on data binding.</td>
              </tr>
              <tr>
                <td>ItemCreated</td>
                <td>Raised after each item gets bound.</td>
                <td>Manipulate content that does not depend on data binding.</td>
              </tr>
              <tr>
                <td>RowDataBound</td>
                <td>Bound data is now available for the row.  </td>
                <td>Format data, get and filter child rows or related data.</td>
              </tr>
              <tr>
                <td>ItemDataBound</td>
                <td>Bound data is now available for the item.</td>
                <td>Format data, pull and filter child rows or related data.</td>
              </tr>
              <tr>
                <td>DataBound</td>
                <td>Marks the end of binding operation. All rows are bound now.</td>
                <td>Do any action that requires all data available.</td>
              </tr>
            </table>

          </Element>
        </Element>
        <Element Type="Section" Name="Login Control Events">
          Login Control Events
          <Element Type="Text">
            <p>
              The login controls, which handle login
              and authentication, are highly sophisticated and powerful. In most scenarios,
              the controls work well out of the box or just need some configuration using the
              web.config file. However, if you need to change or customize the behavior or
              extend the available features, you’ll need to know the events fired during
              their life cycle. 
            </p>

          </Element>
          <Element Type="table" Name="Relationship between life cycle events and logging-in events">
            <table>
              <tr>
                <th>Event</th>
                <th>Typical behavior</th>
                <th>Usage hint</th>
              </tr>
              <tr>
                <td>LoggingIn</td>
                <td>
                  Raised during postback
                  after LoadComplete.
                </td>
                <td>
                  Tasks required before the login procedure, such as
                  opening a database connection, if required.
                </td>
              </tr>
              <tr>
                <td>Authenticate</td>
                <td>
                  Raised next after
                  LoggingIn.
                </td>
                <td>Customize the authentication behavior itself.</td>
              </tr>
              <tr>
                <td>LoggedIn</td>
                <td>
                  Raised after
                  authentication.
                </td>
                <td>
                  Action required after successful authentication, such
                  as redirect to another page.
                </td>
              </tr>
              <tr>
                <td>LoginError</td>
                <td>
                  Raised
                  after failed authentication.
                </td>
                <td>
                  Do any action to handle failed authentication, such
                  as displaying instructions.           
                </td>
              </tr>
            </table>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="View State">
        View State
        <Element Type="Text">

          <p>
            The ASP.NET view state is a mechanism
            to track changes of the state of pages from one postback to the next. We call
            it postback whenever a page sends the contents of a form back to the server.
            The name comes from the underlying HTTP command POST that we use and the way that
            it takes the contents back to the server. View state is turned on by default and
            most developers don’t care about it. It contains the values of properties of
            controls changed since the last page cycle and is stored in a serialized and
            encrypted format within the page. Each postback sends all the information
            stored in it back to the server. As you may know, using view state in the
            default manner can lead to huge pages that consume a lot of bandwidth. It’s not
            easy to understand view state completely, and simply disabling it leads to
            controls not working or having fewer features.
          </p>

          <p>
            The real internal behavior is confusing
            and hard to understand. As long as you deal with simple applications, a basic
            ideamight be enough. But when it comes to your own controls, complex pages, or
            using AJAX, a good understanding is a prerequisite.
          </p>

        </Element>
      </Element>
      <Element Type="Section" Name="Why Understanding View State is Important">
        Why Understanding View State is Important
        <Element Type="Text">

          <p>
            Misunderstanding view state leads to
            leaking of sensitive data, being exploited by view state attacks, poor page
            performance, poor scalability, and headaches. Whatever you want to achieve with
            your application, the Figure 1-11 shows the source of a page which we never want to see.
          </p>

        </Element>
        <Element Type="Image" Name="The view state’s form field could grow">
          images/19835f0111.png
        </Element>
        <Element Type="Text">
          <p>
            Simply disabling view state will not
            help, however, because you will probably lose some features that you need and like.
            In fact, there is nothing wrong with view state; it’s just the wrong or inappropriate
            usage of it that causes problems. Now let’s move on by starting back at the
            beginning. What does view state do?
          </p>
          <ol>
            <li>
              Stores values of control’s properties
              by keys, similar to a hash table
            </li>
            <li>Tracks changes to initial values</li>
            <li>
              Serializes and deserializes a saved
              dictionary in a hidden form field
            </li>
            <li>
              Restores stored values into control’s
              properties
            </li>
          </ol>
          <p>
            These features are well known. Much
            more important is what the view state does not do:
          </p>
          <ol>
            <li>Retain the state of class members</li>
            <li>
              Remember state information across page
              loads (page reloads by GET request)
            </li>
            <li>
              Avoid the need to repopulate data on every
              request
            </li>
            <li>
              Hold data in controls that are posted
              back—the so-called sticky form behavior
            </li>
          </ol>
          <p>
            The last bullet point is probably the
            most confusing here. Many developers think that this is the only task that the view
            state has to do.Although the view state is involved in the process of holding
            the control’s visible data; it is not the originator of the process (that would
            be the control state).
          </p>
        </Element>
        <Element Type="Section" Name="What View State is Supposed to Do">
          What View State is Supposed to Do
          <Element Type="Text">

            <p>
              Before we start looking into what view
              state does exactly, some basic features should be reviewed.
            </p>
            <p>
              <ul>
                    <li>View state stores values</li>
                    <li>View state tracks changes</li>
                    <li>View state serializes and deserializes data</li>
                    <li>View state restores data</li>
              </ul>
            </p>
            <p>
              View state is held in a hidden field
              with the name <code>
                __VIEWSTATE
              </code>. “Hidden" means that the
              browser does not render the field, but the field itself and its content are visible
              in the page’s source. It needs the bandwidth twice—the first time when the page
              is sent to the browser and the second time when the browser sends the page back
              (that is, when a postback happens). A postback occurs very frequently when a
              user navigates within the application; unless you use hyperlinks, almost all
              actions are based on a form being sent back.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="The Page Cycle from the View State Perspective">
        The Page Cycle from the View State Perspective
        <Element Type="Text">

          <p>
            The page cycle is very important to
            understanding view state completely as several levels of the cycle treat view state
            explicitly. You can refer to the previous section to get an idea of the page
            cycle in a nutshell. In this section I will repeat the major steps that
            actually handle view state.
          </p>

          <p>
            Each time the server receives a request
            for an .aspx page it will be processed by the ASP.NET engine through a specific
            number of steps. These include checking access security and restoring the
            session state. At the end of the process the engine creates a class that
            consists of the markup and code-behind. This generates an instance of that
            class which becomes its <code>
              ProcessRequest
            </code> method.
          </p>

          <p>
            The page life cycle begins with the
            call to this method. It follows the initialization of the controls of the page
            and life cycle phases of those controls begin. This includes the processing of
            the view state, handling of postback data and related events and finally the
            processing of HTML content.
          </p>

          <p>
            The life cycle of the page ends when the
            HTML is completely rendered and handed over to the web server. The web server
            is responsible for sending the data over the wire to the browser. While the web
            server is sending the data, the garbage collector is already freeing up the
            released memory. This is true for all requests without any interaction or
            custom code required. However, within this cycle, view state has an
            extraordinary function and it makes your life as a control developer easier if
            you understand life cycles and their relation to view state.
          </p>

        </Element>
        <Element Type="Section" Name="Step One—Instantiation">
          Step One—Instantiation
          <Element Type="Text">

            <p>
              The instantiation is the
              beginning of the life cycle of the page. The class, which represents the page, is
              instantiated and launched. But what actually happens and where does the page’s
              code get stored? ASP.NET pages consist of HTML markup with controls and code. Firstly,
              the ASP.NET engine converts the text portion of the page and all markup into
              web controls. That means the page is now completely made of code. Most parts
              that consist of HTML are replaced by <code>
                LiteralControl
              </code> controls. Literals contain text that doesn’t need any further
              processing. This is required in order to avoid the extensive recognition
              process. The ASP.NET engine is able to recognize changes made and re-runs the
              process, if required. The features required for a page are inherited from the <code>Page</code> class (<code>
                System.Web.UI.Page
              </code>). If
              code behind is being used, one more step is required. Using the <code>partial</code> keyword this class is married with the code-behind
              class that is associated with the aspx page.
            </p>

            <p>
              When compilation is done with
              SDK components, the final class is stored under this path:
            </p>

            <p class="Query">
              WINDOWS\Microsoft.NET\Framework\&lt;Version&gt;\Temporary
              ASP.NET Files
            </p>

            <p>
              This is same if IIS is calling
              a web project that is not pre-compiled and the ASP.NET engine is forced to
              compile the code on the fly.
            </p>
            <p>
              Using Visual Studio 2008, the
              path is quite different:
            </p>

            <p class="Query">
              &lt;UserHome&gt;\AppData\Local\Temp\Temporary
              ASP.NET Files\root\
            </p>

            <p>
              Under either path, you can find
              folders for projects and solutions. However, Visual Studio uses some weird
              codes to name the folders instead of the project’s real name. I suggest sorting
              the explorer view by date to recognize the right folder based on last change
              date. The language—either C# or Visual Basic—depends on the setting of the page
              and the code behind used. Reading the generated pages can occasionally be helpful,
              especially when researching odd errors. If you want to go deeper into the
              internal page processing, it’s worth a look. The generated material includes
              all fragments read from pages, code behind, user controls and master pages.
            </p>

            <p>
              If the code is compiled directly
              you may not find the generated classes but the final assembly only. In that
              case I recommend using a tool like Red Gate’s Reflector to examine the finally
              generated code.
            </p>

          </Element>
          <Element Type="Section" Name="Building the Hierarchy of Controls">
            Building the Hierarchy of Controls
            <Element Type="Text">
              <p>
                The page is the top level of the
                hierarchy of controls. Because the <code>
                  Page
                </code> class
                itself inherits from <code>
                  Control
                </code>, it’s a
                control, too. Each control has exactly one parent and none, one, or many
                children. The elements placed declaratively in the page are children of the
                highest level. There is no limit to nesting levels for the control hierarchy.
                This leads to vast trees made of complex controls.
              </p>

              <p>
                One important control is <code>HtmlForm</code> (full name is <code>
                  System.Web.UI.HtmlControls.HtmlForm
                </code>). It creates the <code>
                  &lt;form&gt;
                </code> tag and
                determines the content sent during postback. The view state information is
                necessarily placed here. You can see this in the sample shown in Listing 1-4.
              </p>

            </Element>
            <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Simple ASPX page with controls">
              &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
              &lt;head runat=&quot;server&quot;&gt;
              &lt;title&gt;&lt;/title&gt;
              &lt;/head&gt;
              &lt;body&gt;
              &lt;h1&gt;
              Apress - ViewState&lt;/h1&gt;
              &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
              &lt;div&gt;
              &lt;asp:TextBox runat=&quot;server&quot; ID=&quot;txtName&quot; /&gt;
              &lt;br /&gt;
              Are you called a
              &lt;asp:DropDownList runat=&quot;server&quot; ID=&quot;ddlWhat&quot;&gt;
              &lt;asp:ListItem Value=&quot;G&quot; Selected=&quot;True&quot;&gt;Geek&lt;/asp:ListItem&gt;
              &lt;asp:ListItem Value=&quot;N&quot;&gt;Nerd&lt;/asp:ListItem&gt;
              &lt;asp:ListItem Value=&quot;W&quot;&gt;Don’t know&lt;/asp:ListItem&gt;
              &lt;/asp:DropDownList&gt;
              &lt;br /&gt;
              &lt;asp:Button runat=&quot;server&quot; ID=&quot;btnSend&quot; Text=&quot;Send!&quot; /&gt;
              &lt;/div&gt;
              &lt;/form&gt;
              &lt;/body&gt;
              &lt;/html&gt;
            </Element>
            <Element Type="Text">
              <p>
                <link ref="Simple page in Visual Studio Designer" /> shows
                how it will look like in the Visual Studio designer.
              </p>

            </Element>
            <Element Type="Image" Name="Simple page in Visual Studio Designer">
              images/19835f0112.png
            </Element>
            <Element Type="Text">

              <p>
                The ASP.NET engine generates the output code,
                a fragment of which is shown in Listing 1-5:
              </p>

            </Element>
            <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Simple ASPX page from last listing compiled into code">

              public class default_aspx : _Default, IRequiresSessionState, IHttpHandler
              {
              private static object __fileDependencies;
              private static bool __initialized;
              [DebuggerNonUserCode]
              public default_aspx()
              {
              base.AppRelativeVirtualPath = &quot;~/Default.aspx&quot;;
              if (!__initialized)
              {
              string[] virtualFileDependencies = new string[] { &quot;~/Default.aspx&quot; };
              __fileDependencies =
              base.GetWrappedFileDependencies(virtualFileDependencies);
              __initialized = true;
              }
              }

              [DebuggerNonUserCode]
              private HtmlTitle __BuildControl__control2()
              {
              return new HtmlTitle();
              }

              [DebuggerNonUserCode]
              private void __BuildControl__control3(ListItemCollection __ctrl)
              {
              ListItem item = this.__BuildControl__control4();
              __ctrl.Add(item);
              ListItem item2 = this.__BuildControl__control5();
              __ctrl.Add(item2);
              ListItem item3 = this.__BuildControl__control6();
              __ctrl.Add(item3);
              }

              [DebuggerNonUserCode]
              private ListItem __BuildControl__control4()
              {
              ListItem item = new ListItem();
              item.Value = &quot;G&quot;;
              item.Selected = true;
              item.Text = &quot;Geek&quot;;
              return item;
              }

              [DebuggerNonUserCode]
              private ListItem __BuildControl__control5()
              {
              ListItem item = new ListItem();
              item.Value = &quot;N&quot;;
              item.Text = &quot;Nerd&quot;;
              return item;
              }

              [DebuggerNonUserCode]
              private ListItem __BuildControl__control6()
              {
              ListItem item = new ListItem();
              item.Value = &quot;W&quot;;
              item.Text = &quot;Don’t know&quot;;
              return item;
              }

              [DebuggerNonUserCode]
              private Button __BuildControlbtnSend()
              {
              Button button = new Button();
              base.btnSend = button;
              button.ApplyStyleSheetSkin(this);
              button.ID = &quot;btnSend&quot;;
              button.Text = &quot;Send!&quot;;
              return button;
              }

              [DebuggerNonUserCode]
              private DropDownList __BuildControlddlWhat()
              {
              DropDownList list = new DropDownList();
              base.ddlWhat = list;
              list.ApplyStyleSheetSkin(this);
              list.ID = &quot;ddlWhat&quot;;
              this.__BuildControl__control3(list.Items);
              return list;
              }

              [DebuggerNonUserCode]
              private HtmlForm __BuildControlform1()
              {
              HtmlForm form = new HtmlForm();
              base.form1 = form;
              form.ID = &quot;form1&quot;;
              IParserAccessor accessor = form;
              accessor.AddParsedSubObject(
              new LiteralControl(&quot;\r\n    &lt;div&gt;\r\n        &quot;));
              TextBox box = this.__BuildControltxtName();
              accessor.AddParsedSubObject(box);
              accessor.AddParsedSubObject(
              new LiteralControl(&quot;\r\n        &lt;br /&gt;\r\n     
              Are you called a \r\n        &quot;));
              DropDownList list = this.__BuildControlddlWhat();
              accessor.AddParsedSubObject(list);
              accessor.AddParsedSubObject(
              new LiteralControl(&quot;\r\n        &lt;br /&gt;\r\n        &quot;));
              Button button = this.__BuildControlbtnSend();
              accessor.AddParsedSubObject(button);
              accessor.AddParsedSubObject(
              new LiteralControl(&quot;\r\n    &lt;/div&gt;\r\n    &quot;));
              return form;
              }

              [DebuggerNonUserCode]
              private HtmlHead __BuildControlHead1()
              {
              HtmlHead head = new HtmlHead(&quot;head&quot;);
              base.Head1 = head;
              head.ID = &quot;Head1&quot;;
              HtmlTitle title = this.__BuildControl__control2();
              IParserAccessor accessor = head;
              accessor.AddParsedSubObject(title);
              return head;
              }

              [DebuggerNonUserCode]
              private void __BuildControlTree(default_aspx__ctrl)
              {
              this.InitializeCulture();
              IParserAccessor accessor = __ctrl;
              accessor.AddParsedSubObject(
              new LiteralControl(&quot;\r\n\r\n&lt;!DOCTYPE html PUBLIC \&quot;-//W3C//DTD XHTML 1.0 Transitional//EN\&quot; \&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\&quot;&gt;\r\n\r\n&lt;html xmlns=\&quot;http://www.w3.org/1999/xhtml\&quot;&gt;\r\n&quot;));
              HtmlHead head = this.__BuildControlHead1();
              accessor.AddParsedSubObject(head);
              accessor.AddParsedSubObject(new LiteralControl(&quot;\r\n&lt;body&gt;\r\n    &lt;h1&gt;\r\n        Apress - ViewState&lt;/h1&gt;\r\n    &quot;));
              HtmlForm form = this.__BuildControlform1();
              accessor.AddParsedSubObject(form);
              accessor.AddParsedSubObject(
              new LiteralControl(&quot;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n&quot;));
              }

              [DebuggerNonUserCode]
              private TextBox __BuildControltxtName()
              {
              TextBox box = new TextBox();
              base.txtName = box;
              box.ApplyStyleSheetSkin(this);
              box.ID = &quot;txtName&quot;;
              return box;
              }

              [DebuggerNonUserCode]
              protected override void FrameworkInitialize()
              {
              base.FrameworkInitialize();
              this.__BuildControlTree(this);
              base.AddWrappedFileDependencies(__fileDependencies);
              base.Request.ValidateInput();
              }

              [DebuggerNonUserCode]
              public override int GetTypeHashCode()
              {
              return -1678387491;
              }

              [DebuggerNonUserCode]
              public override void ProcessRequest(HttpContext context)
              {
              base.ProcessRequest(context);
              }

              // Properties
              protected HttpApplication ApplicationInstance
              {
              get
              {
              return this.Context.ApplicationInstance;
              }
              }

              protected DefaultProfile Profile
              {
              get
              {
              return (DefaultProfile) this.Context.Profile;
              }
              }
              }

            </Element>
            <Element Type="Text">

              <p>
                The code is not very readable, but this
                is what generated code is supposed to look like, right? There is no need to do
                anything special with it, but rather to learn what is going on internally. Note
                two things here. Firstly, the declarative assignment of attributes is being
                replaced with simple property assignments. See the following markup:
              </p>
              <code>&lt;asp:Button text=&quot;Foobar&quot;&gt;</code>
              <p>It becomes this in the generated class: </p>
              <code>button1.Text = &quot;Foobar&quot;</code>
              <p>
                Secondly, all literal stuff is placed in
                strings and copied into the final page “as is", just like shown in the snippet
                below:
              </p>
              <code>
                new
                LiteralControl(&quot;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n&quot;))
              </code>
              <p>
                Once the class is complete, the engine
                proceeds to the next step.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Step Two—Initializing">
          Step Two—Initializing
          <Element Type="Text">

            <p>
              After creating the control hierarchy,
              all the controls of the page are moved into the initialization state. This becomes
              apparent by raising the <code>
                Init
              </code> event. In this
              phase not only are the controls ready but they also having their static,
              declarative properties assigned.
            </p>

          </Element>
          <Element Type="Sidebar" SidebarType="Note">

            <header>Note</header>
            <aside>“Declarative" is everything that’s written within the markup and not in code fragments.</aside>

          </Element>
          <Element Type="Text">
            <p>
              Whether or not a property has been
              declaratively assigned, you still can change the value any time before the
              render process is complete. However, because I’m talking about view state, the
              initialization step plays a special role regarding property values.
            </p>

          </Element>
          <Element Type="Section">
            View State Tracks Changes
            <Element Type="Text">

              <p>
                View state tracks changes of properties.
                This is a special function of the <code>
                  StateBag
                </code>
                class, which holds the data behind the scenes. Tracking starts during the
                Initializing step. In order to recognize the default value and the changed one,
                the <code>StateBag</code> compares the initialized value set by declarative markup with the
                current value set anytime later programmatically. Even if the results look the
                same, the view state treats the data in a different way.
              </p>

            </Element>
          </Element>
          <Element Type="Section">
            View State and Dynamic Controls
            <Element Type="Text">

              <p>
                Using dynamic controls, you’ll know
                that technically it’s possible to add controls any time before the page render
                process is complete. View state, is not that flexible. Adding controls using <code>Controls.Add</code> method must take place in the
                initializing phase. Otherwise the <code>StateBag</code> class does not recognize the <code>
                  Init
                </code> event
                at the right time and does not start tracking changes. You still can add
                controls anytime, but for those controls the view state will not work. You
                might find problems here occasionally as the majority of controls being added
                dynamically—such as the <code>
                  Label
                </code> control—don’t
                require property value tracking.
              </p>

              <p>
                The golden rule states that in
                order to “take care of the view state, whether it’s required or not, add
                dynamic controls during the Initializing step".
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Step Three—Loading the View State">
          Step Three—Loading the View State
          <Element Type="Text">

            <p>
              View state data is saved into a hidden
              field called <code>
                __VIEWSTATE
              </code>. It’s transmitted back to
              the server only during a POST operation, which forces a postback.
            </p>

          </Element>
          <Element Type="Sidebar" SidebarType="Note">
            <header>Note</header>
            <aside>
              You can completely ignore
              page requests that use GET for this step. Such requests do not interact with
              view state at all.
            </aside>
          </Element>
          <Element Type="Text">

            <p>
              In this step the engine decodes
              values from the hidden fields and assigns them to the controls, looping
              recursively through the control hierarchy. Also in this phase the validity of
              the view state is checked. There are several reasons why the view state could
              become invalid. One reason is that the control hierarchy has been changed during
              postback and the control is not at the expected place, or removed completely.
            </p>
            <p>If everything is fine, the engine proceeds to the next step.</p>

          </Element>
        </Element>
        <Element Type="Section" Name="Step Four—Loading Postback Data">
          Step Four—Loading Postback Data
          <Element Type="Text">

            <p>
              After loading and restoring the view
              state, the form data is processed. Not all controls can return data. To let the
              engine know whether it has to look for data sent back, the <code>IPostBackDataHandler</code> interface is recognized. Each control implementing this interface
              might send form data back. Form data is sent back in the HTTP protocol as id&#8722;value
              pairs:
            </p>

            <code>Myclientid=value</code>

            <p>
              The page class looks for a control with
              a <code>ClientID</code> that equals “Myclientid". When found, it checks whether the control
              implements the <code>
                IPostBackDataHandler
              </code> interface. If it does
              this, the page class calls the only method defined there—<code>LoadPostData</code>. That means that the control itself manages the loading of data,
              which opens up a great way of changing behavior and adding custom code.
            </p>

            <p>
              Concerning view state, this behavior is very
              significant. The ability to get the values of controls back between postbacks
              is called “sticky form" behavior. It’s one of the best features of ASP.NET. Let
              me explain this in more detail using the example of a <code>TextBox</code> control. The <code>
                TextBox
              </code> has a property <code>Text</code>. It also implements the <code>
                IPostBackDataHandler
              </code> interface. Once a page with the textbox control is posted back, the
              <code>LoadPostData</code> method reads the value of the control out of the view state and
              writes it into the <code>
                Text
              </code> property. The
              default value—that was probably set declaratively—is overwritten. You can
              easily check this with the following definition:
            </p>

            <pre>
              &lt;asp:TextBox runat=&quot;server&quot;
              ID=&quot;txtName&quot; Text=&quot;&quot; /&gt;
            </pre>

            <p>
              The render process transforms this
              markup into HTML form:
            </p>

            <pre>
              &lt;input type=&quot;text&quot; id=&quot;txtName&quot;
              Name=&quot;txtName&quot; /&gt;
            </pre>

            <p>
              If the user now enters some text here,
              like “It’s a geek", the form transmitted back to the server contains at least
              this line:
            </p>

            <pre>txtName=It’s a geek</pre>

            <p>
              This data pair becomes part of the <code>Request.Form</code> collection. The key is “txtName" and the value is “It’s a geek".
              The page class hands this data pair to the <code>
                LoadPostData
              </code>
              method. Internally there is nothing surprising here. Using Reflector, you can
              look into the relevant code inside <code>
                System.Web.dll
              </code>.
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Disassembled code of the LoadPostData method">

            protected virtual bool LoadPostData(string postDataKey, NameValueCollection postCollection)
            {
            base.ValidateEvent(postDataKey);
            string text = this.Text;
            string str2 = postCollection[postDataKey];
            if (!this.ReadOnly &amp;&amp; !text.Equals(str2, StringComparison.Ordinal))
            {
            this.Text = str2;
            return true;
            }
            return false;
            }

          </Element>
          <Element Type="Text">

            <p>
              This code snippet is from <code>TextBox</code>, and the one and only property filled by a postback is <code>Text</code>.
              The control might have been set read-only and therefore this is checked first (<code>
                this.ReadOnly
              </code>). Also, as the code
              compares the old value and the new one, it’s written only if the value has been
              changed. Why is this additional check required? You might assume that comparing
              takes more time than assigning a property—even if there is nothing to render at
              this stage. Well, the reason is view state. To understand this, take a look
              into the code for the <code>
                Text
              </code> property:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Disassembled code of Text method of the TextBox class">

            public virtual string Text
            {
            get
            {
            string str = (string) this.ViewState[&quot;Text&quot;];
            if (str != null)
            {
            return str;
            }
            return string.Empty;
            }
            set
            {
            this.ViewState[&quot;Text&quot;] = value;
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              The value is not stored in a private
              field but only in view state. The tracking feature of the underlying <code>StateBag</code> class handles changes as well.
              If nothing has changed, it’s not recommended to assign the value to view state, or the <code>StateBag</code> class will start tracking.
              If there is nothing to track, it doesn’t make sense to do so, and the <code>
                LoadPostData
              </code> method is clever enough to know.
            </p>

            <p>
              One major aspect many developers overlook
              is the role of view state in the handling of postback data. The previous code
              snippets showed that the postback and form data loading procedures do not
              involve view state. More than that, they try to avoid any interaction with view
              state. The form data handling and stickiness behavior has nothing to do with
              the view state. The stickiness is a feature that comes with the <code>IPostBackDataHandler</code> interface.
              Just for clarity, here it is in its entire glory:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Code of IPostBackDataHandler interface">

            public interface IPostBackDataHandler
            {
            bool LoadPostData(string postDataKey,
            NameValueCollection postCollection);

            void RaisePostDataChangedEvent();
            }

          </Element>
          <Element Type="Text">

            <p>
              You know now that view state tracks
              changes and stores these changes. You know, too, that the stickiness of the
              form has nothing to do with view state.
            </p>
            <p>
              Now, all the controls have been initialized,
              properly filled with declarative data, over-written with data posted back from
              the browser, and are ready to enter the next state.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Step Five—Load Step">
          Step Five—Load Step
          <Element Type="Text">

            <p>
              Most descriptions of ASP.NET put user
              code into the <code>
                Load
              </code> event. In the explanation of life cycles
              you read about this important step. I as it signals to us that the control is
              now “ready". Even if you don’t want to do anything else with the control, it’s
              ready to be rendered. This is why the best step for adding custom code and
              modifying the behavior of the page is the load step. Internally, it’s much
              easier, because there is nothing to do. Anything that is supposed to happen
              here is up to you.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Step Six—Raising Postback Events">
          Step Six—Raising Postback Events
          <Element Type="Text">

            <p>
              Several controls can fire events,
              depending on the form data posted back. After the loading step, the events are fired
              one by one. For example, the <code>
                Button
              </code> control can fire
              a <code>Click</code> event, whereas the <code>
                DropDownList
              </code> fires <code>SelectedIndexChanged</code>. This is another major feature that makes the dynamic portion of an
              ASP.NET page so powerful and easy to program.
            </p>

            <p>
              There are two kinds of event
              fired during the page’s postback.
            </p>

            <p>
              One kind is responsible for changes,
              indicated by the suffix <code>
                _Change
              </code>. The
              implementation of <code>
                IPostBackDataHandler
              </code> is
              responsible for recognizing this and firing the appropriate event by calling
              the <code>RaisePostDataChangedEvent</code> method. In the case of the <code>
                TextBox
              </code> example,
              the event exposed by the class is <code>
                OnTextChanged
              </code>.
            </p>

            <p>
              The other kind of event is the trigger
              event. For example, in the case of a <code>
                Button
              </code> this
              is a <code>Click</code> event. There is no special state required and no data to compare.
              To handle trigger events the <code>
                IPostBackEventHandler
              </code>
              interface is used:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Code of IPostBackEventHandler interface">

            public interface IPostBackEventHandler
            {
            void RaisePostBackEvent(string eventArgument);
            }

          </Element>
          <Element Type="Text">

            <p>
              To understand what happens internally,
              we’ll look into the <code>
                RaisePostBackEvent
              </code>
              method. Listing 1-10 is for a <code>
                Button
              </code> control.
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Code of typical implementation of IPostBackEventHandler interface">

            protected virtual void RaisePostBackEvent(string eventArgument)
            {
            base.ValidateEvent(this.UniqueID, eventArgument);
            if (this.CausesValidation)
            {
            this.Page.Validate(this.ValidationGroup);
            }
            this.OnClick(EventArgs.Empty);
            this.OnCommand(new CommandEventArgs(
            this.CommandName, this.CommandArgument));
            }

          </Element>
          <Element Type="Text">

            <p>
              As you can see this method raises more
              than one event in a predefined and hard-coded order. Several other actions take
              place first—such as validation—but the events being fired are unconditional.
            </p>
            <p>
              Again, all these events can only happen during
              a postback. Calling the page using GET will do nothing. If you have a <code>DropDownlist,</code> and if you change the current index
              programmatically, nothing will happen unless the page is posted back. This is different from the windows programming
              model, where the controls can fire events immediately and independently of a
              particular state.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Step Seven—Storing the View State">
          Step Seven—Storing the View State
          <Element Type="Text">

            <p>
              After all events have been fired, the
              current state of each control’s property changes needs to be stored. The
              tracked changes are retrieved recursively through the controls hierarchy. To
              get the value back, the <code>
                SaveViewState
              </code> method of
              each control is called. The collection of data is then serialized and encoded
              using Base64.
            </p>

            <p>
              In the next step the string is saved to
              the hidden field named <code>
                __VIEWSTATE
              </code>.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Step Eight—Render the Page">
          Step Eight—Render the Page
          <Element Type="Text">

            <p>
              The render process runs through all the
              controls and allows them to render. This is done by a recursive call to all <code>RenderControl</code> methods. The <code>
                HtmlForm
              </code> control
              mentioned at the beginning is responsible for creating the <code>__VIEWSTATE</code> hidden field, which is the container for view state data.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="The True Role of View State">
        The True Role of View State
        <Element Type="Text">

          <p>
            The eight states of the life cycle are
            virtually all important for view state. There are several more steps the
            various life cycles could run through, but these steps don’t affect view state
            and we can exclude them for now. To understand the view state, it’s crucial to
            know what the purpose of view state is. As the name implies, view state stores
            status information. But what kind of status is it?
          </p>

          <p>
            The hierarchy of controls and the
            default values of properties are defined in the declarative part of the page.
            Take a look at this markup:
          </p>

          <code>
            &lt;asp:Label runat=&quot;server&quot;
            Text=&quot;We learn viewstate&quot; Font-Bold=&quot;true&quot; /&gt;
          </code>

          <p>
            Neither the text “We learn viewstate"
            nor the value <code>Bold</code> of the <code>Font</code> property is stored in view state. The values are assigned during
            the initializing phase. View state, in contrast, tracks changes made <i>programmatically</i>.
            This leads to the first definition about view state.
          </p>

        </Element>
        <Element Type="Sidebar" SidebarType="Note">
          <header>Note</header>
          <aside>View state becomes important only if the page contains custom code.</aside>
        </Element>
        <Element Type="Text">

          <p>
            However, if a page contains custom code,
            this does not necessarily mean that view state is required. Let’s look into
            another code snippet. The following example has two buttons. Both cause a
            postback, but only one has an <code>
              OnClick
            </code> event attached
            and handled to access properties in code.
          </p>

        </Element>
        <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Markup of the view state test">

          &lt;asp:Label ID=&quot;LabelMessage&quot; runat=&quot;server&quot; Text=&quot;We learn viewstate&quot;&gt;&lt;/asp:Label&gt;
          &lt;br /&gt;
          &lt;asp:Button ID=&quot;ButtonSubmit&quot; runat=&quot;server&quot; onclick=&quot;ButtonSubmit_Click&quot;
          Text=&quot;Change Text&quot; Width=&quot;150px&quot; /&gt;
          &lt;br /&gt;
          &lt;asp:Button ID=&quot;ButtonEmpty&quot; runat=&quot;server&quot; Text=&quot;No Change&quot;
          Width=&quot;150px&quot; /&gt;

        </Element>
        <Element Type="Text">

          <p>
            The code of the click handler is simple,
            too.
          </p>

        </Element>
        <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Code of the Click handler">
          protected void ButtonSubmit_Click(object sender, EventArgs e)
          {
          LabelMessage.Text = "Hello Geek!";
          }
        </Element>
        <Element Type="Text">

          <p>
            At the first call of the page the ASPX
            markup is processed and all values of properties are set, especially the text
            “We learn viewstate" for the <code>
              Label
            </code>. View state
            stores nothing and therefore contains only internal information without custom
            data:
          </p>

          <code>
            &lt;input type=&quot;hidden&quot;
            Name=&quot;__VIEWSTATE&quot; id=&quot;__VIEWSTATE&quot;
            style='font-family:Wingdings'>
                        value=&quot;/wEPDwULLTExNjMzNDIxNjRkZGn5amjBsOOap6CvRbpUM5D9Mlgo&quot;
            /&gt;
          </code>

          <p>
            Now click on the button “No Change".
            This forces the page to postback and reload, but nothing more happens, because
            no custom code is involved. Now click on the other button “Change Text". Again
            a postback occurs, but now the handler processes the <code>OnClick</code> event. In the code, the text of the label gets a new value. View
            state is changed to this:
          </p>

          <code>
            &lt;input type=&quot;hidden&quot;
            Name=&quot;__VIEWSTATE&quot; id=&quot;__VIEWSTATE&quot;
            va-lue=&quot;/wEPDwULLTExNjMzNDIxNjQPZBYCAgMPZBYCAgEPDxYCHgRUZXh0BQtIYWxsbyBHZWVrIWRkZHTeN11LiTv5BJ0xSdey0L0Qsnk8&quot;
            /&gt;
          </code>

          <p>
            As you see, the coded part is bigger
            and obviously contains more information. This is no surprise. If you click now on
            the other button “No Change", the page loads as expected and no custom code is
            run. However, the text of the label is still “Hello geek!" There is no custom
            code—the initializing phase has obviously passed and has set the declaratively
            assigned values. But the change made programmatically in an earlier postback is
            still there—it’s persistent.
          </p>

          <p>
            And that’s really the purpose of view
            state. During postbacks, it makes programmatic changes to control properties
            persistent. To check whether this behavior is really managed by view state,
            just disable it using the <code>@Page</code> directive:
          </p>
          <pre>
            &lt;%@ Page Language=&quot;C#&quot; EnableViewState=&quot;false&quot; …
          </pre>
          <p>
            The first click on “Change text" still
            works as expected. The new text appears. However, when you click on “No change",
            the postback forces the page to reload and the declarative part of the markup reloads
            the default values.
          </p>

          <p>
            Imagine that the “no view
            state" behavior described above is the intended behavior in most cases. If you
            have a label, you usually want it to show its default text. In case of an
            exception you might want to display a different text. But subsequent reloads
            usually store the state of such an exception by either overwriting the text
            again or letting the default text appear.
          </p>

          <p>
            Globally disabling view state is
            not an option either, because several complex controls use it to handle their
            behavior properly, such as the <code>
              GridView
            </code> control. You
            need to understand the view state to prevent overuse in case you don’t need it.
            In case you really need the special behavior the view state provides you use it
            correctly, then.
          </p>

        </Element>
      </Element>
      <Element Type="Section" Name="View State Anti-Patterns">
        View State Anti-Patterns
        <Element Type="Text">

          <p>
            Improper use of view state is easily avoided
            once you really understand how it works.To make things clear, I’ll explain the
            most frequent misuse scenarios. Examples of how <i>not</i> to use view state
            will help you understand how to use view state correctly:
          </p>
          <ol>
            <li>Forcing a default.</li>
            <li>Persisting static data.</li>
            <li>Persisting “cheap" data.</li>
            <li>Initializing child controls.</li>
            <li>Adding controls dynamically.</li>
            <li>Initializing dynamically created controls.</li>
          </ol>
          <p>I’ll explain each of these scenarios to make things as clear as possible.</p>

        </Element>
        <Element Type="Section">
          Forcing a Default
          <Element Type="Text">

            <p>
              Forcing a default vlue is a very common
              misuse. Fortunately, it’s even easier to fix. It’s also a good demonstration of
              the KISS principle. The developers of ASP.NET did a tremendous job to give us a powerful
              and well-designed toolkit. The whole framework is an infrastructure thing and
              provides stable and reliable blocks of code for basic stuff. Doing too much
              infrastructure work is a signal that something is going wrong.
            </p>

            <p>
              Assume that you want to store some
              private data used in a user control. The following code uses the view state, which,
              in principle, is not a bad idea.
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="DON’T TRY THIS AT HOME: a wrongly written user control">
            public class MyControl : WebControl
            {
            public string MyData
            {
            get { return ViewState[&quot;MyData&quot;] as string;  }
            set { ViewState[&quot;MyData&quot;] = value; }
            }
            protected override OnLoad(EventArgs e)
            {
            if (!IsPostBack)
            {
            this. MyData = Session[&quot;Control MyData&quot;] as string;
            }
            base.OnLoad();
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              You may have written code like this before.
              It’s not a bad style; it’s simply wrong. To understand my harsh judgment, let’s
              examine the intent of the control. The developer wrote a user control with the
              public property MyData. This gives other developers access to it in order to
              put the control into a defined state using markup like this:
            </p>

            <pre>
              &lt;alias:mycontrol runat=&quot;server&quot;
              Text=&quot;Show this label&quot; id=&quot;myControl1&quot; /&gt;
            </pre>

            <p>
              This compiles and runs well without any
              exceptions. However, it doesn’t work as expected because the MyData property is
              never set. Instead, the view state of the page starts growing because the view
              state field stores this private information. From that perspective, it’s doing
              well; it holds some data. Also, remember the life cycle events. It’s boring to
              repeat them again and again, but everything in ASP.NET is based on the life
              cycle. In Listing 1-13 the code
              is written into the <code>
                OnLoad
              </code> method. But the <code>Load</code> stage is too late. View state already tracks changes and now it’s
              being overwritten. That’s why it doesn’t make sense to write the data there. Let’s
              improve our example:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true"  Name="Save to be used at home: A well written control">

            public class MyControl : WebControl
            {
            public string MyData
            {
            get {
            if (ViewState[&quot;MyData&quot;] == null)
            return Session[&quot;Control MyData&quot;] as string;
            else
            return ViewState[&quot;MyData&quot;] as string;
            }
            set { ViewState[&quot;MyData&quot;] = value; }
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              This involves less code and it’s
              working well. The default value in the session is now used without touching view
              state. Simply putting the control onto the page does not increase the size of view
              state. <code>OnLoad</code> is out of the way here. The assignment of properties happens in the
              Initializing phase—early enough to set values properly. In case the user of the
              control sets the MyData property programmatically, view state is in full cry
              and stores the changes silently in the hidden field.
            </p>

          </Element>
        </Element>
        <Element Type="Section">
          Persisting constant data
          <Element Type="Text">

            <p>
              A lot of data used in a page’s code
              never changes during the life of the page or during the user’s session. Assume
              your application has some “My" section that is customizable by the user. After
              the user is logged on, his or her name appears at the top of each page. Assume
              further that a user control is being written to achieve this.
            </p>
            <p>
              <code>&lt;asp:label id="lblUser" runat="server"/&gt;</code>
            </p>
            <p>In the code behind portion the name is set:</p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >

            public class MyControl : WebControl
            {
            protected override OnLoad(EventArgs e)
            {
            lbluser.Text = CurrentUser.Name;
            base.OnLoad();
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              This is code that would work well.
              However, it’s doing something under the hood that we don’t want. The label has
              its own view state and, as a child control of the user control, it will store
              its changed properties in the parent’s view state. The user control is going to
              recognize this and store the change of view state. Storing the label’s text
              value in view state doesn’t make sense as, each time it’s loaded, the value is
              pulled from the <code>
                CurrentUser
              </code> class. The
              default behavior of controls is an implicit usage of view state. Either you
              assign it once, and hold data in view state, or you need to prevent it from
              using view state. The solution I would recommend looks very easy:
            </p>
            <p>
              <code>
                &lt;asp:label id=&quot;lblUser&quot;
                runat=&quot;server&quot; EnableViewstate=&quot;false&quot; /&gt;
              </code>
            </p>
            <p>
              Disable view state on the control level
              and it will work like a charm.
            </p>

          </Element>
        </Element>
        <Element Type="Section">
          Persisting cheap data
          <Element Type="Text">

            <p>
              Sometimes you use data that changes
              frequently, depending on user action or external conditions. Assume you want to
              show a list of data on your page. It is a small list and it doesn’t change
              frequently. But it could change or grow at any time. Your site is already using
              a database; it’s fast and there is nothing wrong with pulling the data from a
              table.
            </p>

            <pre>
              &lt;asp:dropdownlist runat=&quot;server&quot;
              id=&quot;ddlMyData&quot; DataTextField=&quot;Name&quot;      DataValueField=&quot;ID&quot;/&gt;
            </pre>

            <p>The (fictitious) code-behind portion could look like this:</p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >

            public class MyControl : WebControl
            {
            protected override OnLoad(EventArgs e)
            {
            if (!IsPostBack)
            {
            ddlMyData.DataSource = DAL.QueryDdlData();
            ddlMyData.DataBind();
            }
            base.OnLoad();
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              This is, again, working well and nobody
              would see any issues here. However, there is something here that is easily
              overlooked. Databound controls need to remember their state, for instance, to
              hold the last selected option of a dropdownlist after postback. I discussed
              this previously and called this smart behavior “stickiness". We don’t want to lose
              the form’s sticky behavior. You might therefore assume that switching view
              state off is not a solution either. But stickiness is part of the control
              state; it’s made by checking the form data. It’s not related to view state, as
              some developers think. The reason we run into trouble with view state is that
              it grows each time the page reloads.
            </p>

            <p>
              This time the solution is not so simple.
              Switching off view state is only the half of the answer:
            </p>

            <pre>
              &lt;asp:dropdownlist runat=&quot;server&quot;
              id=&quot; ddlMyData&quot; DataTextField=&quot;Name&quot; DataValueField=&quot;ID&quot;
              EnableViewState=&quot;false&quot; /&gt;
            </pre>

            <p>
              The code behind is almost the same, except
              we pull the data every time the control loads (note the missing <code>if</code> statement):
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >

            Public class MyControl : WebControl
            {
            protected override OnLoad(EventArgs e)
            {
            ddlMyData.DataSource = DAL. QueryDdlData ();
            ddlMyData.DataBind();
            base.OnLoad();
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              Now view state is as clean as possible.
              But the sticky form behavior has gone, too. Trying this, you might think you’ve
              found a bug in this book and that the author is wrong about view state.
            </p>

            <p>
              The fault is not view state itself. It
              still has no function because the control state is restoring the data from
              postback values. However, we overwrite this because the <code>OnLoad</code> event is fired after all states are restored. This is, again, a
              life cycle issue. Understanding the life cycle leads us to the solution. Move
              the last code fragment as is to another step in the life cycle—<code>OnInit</code>:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >

            public class MyControl : WebControl
            {
            protected override OnInit(EventArgs e)
            {
            ddlMyData.DataSource = DAL. QueryDdlData ();
            ddlMyData.DataBind();
            base.OnInit();
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              This solution is both clean and simple.
              <code>OnInit</code> fires before the control state restores the values. It pulls static
              data from a fast database, puts it directly into the control, forces the render
              process before the control restores its state, and everything is fine. The
              render process is an important step here, made by calling the <code>DataBind</code> method.
            </p>

          </Element>
          <Element Type="Sidebar" SidebarType="Tip">

            <header>Tip</header>
            <aside>
              You’ll probably want to
              avoid heavy database access whenever possible. Instead, you’ll probably store
              small data portions in XML files and maintain changes there. I would recommend
              using a database anyway. Modern implementations, like Microsoft SQL Server™,
              hold frequently requested data in memory. The amount of data requested is
              small, and the connection is usually 1GB or 10GB Ethernet. A powerful data
              access layer will also cache the data locally, so that in reality nothing is
              transferred between the servers. The slowest part of the connection is from the
              web server to the user. He or she will have ISDN, DSL, or a dial-up modem.
              Storing the small portion of data in view state sends the data three times over
              the wire: once when the user loads the page (as visible data in the dropdown
              control), once in view state, and the third time when the form is sent back (as
              view state is part of the form’s field collection). Calling a database
              frequently is not torture; this is the reason for a database.
            </aside>

          </Element>
        </Element>
        <Element Type="Section">
          Initializing child controls
          <Element Type="Text">

            <p>
              One paradigm you might hear frequently
              about ASP.NET is to do things declaratively. Whatever you can do directly
              within the aspx page, do it! However, this has some implications and
              limitations, and eventually you must start doing some work programmatically.
              The trouble is that initializing controls programmatically is not straightforward.
              As shown before, you can do this in <code>
                OnLoad
              </code>, but
              this could cause the view state to grow and, in any case, it’s not necessary to
              use view state when merely setting defaults. Even <code>OnInit</code> is not the best solution because view state will still track
              changes and catch the settings. If you need view state and can’t disable it,
              you’ll have to live with this behavior. Because the control’s view state tracks
              changes from the bottom up—say, from the last leaf control in the control
              hierarchy up to the tree’s root—the <code>
                OnInit
              </code> for
              child controls is done when the current <code>
                OnInit
              </code> is
              called.
            </p>

            <pre>&lt;asp:label id=&quot;lblDate&quot; runat=&quot;server&quot;/&gt;</pre>

            <p>In the code behind portion we set the text by assigning the current date:</p>

            <pre>
              public class MyControl : WebControl
              {
              protected override OnInit(EventArgs e)
              {
              lblDate.Text = DateTime.Now.ToLongDate();
              base.OnInit();
              }
              }
            </pre>

            <p>
              Even if this is the earliest
              event possible, it’s already too late. The label is initialized before the user
              control, and view state is already tracking changes. This means thatthe date persists
              in view state, which doesn’t make sense—this is the same situation we faced in
              the current user name example.
            </p>

            <p>
              Disabling view state has been
              discussed before, but this is not always a solution. Perhaps you have tried
              this:
            </p>

            <pre>
              &lt;asp:label id=&quot;lblDate&quot;
              runat=&quot;server&quot; Text=&quot;&lt;% = DateTime.Now.ToLongDate() %&gt;&quot;/&gt;
            </pre>

            <p>
              This is not possible, because
              ASP.NET doesn’t allow the initializing of properties in that way. Using
              databinding syntax <code>
                &lt;%# %&gt;
              </code> is no
              solution, either.
            </p>

            <p>
              Let’s assume that for some
              reason you want to assign the value by code. And you want to use view state for
              some other reason as well. You may think about <code>OnPreInit</code>,
              but this event isn’t recursive and appears only on the page level. So, what’s
              going on here? It’s interesting that the <code>
                OnInit
              </code> event
              behaves slightly differently depending on how you get access to it. The obvious
              way is to override the event handler. This is easy, well supported in IntelliSense,
              and the most common solution. You can attach events declaratively, too. As I
              said before, this is one of the major paradigms of ASP.NET.
            </p>

            <pre>
              &lt;asp:label id=&quot;lblDate&quot;
              runat=&quot;server&quot; OnInit=&quot;lblDate_Init&quot; /&gt;
            </pre>

            <p>
              This handler is fired before the
              internal initialization takes place—before the <code>
                TrackViewState
              </code> method is called and the view state starts tracking changes. Just
              set the text in the code behind as you would before:
            </p>
            <pre>
              public class MyControl : WebControl
              {
              public void lblDate_Init(object sender, EventArgs e)
              {
              lblDate.Text = DateTime.Now.ToLongDate();
              }
              }
            </pre>
          </Element>
          <Element Type="Sidebar" SidebarType="Tip">
            <header>Tip</header>
            <aside>If you’re wondering whether to use declarative events or just wire up to code—remember the basic rule: “Whatever we can do easily and safely the declarative way is our primary programming technique".</aside>
          </Element>
          <Element Type="Text">

            <p>
              Another solution comes to mind if you’re
              an experienced developer of object oriented software. Each object starts its
              life with the call of the object’s constructor. Usually the constructor is the
              place to initialize the object. However, in ASP.NET the life of controls begins
              some time later, in the initialization phase. You may subclass the control and
              override the constructor to invoke code there, but child controls are not yet
              present. The various events required are fired some time later. With a custom
              control it would work. This is indeed another powerful solution. By
              implementing your own label you can access the constructor without needing to do
              anything elsewhere:
            </p>
            <pre>
              public class MyLabel : Label
              {
              public MyLabel()
              {
              this.Text = DateTime.Now.ToLongDate();
              }
              }
            </pre>
            <p>
              This is a slightly modified label that
              simply initializes itself at the right time without any side effects. The
              constructor call assures that any tracking begins later.
            </p>
          </Element>
          <Element Type="Sidebar" SidebarType="Note">
            <header>Note</header>
            <aside>
              The internal “building
              steps" of an object, like the constructor call, are made before the life time
              of the object begins. By “life time", I mean the life of an object within the
              control’s or page’s life cycle—not the life time of an object within the
              runtime.
            </aside>

          </Element>
        </Element>
        <Element Type="Section">
          Attaching Dynamic controls
          <Element Type="Text">

            <p>
              All controls have a collection of child
              controls, represented by the property <code>
                Controls
              </code>.
              Some controls, such as <code>
                Label
              </code>, have an empty
              collection, because they can’t render children. All controls inherit the
              collection from <code>
                Control
              </code> base class.
              This is the common way to access the hierarchy of controls. The class behind
              the collection is defined:
            </p>

            <pre>
              public class ControlCollection :
              ICollection, IEnumerable
            </pre>

            <p>
              There are no obvious limits preventing
              you from adding new controls at any time.  With view state, it’s not that easy.
              View state can track values only for existing controls. To handle dynamic
              controls, you need to add them on any page load, whether it’s a postback or
              regular page load cycle. Attaching dynamic controls must happen in the
              initializing phase (<code>
                OnInit
              </code> event), because,
              at an earlier state, there is no hierarchy of controls to which you could
              attach anything. View state of those dynamically attached controls is then tracked
              automatically. Remember that this is done recursively through the whole
              hierarchy, so the <code>
                StateBag
              </code> class will
              never miss anything. However, this point is critical. You might experience the
              following exception loading the page after postback:
            </p>
            <pre> [Failed loading view state]</pre>

            <p>
              Failed to load view state. The control
              tree into which view state is being loaded must match the control tree that was
              used to save view state during the previous request. For example, when
              adding controls dynamically, the controls added during a post-back must match
              the type and position of the controls added during the initial request.
            </p>

            <p>
              Let’s create an example so that we can
              figure out what is happenning internally:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >

            protected void Page_Init(object sender, EventArgs e)
            {
            if (!IsPostBack)
            {
            Button myButton = new Button();
            form1.Controls.Add(myButton);
            myButton.Text = &quot;Click here&quot;;
            }
            else
            {
            Label label = new Label();
            form1.Controls.Add(label);
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              The intent of this code is
              obvious. The user has a <code>
                Button
              </code> to invoke some
              action, and, when the action is completed, the button is replaced by a <code>Label</code> control. You might argue that this is not good practice,
              but let’s examine it for the moment. View state tries to recognize the elements solely by their
              index. In this example the control at index [0] is the <code>Button</code>. After postback it has been replaced by the <code>Label</code>,
              using the same index [0]. This does not lead to the exception
              shown above, because the restoring code is fairly stupid. It just looks for the
              right property, and both <code>
                Button
              </code> and <code>Label</code> share the same <code>
                Text
              </code> property. While
              this works, the label now shows the text “Click here". Why? The exception
              appears even if this less than ideal method fails, probably because the control
              does not provide the expected property.
            </p>

            <p>
              The first solution is simple. Turn
              off view state for the button control. Since you throw away the button anyway, view
              state is not required at all. If the view state is being saved, it can’t
              disturb the next cycle—problem solved. Here is the solution in all its glory:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >

            protected void Page_Init(object sender, EventArgs e)
            {
            if (!IsPostBack)
            {
            Button myButton = new Button();
            myButton.EnableViewState = false;
            form1.Controls.Add(myButton);
            myButton.Text = &quot;Click here&quot;;
            }
            else
            {
            Label label = new Label();
            form1.Controls.Add(label);
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              Had you been using view state in the
              sample above, the problem would resolve itself—that is, if you had recreated
              the control after postback, which is one of the basic rules of dynamic controls
              creation. The ultimate solution looks like this:
            </p>

          </Element>
          <Element Type="Listing" Language="text/x-csharp" Highlight="true" LineNumbers="true" >

            protected void Page_Init(object sender, EventArgs e)
            {
            Button myButton = new Button();
            myButton.EnableViewState = false;
            form1.Controls.Add(myButton);
            myButton.Text = &quot;Click here&quot;;
            if (IsPostBack)
            {
            Label label = new Label();
            form1.Controls.Add(label);
            myButton.Visible = false;
            }
            }

          </Element>
          <Element Type="Text">

            <p>
              Here we are close to the best practice.
              Allow all controls on the page to remain untouched and switch the visibility on
              and off, as required, via code. The render method is smart enough to not render
              invisible controls. But that’s another topic and would lead us away from view
              state.
            </p>

          </Element>
        </Element>
        <Element Type="Section">
          Initializing dynamically created controls
          <Element Type="Text">

            <p>
              I discussed dynamic controls before and,
              reading the text, you might feel that there are some issues with them. This is
              indeed something we need to approach carefully, but there are no real issues.
            </p>

            <p>
              The problem is very similar to the one
              described before. Because you create the control when you choose, you have more
              influence and this makes your life easier. It does, however, run against the
              paradigm, because we leave the world of declarative definitions completely. In
              any case, let’s look how to handle another view state issue correctly.
            </p>
            <pre>
              public class MyCustomControl : Control
              {
              protected override void CreateChildControls()
              {
              Label l =  new Label();
              Controls.Add(l);
              l.Text = DateTime.Now.ToLongDate();
              }
              }
            </pre>
            <p>
              You can create child controls any time,
              but the <code>CreateChildControls</code> method is the best opportunity for fitting into the event sequence.
              The initialize event is called and the control doesn’t miss the tracking of
              view state. The secret is the behavior of the <code>
                Controls.Add
              </code>
              call. This isn’t just a collection; it does much more when the <code>Add</code> method is invoked. Even if all events of the parent
              hierarchy are complete, the control begins its regular life cycle and all events involved here are
              fired correctly. That means that the control starts tracking view state
              immediately after it’s added to the collection. <code>CreateChildControls</code> always seems too late, as even though it is called at different
              points in time, it’s always later than <code>OnInit</code>. Just
              for completeness, you need to know that it’s based on <code>EnsureChildControls</code> call, which happens in <code>OnPreRender</code>
              at the latest. For some reasons the call might come much earlier.
            </p>

            <p>Now take a closer look at the solution:</p>
            <pre>
              public class MyCustomControl : Control
              {
              protected override void CreateChildControls()
              {
              Label l =  new Label();
              l.Text = DateTime.Now.ToLongDate();
              Controls.Add(l);
              }
              }
            </pre>
            <p>
              There is only a subtle difference. The
              control’s properties are set before the control is added, which means that it’s
              initialized before the <code>OnInit</code> is fired, and
              that subsequently it has not yet begun to track the view state.
            </p>
            <p>
              You can also databind controls before they
              have been added to the parent control’s control hierarchy. This is very powerful
              and flexible. So real developers write their own custom controls and know how
              they work internally. Because this is a good topic for extensibility I’ll cover
              this in this book, too.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Summary">
        Summary
        <Element Type="Text">

          <p>
            In this chapter you learned about the
            internal processing of ASP.NET. Especially we took a look into the processing
            pipeline, which is running a single request and performs the steps required to
            create the content send to the client finally. The pipeline forms the life
            cycle of application, pages, and controls. During the life cycle several states
            store current processing step’s data. To rescue data from one request to
            another, the view state is used. You learned what the view state is for and how
            to overcome the quirks and traps the implemention has.
          </p>

          <p>
            However, Web applications handle usually
            more than one request at a time. The next chapter extends the description by
            looking into threading, thread pools, and other stuff required to make an
            ASP.NET project fast and reliable even if it comes under pressure from multiple
            requests.
          </p>
        </Element>
      </Element>
    </Element>
    <Element Type="Section" Name="Worker and Threads">
      Worker and Threads
      <Element Type="Text">

        <p>
          In the first chapter I looked into the handling
          of a page request, and, in particular, the application life cycle and page life
          cycle. This is the fundamental process that runs when anyone requests a page
          resource. However, Chapter 1 was a simplification of the situation—I assumed that
          only one request comes in at a time. Reality is quite different.
        </p>
        <p>
          Managing hundreds, or even thousands, of
          simultaneous requests requires advanced knowledge and skills. In this and
          subsequent chapters you will learn those skills.
        </p>
        <p>Objectives in this chapter:</p>
        <ul>
          <li>Learn how ASP.NET handles multiple requests</li>
          <li>Understand how to manage the worker processes and optimize the workload</li>
          <li>Comprehend the thread model, thread pool behavior and how to optimize its usage</li>
          <li>Learn how to build asynchronous handlers, pages, and tasks</li>
        </ul>

      </Element>
      <Element Type="Section" Name="Managing the Worker Process">
        Managing the Worker Process
        <Element Type="Text">

          <p>
            In Chapter 1 you learned about the
            worker process, w3wp.exe, which executes a request and initiates the ASP.NET
            engine processing. Managing the worker process is the key to managing high
            server demand, and keeping your applications stable and reliable.
          </p>

        </Element>
        <Element Type="Section" Name="Managing Worker Processes and AppDomains in IIS7">
          Managing Worker Processes and AppDomains in IIS7
          <Element Type="Text">

            <p>
              One of the leading Windows application
              management tools is Windows Management Instrumentation (WMI). You have probably
              used WMI to administer basic ASP.NET-related parts of IIS. It’s a well-known
              way to access worker processes while your application is running.
            </p>

          </Element>
          <Element Type="Sidebar"  SidebarType="Box">

            <header>Good Old Days: Windows Management Instrumentation</header>
            <aside>
              <p>WMI stands for Windows Management Instrumentation. If you’re unfamiliar with it, there’s a good introduction in Wikipedia at:</p>
              <ul>
                <li>http://en.wikipedia.org/wiki/Windows_Management_Instrumentation</li>
              </ul>
              <p>
                It suggests that WMI is a good tool for automating
                the management of worker processes and application domains in IIS7. It can also
                help us find a better way to customize the ASP.NET environment. IIS7 worker
                processes are spawned by the Windows Process Activation Service (WAS), using w3wp.exe.
                A worker process can contain AppDomains that are typically created to handle a request.
              </p>
            </aside>

          </Element>
          <Element Type="Text">

            <p>
              To accommodate today’s managed-code
              world, Microsoft exposed the WMI and COM method calls via .NET. Instead of invoking
              WMI directly, you can manage IIS using .NET typed classes, rather than using untyped
              strings. These classes expose a direct interface to the IIS7 management level
              and appear to be easy to use and robust.
            </p>

          </Element>
          <Element Type="Section" Name="Prerequisites">
            Prerequisites
            <Element Type="Text">

              <p>
                There are several prerequisites to writing
                sophisticated management applications using Visual Studio. First of all, IIS7
                itself is a prerequisite. No other web server currently supports these
                interfaces. To test your application it must run with elevated privileges. If
                you run the development environment on Windows Vista, you must launch Visual
                Studio with Administrator rights. An application built on such a system runs
                well on Windows Server 2008, as long as it runs with Administrator privileges.
                Once Visual Studio is running with the right account, you need to reference the
                administration assemblies in your project. There are several managed assemblies
                available in the IIS7 installation folder:
              </p>

              <p class="Query">&lt;%WinDir%&gt;\system32\inetsrv</p>

              <p>
                You will find several assemblies
                starting with the name “Microsoft.Web". Depending on what you’re planning to do,
                you’ll need one or another. For the moment, just reference all of them to
                ensure that all the examples in this chapter run properly. Here’s the list of what
                you’ll need:
              </p>
              <ul>
                <li>
                  <code>Microsoft.Web.Administration</code>
                </li>

                <li>
                  <code>Microsoft.Web.Management.Aspnet</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management.AspnetClient</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management.Iis</code>
                </li>

                <li>
                  font-family:"TheSansMonoConNormal","serif";
                  color:green'>           <code>Microsoft.Web.Management.IisClient</code>
                </li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Tasks to Manage">
            Tasks to Manage
            <Element Type="Text">

              <p>
                There are several tasks you can manage
                using the techniques described in this chapter. They will allow you to extend
                the available toolkit and customize the management of the ASP.NET environment. I
                will focus here on some of the more common tasks, but there is almost unlimited
                scope for extending the new management classes:
              </p>
              <ul>
                <li>
                  View the currently executing
                  requests for a worker process
                </li>

                <li>
                  Get the state of all worker processes
                </li>

                <li>
                  Unload a specific AppDomain, or all
                  AppDomains
                </li>

                <li>
                  Display all AppDomains and their
                  properties
                </li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Backup your Configuration">
            Backup your Configuration
            <Element Type="Text">

              <p>
                It is possible that the following
                samples will destroy or damage your IIS7 configuration. As it’s cumbersome to
                re-install your development environment after any undesirable side effects, you
                should test in a virtual machine or backup the IIS configuration of your
                production machine before you start.
              </p>
              <p>To make a backup of the configuration:</p>
              <ul>
                <li>
                  Open a command window with
                  Administrator rights
                </li>

                <li>Navigate to %WinDir%\system32\inetsrv</li>
                <li>Enter following command:</li>

                <p class="Query">            AppCmd add backup IIS7backup</p>

                <li>
                  The backup is created in the folder
                  %WinDir%\system32\inetsrv\IIS7backup
                </li>
              </ul>
              <p>
                You can use any name you like for the
                backup.
              </p>

            </Element>
            <Element Type="Image" Name="Backup command and created Backup folder with IIS7 settings">
              images/19835f0201.png
            </Element>
            <Element Type="Text">

              <p>
                The AppCmd tool has several options. The
                basic structure of the command is:
              </p>

              <p class="Query">AppCmd Command ObjectType ID Parameter</p>

              <p>
                The <i>command</i> parameter depends on
                the <i>ObjectType</i> parameter. For backup purposes the <i>ObjectType</i> is <code>Backup</code>. You can use the following commands:
              </p>
              <ul>
                <li>
                  list – shows all available backups
                </li>
                <li>
                  add – creates a new backup for the current configuration
                </li>
                <li>
                  delete – delete a backup from disk
                </li>
                <li>
                  restore – restore a backup and
                  overwrite current configuration
                </li>
              </ul>
              <p>
                The usage is straightforward. Again,
                remember to run this tool with Administrator privileges to access the IIS
                settings.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Basic tasks">
            Basic tasks
            <Element Type="Text">

              <p>
                The code in Listing 2-1 shows the
                typical structure of an IIS7 management code snippet. You can use whatever
                client environment you prefer. You could use a simple WPF (Windows Presentation
                Foundation) client to display the data in a hierarchical format (such as a
                TreeView), or perhaps well-formatted in a RichTextBox control.
              </p>

              <p>
                For the purpose of demonstrating sample
                code, a console application is a simple, satisfactory alternative. I will use
                the following generic test structure for the examples:
              </p>

            </Element>
            <Element Type="Listing" Name="Basic code structure for IIS7 administration code snippets">

              using System;
              using System.Text;
              using Microsoft.Web.Administration;

              namespace Apress.AspNetExtensiblity.IIS7Console
              {
                  static class IIS7Management
                  {

                      internal static string Method()
                      {

                          StringBuilder sb = new StringBuilder();
                                              // Code goes here
                                              return sb.ToString();
                      }
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                These static methods are invoked from the
                console’s entry point. The basis for most operations is
                the <code>ServerManager</code> class. From the
                <code>ServerManager</code> class there
                are several collections available:
              </p>
              <ul>
                <li>Applications</li>

                <li>Sites</li>

                <li>WorkerProcesses</li>

                <li>Bindings</li>

                <li>VirtualDirectories</li>
              </ul>
              <p>
                Through these collections you can reach
                the desired objects and properties for monitoring and managing IIS7. You always
                have read and write access. To save your changes, you need to explicitly call the
                <code>CommitChanges</code> method.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Get Information about the Worker Processes">
            Get Information about the Worker Processes
            <Element Type="Text">

              <p>
                Once I’ve shown you how to loop through
                each worker process on a Web server, you’ll see how to display the currently
                executing requests, process ID, and state of each worker process, as well as
                the application pool to which it belongs.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Get the State of a Worker Process">
            Get the State of a Worker Process
            <Element Type="Text">

              <p>
                The <code>WorkerProcess</code> object in the IIS7 administration has a
                <code>GetState</code> method that indicates whether a worker process is starting,
                running, or stopping. <code>WorkerProcess</code> also has
                two properties that particularly interest us: <code>ApplicationPool</code> and
                <code>ProcessId</code>. The
                <code>ApplicationPool</code> property represents the application pool to which the worker
                process belongs. The <code>ProcessId</code> property
                contains the process ID that uniquely identifies the worker process.
              </p>
            </Element>
            <Element Type="Listing" Name="Getting information about worker processes">

              internal static string ShowWorkerProcesses()
              {
                  StringBuilder sb = new StringBuilder();
                  try
                  {
                      ServerManager manager = new ServerManager();
                      foreach (WorkerProcess proc in manager.WorkerProcesses)
                      {
                          sb.AppendFormat(&quot;WorkerProcess found: {0}\n&quot;, proc.ProcessId);
                          sb.AppendFormat(&quot;\t|--AppPool : {0}\n&quot;, proc.AppPoolName);
                          sb.AppendFormat(&quot;\t|--ProcGuid: {0}\n&quot;, proc.ProcessGuid);
                          sb.AppendFormat(&quot;\t|--State   : {0}\n&quot;, proc.State.ToString());

                          foreach (ApplicationDomain appDom in proc.ApplicationDomains)
                          {
                              sb.AppendFormat(
                                  &quot;\t+--ApplicationDomain Found: {0}\n&quot;, appDom.Id);
                              sb.AppendFormat(
                                  &quot;\t\t|--AppDomPhysPath: {0}\n&quot;, appDom.PhysicalPath);
                              sb.AppendFormat(
                                  &quot;\t\t+--AppDomVirtPath: {0}\n&quot;, appDom.VirtualPath);
                          }
                      }
                      return sb.ToString();
                  }
                  catch (Exception ex)
                  {
                      return ex.Message;
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                The worker processes are exposed by the
                property <code>WorkerProcesses</code>.
                The value should match the number of w3wp.exe instances running in the Windows Task Manager.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Tip">
              <header>Tip</header>
              <aside>If there are no worker processes but IIS7 is running, open a website to force the process to launch.</aside>

            </Element>
            <Element Type="Text">

              <p>
                The properties used depend on the object
                you wish to investigate. Refer to the documentation on MSDN to get full
                descriptions of all available values.
              </p>

            </Element>
            <Element Type="Image" Name="Watching worker processes">
              images/19835f0203.png
            </Element>
            <Element Type="Text">

              <p>
                To monitor your worker processes, check the
                <code>State</code> property. The state of a process can be one of:
              </p>
              <ul>
                <li>Starting</li>

                <li>Running</li>

                <li>Stopping</li>

                <li>Unknown</li>
              </ul>
              <p>
                Why can’t the worker process have a
                state of "Stopped"? After the process has been shut down, the executable is
                disposed of and removed from memory. The worker process then disappears from the
                list of processes. Therefore, the worker is first starting, then running, and,
                if there is nothing to do, stopping. There isn’t a specific situation where the
                state <code>Unknown</code>
                appears, as the name implies. I assume that it occurs when the
                process dies unexpectedly and hangs.  
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Get Executing Requests">
            Get Executing Requests
            <Element Type="Text">

              <p>
                One exciting new feature of IIS7 is the
                ability to see the requests which are currently executing in a worker process.
                You do this with the <code>WorkerProcess.GetRequests</code> method in a manner
                very similar to the one shown above. Retrieve the worker process and invoke the <code>GetRequests</code>
                method to get the current requests.
              </p>

              <p>
                The <code>GetRequests</code>
                method requires an <code>int</code> parameter to filter
                the results for requests which have run for at least the number of milliseconds
                specified. This is very useful for displaying only long running requests. It’s a
                good idea to set the value to zero initially in order to get all requests, as
                shown in Listing 2-4.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Tip">
              <header>Tip</header>
              <aside>
                A request to test an application within the development environment can be tricky. Use the <code>Thread.Sleep</code>
                method to make the request last long enough to be caught.
              </aside>

            </Element>
            <Element Type="Text">

              <p>
                Use Windows Notepad to save the
                following text into a file called Sleep.aspx. Listing 2-3 shows the complete page for a
                request that will take a minute to execute.
              </p>

            </Element>
            <Element Type="Listing" Name="Define a page running one minute to get a long-lasting request">
              <Element Type="Text">

                &lt;% System.Threading.Thread.Sleep(60000);
                Response.Write (&quot;I'm finally finished...&quot;) %&gt;

              </Element>
            </Element>
            <Element Type="Text">

              <p>
                Running the management code, as in
                Listing 2-4, shows that the request is running and displays various properties
                for the request.
              </p>

              <Element Type="Listing" Name="Looping through some properties of a running worker process">

                internal static string ShowRequest()
                {
                    StringBuilder sb = new StringBuilder();
                    try
                    {
                        ServerManager manager = new ServerManager();
                        foreach (WorkerProcess proc in manager.WorkerProcesses)
                        {
                            foreach (Request r in proc.GetRequests(0))
                            {
                               sb.AppendFormat(&quot;Request:\n&quot;)
                                sb.AppendFormat(&quot; Hostname = {0}\n&quot;, r.HostName);
                                sb.AppendFormat(&quot; Url = {0}\n&quot;, r.Url);
                                sb.AppendFormat(&quot; Verb = {0}\n&quot;, r.Verb);
                                sb.AppendFormat(&quot; IP = {0}\n&quot;, r.ClientIPAddr);
                            }
                        }
                        return sb.ToString();
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  The console (see Figure 2-3) shows all the
                  requests currently running on available worker processes. Before running this on
                  a production system, it would be advisable to add some filter conditions to avoid
                  returning an excessive number of results.
                </p>

              </Element>
              <Element Type="Image" Name="Output shows detailed information about certain requests">
                images/19835f0202.png
              </Element>
              <Element Type="Text">

                <p>
                  Monitoring requests is not particularly
                  suited to a console application. Imagine you have some requests that don’t function
                  as expected, but the errors are infrequent and not reproducible. In this
                  situation, you could write an application to monitor a specific request and log
                  all relevant data. When the error reappears, your log file should contain
                  information enabling you to track down the error source.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name="Get Information about the Application Domains">
              Get Information about the Application Domains
              <Element Type="Text">

                <p>
                  The first time a request for an ASP.NET
                  page is received, the IIS7 managed engine module creates an application domain
                  (AppDomain) in memory. I explained this in Chapter 1. The AppDomain processes
                  requests for aspx pages, or any page that uses managed code. Unloading and
                  enumerating AppDomains is straightforward. This section shows you how to do
                  both.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name="Unloading a Specific AppDomain">
              Unloading a Specific AppDomain
              <Element Type="Text">

                <p>
                  To unload a specific AppDomain, you
                  must be able to uniquely identify it. AppDomains have three key properties: <code>Id</code>, <code>VirtualPath</code>
                  and <code>PhysicalPath</code>. One of these properties should be sufficient.
                </p>

                <p>
                  The code snippet in Listing 2-5 shows you
                  how to obtain the desired AppDomain using a  LINQ query. The nested
                  <code>from</code> statements form a join to retrieve the <code>ApplicationDomains</code> property for each running <code>
                    WorkerProcess
                  </code> object. The <code>where</code>
                  clause restricts the result to the single AppDomain defined by the given
                  <code>Id</code>. For a real-life application, this value could be a variable. We
                  saw the <code>ShowWorkerProcesses</code> method earlier in Listing 2-2.
                  It’s not required, but I’ve included it here for demonstration purposes.
                </p>

              </Element>
              <Element Type="Listing" Name="Retrieve information about the application domains">

                internal static string UnloadAppDomain(string name)
                {
                    StringBuilder sb = new StringBuilder();
                    try
                    {
                        sb.Append(ShowWorkerProcesses());
                        ServerManager manager = new ServerManager();
                        var appDomains = from proc in manager.WorkerProcesses
                                         from adc in proc.ApplicationDomains
                                         where adc.Id == &quot;/LM/W3SVC/4/ROOT&quot;
                                         select adc;

                        ApplicationDomain ad = appDomains.FirstOrDefault&lt;ApplicationDomain&gt;();

                        if (ad != null)
                        {
                            ad.Unload();
                            return name + &quot; unloaded&quot;;
                        }
                        else
                        {
                            return &quot;can't find &quot; + name;
                        }
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  Incidentally, the AppDomain’s <code>Id</code> property is a path that looks like this:
                </p>

              </Element>

              <Element Type="Listing">

                /LM/W3SVC/1/ROOT
              </Element>
              <Element Type="Text">

                <p>
                  The “1" in the path listed is
                  the site’s ID. “1" usually corresponds to the default Web site. You could find
                  any number here, depending on how many webs you have on the machine you’re
                  currently investigating.
                </p>

                <p>
                  If you generate a list of your
                  server’s AppDomains and their properties first, you’ll find the right one
                  easily (see Listing 2-2 where
                  we extracted the AppDomain instances from the currently running worker
                  processes).
                </p>

                <p>
                  However, the purpose of the
                  script was to unload a particular AppDomain. To understand what happens when
                  you unload an AppDomain, run this scenario:
                </p>
                <ul>
                  <li>Request a page from your server</li>
                  <li>
                    Watch running processes and
                    AppDomains and retrieve the properties
                  </li>
                  <li>Launch the code and unload the domain</li>
                  <li>Request the page again</li>
                  <li>Retrieve the very same information from properties</li>
                </ul>
              </Element>
            </Element>
            <Element Type="Section" Name="Unloading all AppDomains">
              Unloading all AppDomains
              <Element Type="Text">
                <p>
                  The next example unloads all
                  AppDomains. Again, I use LINQ and generic features. You don’t have to do it this
                  way, but it results in compact and highly readable code. The LINQ statement again
                  uses a nested query.
                </p>

              </Element>

              <Element Type="Listing" Name="Unload all AppDomains">

                internal static string UnloadAppDomains()
                {
                    try
                    {
                        ServerManager manager = new ServerManager();
                        Func&lt;ApplicationDomain, bool&gt; unloadFunc = new Func&lt;ApplicationDomain, bool&gt;(Unload);
                        var appDomains = from proc in manager.WorkerProcesses
                                         from adc in proc.ApplicationDomains
                                         where unloadFunc(adc) == true
                                         select adc;
                        return &quot;Unloaded &quot; + appDomains.Count() + &quot; domain(s)&quot;;
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

                private static bool Unload(ApplicationDomain appDomain)
                {
                    try
                    {
                        appDomain.Unload();
                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  The unload method is encapsulated in
                  the callback function <code>Unload</code>. It takes the
                  AppDomain as a parameter of type <code>
                    ApplicationDomain
                  </code>. As before, the query starts by retrieving the worker processes and
                  the AppDomains joined to them. In the <code>where</code> clause,
                  the inline method <code>unloadFunc()</code>  is used
                  to unload the domain. The <code>Func</code> type is a
                  predefined typed delegate used to pass a parameter and retrieve a Boolean
                  result flag. The clause forces the method call to <code>Unload</code>
                  and the return value decides whether the AppDomain becomes part of
                  the result set. This leads to a direct usage of the <code>Count</code>
                  method that returns the number of successfully unloaded AppDomains.
                </p>

              </Element>
              <Element Type="Image" Name="Number of successfully unloaded AppDomains">
                images/19835f0204.png
              </Element>
            </Element>
            <Element Type="Section" Name="Enumerating AppDomains">
              Enumerating AppDomains
              <Element Type="Text">

                <p>
                  Dealing with AppDomains in a management
                  environment often starts with showing all available properties. For learning
                  purposes it makes sense to investigate the AppDomain’s properties. Listing 2-7
                  shows how to get this information.
                </p>

              </Element>
              <Element Type="Listing" Name="Show properties of AppDomains">

                internal static string ShowAppDomains()
                {
                    StringBuilder sb = new StringBuilder();
                    try
                    {
                        ServerManager manager = new ServerManager();
                        var appDomains = from proc in manager.WorkerProcesses
                                         from adc in proc.ApplicationDomains
                                         select
                                           String.Format(@&quot;Physical Path = {0}
                                                         {4}VirtualPath = {1}
                                                         {4}Process ID = {2}
                                                         {4}Is Idle = {3}&quot;,
                                                adc.PhysicalPath,
                                                 adc.VirtualPath,
                                                 adc.Id
                                                 adc.Idle,
                                                 Environment.NewLine)

                        if (appDomains.Count() == 0)
                        {
                            sb.Append(&quot;can't find AppDomains&quot;);
                        }
                        else
                        {
                            foreach (string ad in appDomains)
                            {
                                sb.AppendLine(ad);
                            }
                        }
                        return sb.ToString();
                    }
                    catch (Exception ex)
                    {
                        return ex.Message;
                    }
                }

              </Element>
            </Element>
            <Element Type="Text">

              <p>
                The LINQ query retrieves the worker
                processes and the attached AppDomains. In the <code>select</code>
                clause, the string is constructed to simplify output. You can alter this clause
                to retrieve the specific values you desire. With this, you can monitor your
                ASP.NET environment with your custom application, without requiring Internet
                Information Services Manager Console.
              </p>

            </Element>

            <Element Type="Image" Name="Information about a running AppDomain">
              images/19835f0205.png
            </Element>
            <Element Type="Text">

              <p>
                You can compare this
                information with that available in the IIS Manager Console. Open the IIS
                Manager Console, navigate to the site and click on <i>Extended Settings</i> to
                see the settings and check against the values retrieved using the code shown
                above.
              </p>
              <p>
                When working with the <code>ApplicationDomain</code>
                object, you might see many more properties than were shown in the
                last example. This is because all settings derive from the <code>ConfigurationSettings</code>
                type, which contains several common properties that we don’t need.
                The helpful properties for an AppDomain are:
              </p>
              <ul>
                <li>
                  <code>Id</code>
                </li>
                <li>
                  <code>VirtualPath</code>
                </li>
                <li>
                  <code>PhysicalPath</code>
                </li>
                <li>
                  <code>Idle</code>
                </li>
              </ul>
              <p>
                Id returns the current internal Id of
                the AppDomain. The <code>VirtualPath</code> is as
                defined in the IIS settings; for the root path it is usually "/". The <code>PhysicalPath</code>
                is the full path to the application on local disk. The <code>Idle</code> property is
                a runtime value. It’s defined as <code>int</code>; it returns either 0 or 1, where the latter is the value for an
                idle application domain. Additional values about the worker process are
                helpful, too. You can add these easily by extending the <code>select</code> clause in this manner:
              </p>
            </Element>
            <Element Type="Listing">
              adc.WorkerProcess.ProcessId
            </Element>
            <Element Type="Text">
              <p>
                The object <code>adc</code> is of the current <code>
                  ApplicationDomain
                </code> type.
                By using a back reference to the <code>WorkerProcess</code> object, all property values
                available there can be retrieved directly.
              </p>
            </Element>
            <Element Type="Section" Name="Configuring the Worker Process">
              Configuring the Worker Process
              <Element Type="Text">
                <p>
                  Unlike classic ASP, which runs in the
                  same memory space as IIS, ASP.NET runs as a process of its own. This gives it more
                  flexibility, stability, and power. You can use the configuration file <i>machine.config</i>
                  to make the Webmaster’s job a lot easier.
                </p>
                <p>
                  I’ll take a closer look here at the
                  ASP.NET process and the attributes that we can adjust. The <i>machine.config</i>
                  file is plain XML and easy to read. As the name implies, it’s a definition at the
                  machine level. Several portions define the default values for the application
                  and the folder specific <i>web.config</i>. However, some parts can’t be
                  overwritten, and there’s no point in attempting to alter others.
                </p>
              </Element>
            </Element>
            <Element Type="Section" Name="The machine.config file">
              The machine.config file
              <Element Type="Text">
                <p>
                  As mentioned earlier, version 3.5 of the
                  .NET framework augments, rather than replaces, .NET framework 2.0. This
                  explains why the <i>machine.config</i> file is stored under the 2.0 hive. The
                  path on your machine should look similar to:
                </p>
                <p class="Query">%WinDir%\Microsoft.NET\Framework\v2.0.50727\CONFIG</p>
                <p>
                  There are several other configuration
                  files, but we’re only examining <i>machine.config</i>. Because it’s XML, you
                  can use Visual Studio to edit it. The worker process settings are stored in the
                  <code>&lt;processModel&gt;</code>
                  tag. It’s located under <code>&lt;system.web&gt;</code> and usually looks like this:
                </p>
                <p>
                  <code>&lt;processModel autoConfig="true" /&gt;</code>
                </p>
                <p>
                  Microsoft sets all common values using the
                  auto configuration option. This is good for most installations, but not all. To
                  optimize the settings, you can set the value of this attribute to false and
                  change whatever you like:
                </p>
                <p>
                  <code>
                    &lt;processModel autoConfig=&quot;false&quot; /&gt;
                  </code>
                </p>
                <p>
                  However, changing basic settings is not
                  simple and may lead to servers not responding or performing poorly. Before
                  going on, let me explain the various settings.
                </p>
              </Element>
              <Element Type="Sidebar" SidebarType="Note">
                <header>Note</header>
                <aside>
                  Changes made to the
                  &lt;processModel&gt; tag do not have immediate effect. You must restart a
                  worker process to force it to re-read the settings. To restart a worker process,
                  you can open Task Manager, right click the w3wp.exe found in the task list, and
                  kill the process. The worker process will start again automatically.
                </aside>
              </Element>
            </Element>
            <Element Type="Section" Name="Why Customize the machine.config Settings?">
              Why Customize the machine.config Settings?
              <Element Type="Text">
                <p>
                  You may wonder why and when you’re
                  supposed to change the <i>machine.config</i> settings and  the <code>>&lt;processModel&gt;</code> settings. Let’s consider the following scenario:
                </p>
                <ul>
                  <li>
                    Your network supports only one
                    application domain (AppDomain)
                  </li>
                  <li>
                    Each page causes one request (no
                    subsequent AJAX calls)
                  </li>
                  <li>
                    All requests go to the same IP
                    address
                  </li>
                </ul>
                <p>
                  In this case, the default settings are
                  very good and there is no reason to change anything. However, other specific
                  scenarios could be problematic:
                </p>
                <ul>
                  <li>Requests to many IP addresses</li>
                  <li>Frequent redirects (HTTP status code 302)</li>
                  <li>Using authentication</li>
                  <li>Using more than one AppDomain</li>
                </ul>
                <p>
                  The following section describes
                  all the <code>processModel</code>
                  parameters. (A later section, <i>Configuring the Thread Pool</i>,
                  explains this in even greater depth.)
                </p>
                <p>
                  Keep in mind that, behind the
                  scenes, IIS must handle the available resources to manage all incoming
                  requests. If the rate of incoming page requests is such that the fraction of
                  memory in use or CPU power exceeds certain levels, the default values for the <code>processModel</code>
                  parameters may not be optimal. However, setting higher values is
                  not always better as this can lead to higher resource consumption and slow down
                  even a lightly-loaded server handling simple requests. Finding the most
                  appropriate options in the parameter jungle is a challenge. 
                </p>

              </Element>
            </Element>

            <Element Type="Section" Name="A First Look Into the Attributes">
              A First Look Into the Attributes
              <Element Type="Text">

                <p>
                  Table 2-1 lists the <code>processModel</code>
                  attributes available. The description column indicates the purpose
                  of each attribute and where to find more information.
                </p>

              </Element>
              <Element Type="Table" Name="Settings available for the &lt;processModel&gt; tag (excerpt)">
                <table>
                  <tr>
                    <th>Attribute</th>
                    <th>Default</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>
                      <code>clientConnectedCheck</code>
                    </td>
                    <td>00:00:05 (five seconds)</td>
                    <td>Once a request has been waiting in the queue for this long, ASP.NET checks whether the client is still connected.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>cpuMask</code>
                    </td>
                    <td>0xffffffff</td>
                    <td>
                      Specifies
                      which CPU of a multiprocessor system runs ASP.NET processes. The value is a
                      bitmask where each bit represents a CPU. Assume you set the value to 0xa, which
                      is 1010 in binary form. CPUs are numbered beginning with 0, and read from right
                      to left. For this value, CPUs 1 and 3 are qualified to run ASP.NET threads and CPUs
                      0 and 2 are not.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>enable</code>
                    </td>
                    <td>true</td>
                    <td>Enables or disables the process model.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>idleTime</code>
                    </td>
                    <td>Infinite</td>
                    <td>
                      The period
                      of inactivity (in time format hh:mm:ss), after which the worker process ends.
                      (For example, a value of “00:20:00" will cause the worker process to shut down
                      twenty minutes after the last request is concluded.) “Infinite" prevents the
                      worker process from stopping at all.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>logLevel</code>
                    </td>
                    <td>Errors</td>
                    <td>The quantity of errors written to the event log. Choose from “All", “Errors", or “None".</td>
                  </tr>
                  <tr>
                    <td>
                      <code>maxAppDomains</code>
                    </td>
                    <td>2000</td>
                    <td>
                      The number of application domains in one process. The default value, 2000, is the maximum
                      allowed. Lower values are appropriate for hosting providers, for instance.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>maxIoThreads</code>
                    </td>
                    <td>20</td>
                    <td>
                      The maximum
                      number of threads for I/O operations, counted on a per-CPU basis. Must be greater than or equal to <code>minFreeThreads</code> in
                      <code>&lt;httpRuntime&gt;</code> settings. Allowed range is between 5 and 100. See the section
                      “Understanding and using threads" in this chapter for more information.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>maxWorkerThreads</code>
                    </td>
                    <td>20</td>
                    <td>
                      The maximum number of worker threads, counted on a per-CPU basis. Must be greater than
                      or equal to <code>minFreeThreads</code> in
                      <code>&lt;httpRuntime&gt;</code> settings. Allowed range is between 5 and 100. See section
                      “Understanding and using threads" in this chapter for more information.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>memoryLimit</code>
                    </td>
                    <td>60</td>
                    <td>
                      The maximum allowed memory size as a percentage of total system memory that one worker
                      process is allowed to consume. Beyond this limit, a new worker process is launched and subsequent requests are redirected to this one.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>minIoThreads</code>
                    </td>
                    <td>1</td>
                    <td>The minimum number of I/O threads. See section “Understanding and using threads" in this chapter for more information.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>minWorkerThreads</code>
                    </td>
                    <td>1</td>
                    <td>The minimum number of worker threads. See section “Understanding and using threads" in this chapter for more information.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>username</code>, <code>password</code>
                    </td>
                    <td>AutoGenerate</td>
                    <td>The account used to run the worker process.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>pingFrequency</code>
                    </td>
                    <td>Infinite</td>
                    <td>
                      The time interval in hh:mm:ss format used to ping the worker process to get its state.
                      If the worker process is not running it is restarted.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>pingTimeout</code>
                    </td>
                    <td>Infinite</td>
                    <td>The time, also in hh:mm:ss format, waiting for a response to a ping request. After a ping timeout is detected, the process is restarted.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>requestLimit</code>
                    </td>
                    <td>Infinite</td>
                    <td>The number of requests a single worker process can handle. Beyond this value a new worker process starts.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>requestQueueLimit</code>
                    </td>
                    <td>5000</td>
                    <td>The number of requests allowed in the queue. Any request beyond this limit receives the HTTP error 503 “Server Too Busy" response.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>responseDeadlockInterval</code>
                    </td>
                    <td>00:03:00 </td>
                    <td>
                      The time period (again in hh:mm:ss format) allowed for the worker process to respond to a queued request. After the time period expires, the worker process
                      is restarted. The default is three minutes.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>restartQueueLimit</code>
                    </td>
                    <td>10</td>
                    <td>
                      After a nonstandard (unexpected) termination of the worker process, incoming requests are queued, waiting for the worker process to become available. The value
                      specifies the number of requests queued.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>serverErrorMessageFile</code>
                    </td>
                    <td>-</td>
                    <td>
                      A file path (either absolute or relative to the <i>machine.config</i> file path) for a file containing the error message to send to the client when a fatal
                      error occurs. If no file is present or the attribute is not set, the string “Server unavailable" is sent. This is the default setting.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>shutdownTimeout</code>
                    </td>
                    <td>00:00:05</td>
                    <td>The time the worker process is allowed to take when shutting the process down. If this time interval is exceeded, the worker process is forcibly terminated.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>timeout</code>
                    </td>
                    <td>Infinite</td>
                    <td>If a worker process is not responding, ASP.NET launches a new one after the specific period is elapsed.</td>
                  </tr>
                  <tr>
                    <td>
                      <code>webGarden</code>
                    </td>
                    <td>False</td>
                    <td>
                      A flag which indicates that the attribute cpuMask is being used. If False (default) this means that all CPU cores are available for worker processes and the
                      operating system decides which CPU will handle the next request.
                    </td>
                  </tr>
                </table>
              </Element>
            </Element>
          </Element>
          <Element Type="Section" Name="Additional Settings Outside the ProcessModel Tag">
            Additional Settings Outside the ProcessModel Tag
            <Element Type="Text">

              <p>
                The <code>&lt;processModel&gt;</code>
                tag  attributes control most of the relevant settings. However,
                there are more tags where we can refine the configuration. One important setting
                is shown below:
              </p>

            </Element>
            <Element Type="Listing">

              &lt;system.net&gt;
                &lt;connectionManagement&gt;
                  &lt;add address=&quot;&quot; maxconnection=&quot;100&quot; /&gt;
                &lt;/connectionManagement&gt;
              &lt;/system.net&gt;

            </Element>
            <Element Type="Text">

              <p>
                This does not impact your client
                connections but controls the connections you make from your application to
                other servers, such as fetching RSS feeds or using web services on another
                server. The default for the attribute <code>maxconnection</code>
                is 2, which is obviously too low. It means you cannot make more
                than two simultaneous connections to an IP address, from your web application.
                In the sample above the value is set to 100.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Specific Tasks">
            Specific Tasks
            <Element Type="Text">

              <p>
                Using these settings, you can perform
                specific tasks. The following sections explain how to use the attributes to:
              </p>
              <ul>
                <li>Recycle the worker process</li>
                <li>Shut down the worker process</li>
                <li>Check if the client is still connected</li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Recycling the Worker Process">
            Recycling the Worker Process
            <Element Type="Text">

              <p>
                A common task configured in this manner
                is the recycling of the process. This generally improves the stability and
                reliability of your web application. There are five ways to recycle a process
                using the attributes <code>timeout</code>,
                <code>requestLimit</code>,
                <code>memoryLimit</code>,
                <code>responseDeadlockInterval</code>
                , and the pair <code>pingFrequency</code>/
                <code>pingTimeout</code>
                . They are explained one by one below:
              </p>
              <ul>
                <li>timeout=&quot;48:00:00&quot;  </li>
              </ul>
              <p>
                This involves the <code>timeout</code>
                attribute, which simply creates a new process after the specified
                time interval elapses. For example, the above setting will start a new process
                after 48 hours, or two days. The first request causes the timer to start.
              </p>
              <ul>
                <li>requestLimit=&quot;1000&quot;  </li>
              </ul>
              <p>
                Another way is to use the <code>requestLimit</code>
                attribute and an Integer value. A value of 1,000 will start a new
                process after 1,000 requests have been made. This can be useful if your web
                server’s performance degrades after a set number of requests.
              </p>
              <ul>
                <li>memoryLimit=&quot;30&quot;  </li>
              </ul>
              <p>
                A third way is to let your system watch
                how much memory the process is consuming. In the above example, the attribute <code>
                  memoryLimit
                </code>
                is set to 30% of the total system memory. Once the limit is
                reached, the process is killed, a new one is created, and all existing requests
                are reassigned to the new process. This is helpful when you have a memory leak.
              </p>
              <ul>
                <li>responseDeadlockInterval=&quot;00:02:00&quot; </li>
              </ul>
              <p>
                A fourth approach is to use the <code>responseDeadlockInterval</code>
                attribute. The time setting of two minutes will restart the process
                if there are requests in the queue and if there have been no responses for the
                last two minutes.
              </p>
              <ul>
                <li>pingFrequency=&quot;00:00:30&quot; </li>
                <li>pingTimeout=&quot;00:00:05&quot; </li>
              </ul>
              <p>
                The final method for recycling the
                process is to use the <code>pingFrequency</code> and
                <code>pingTimeout</code>
                attributes in tandem. The system pings the process at the
                <code>pingFrequency</code>
                interval, and restarts it if there is no response within the
                <code>pingTimeout</code> time interval.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Shutting Down the Process">
            Shutting Down the Process
            <Element Type="Text">

              <p>
                There are two ways of shutting down the worker
                process.
              </p>
              <ul>
                <li>idleTimeout=&quot;00:20:00&quot; </li>
              </ul>
              <p>
                The first way uses the <code>idleTimeout</code>
                attribute. If the server has not served any requests for 20 minutes
                (in this example), then it automatically shuts down the process. If a new request
                comes in, a new process is started automatically. This might be useful if you experience
                long periods of inactivity. The server can then handle other tasks better
                because there is more free memory.
              </p>
              <ul>
                <li>shutDownTimeout=&quot;00:00:10&quot; </li>
              </ul>
              <p>
                The second way is by using the <code>shutDownTimeout</code>
                attribute. This is used as a last resort after  the worker process
                tries to shut down gracefully and fails. In this case, after the time set here
                has passed, a low level kill command is performed on the process to ensure its
                termination. This is useful in situations where the process has crashed and is
                no longer responding. The setting shown will force a kill after ten seconds.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name="Checking if the client is still connected">
            Checking if the client is still connected
            <Element Type="Text">
              <p>
                This is useful for eliminating unwanted
                requests from the queue.
              </p>
              <ul>
                <li>clientConnectedCheck=&quot;00:00:10&quot; </li>
              </ul>
              <p>
                Users can become impatient. If your web
                server is slow to respond to their requests, they might click on the same link
                many times. Even if only the last request is returned to them, the server will
                process all the previous ones. Furthermore, if the user abandons their session
                with your server, the queue from that user will remain. In the example above, the
                server will check each request at ten seconds intervals after it has entered
                the queue, to ensure that the user who made it is still connected. If the user
                is not, the server discards that request.
              </p>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Understanding and Using Threads">
        Understanding and Using Threads
        <Element Type="Text">
          <p>In ASP.NET, threads are like magic.</p>
          <p>
            Threads are well-known and easy to
            program using .NET techniques. However, in ASP.NET, threading is handled behind
            the scenes and consequently regarded by some developers as unimportant. This
            common misunderstanding of threading can cause poor performance, unpredictable
            behavior, and, in the end, unreliable applications.
          </p>
        </Element>
        <Element Type="Section" Name="ASP.NET Thread Usage on IIS">
          ASP.NET Thread Usage on IIS
          <Element Type="Text">
            <p>
              Threading in ASP.NET is complicated by
              the various changes Microsoft applied over the years with each new version of
              IIS. As we saw in Chapter 1, IIS plays a major part in ASP.NET’s request
              processing. Because of the co-existence of IIS6 and IIS7, I will explain firstly
              how threads are handled in IIS6, and then the changes in threading introduced
              with IIS7.
            </p>
            <p>
              You may also think of other hosting
              capabilities ASP.NET supports. Because threading has a direct and explicit
              relation to multiple requests and high workload, other environments, such as
              Visual Studio’s integrated web server, do not handle threads in any special way
              worth discussing.
            </p>

          </Element>
          <Element Type="Section" Name="Thread Usage with IIS6">
            Thread Usage with IIS6
            <Element Type="Text">
              <p>
                Each request from the outside world to
                the web server is handed over to an I/O thread on IIS. This thread comes from the
                CLR (Common Language Runtime) ThreadPool and returns the status “Pending" to
                IIS. Having passed the work on to the new thread, IIS is now free to service
                other requests, such as requests for static resources.
              </p>
              <p>
                The CLR ThreadPool works like a
                queue. It can adjust itself according to the actual workload. This means that the
                situation depends on the frequency of incoming requests and the ability of the processor
                workload to respond to each request. There are two extreme situations you need
                to take care of.
              </p>
              <p>
                Firstly, you might receive many
                simultaneous requests that are processed quickly. In this case, the ThreadPool will
                attempt to run only 1 or 2 threads per CPU to ensure a very low latency (waiting
                time).
              </p>
              <p>
                Secondly, you might receive a
                few requests where one is processor intensive and somewhat long-running.
                Additional incoming requests will cause more threads to be spawned per CPU. The
                processing time will always be longer in this scenario.
              </p>
              <p>
                A queue is a clever way to
                avoid allocating a lot of memory for each request, before processing starts and
                memory expensive objects such as <code>HttpRequest</code> are
                created. Keep in mind that the thread queue is in native memory and has no
                overhead caused by managed code components. Once a thread is ready for processing,
                we leave the unmanaged world and start working completely within the managed code
                realm.
              </p>
              <p>
                The ThreadPool queue is not the
                only way to handle a lot of incoming requests. Within each AppDomain there are
                ways to handle requests that exceed the number of available threads. If there
                is lot of latency, the ThreadPool starts growing and launches more active
                threads. However, there are physical limitations; either the system runs out of
                threads, or the available memory restricts the number of threads.
              </p>
            </Element>
            <Element Type="Sidebar" SidebarType="Note">
              <header>Note</header>
              <aside>default the ThreadPool has a limitation of 25 worker threads per CPU and 1000 I/O completion threads.</aside>
            </Element>
            <Element Type="Text">
              <p>
                ASP.NET sets its own limits to
                ThreadPool usage. If this limit is exceeded, incoming requests are still
                handled but another queue is now built on the application level and performance
                becomes significantly worse. You can control the settings with the following
                parameters of the <code>&lt;httpRuntime&gt;</code> tag:
              </p>
              <ul>
                <li>
                  <code>minFreeThreads</code>
                </li>
                <li>
                  <code>minLocalRequestFreeThreads</code>
                </li>
              </ul>
              <p>
                Performance Counters are widely
                used in Windows to monitor a system running with high workload. To observe the
                internal behavior of the ThreadPool you can use the following counter: “ASP.NET
                Applications\Requests in Application Queue".
              </p>
              <p>
                Any value but zero shows that
                there is a performance problem on that system, as it indicates that the
                ThreadPool has at some time run out of threads.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Managing the ThreadPool">
            Managing the ThreadPool
            <Element Type="Text">

              <p>
                Usually the ThreadPool does not require
                managing, because few sites exceed the default limitations. Additionally, the
                <code>autoConfig</code>
                settings allow the ASP.NET engine to optimize behavior as much as
                possible. However, maintaining an ASP.NET system that is running near its limits
                is the goal of this book. If you experience performance issues, it’s time to explore
                manual intervention. The auto settings assume that the number of concurrently
                executing requests per CPU is twelve. An application with high latency might
                require higher values.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Thread Usage with IIS7">
            Thread Usage with IIS7
            <Element Type="Text">

              <p>
                In chapter 1, I discussed IIS7 and
                integrated mode several times. As mentioned earlier, the differences between
                IIS7 and IIS6 are significant for basic page request processing.
              </p>
              <p>
                First of all, the queues built
                on the application level are gone, due to poor performance. The biggest difference is that IIS6
                restricts the number of threads, while IIS7 restricts the number of requests.
                Each thread in IIS6 handles a request and this—indirectly—limits the number of
                requests handled in parallel. IIS7 is able, due to the tight integration of
                ASP.NET within IIS7, to directly restrict the number of requests. It is when
                you employ asynchronous processing that this makes a difference. Although the
                processing pipeline is usually synchronous (see Chapter 1), both, Handlers and
                Modules, can be set up to run asynchronously. I’ll explain this, with examples,
                later in this chapter.
              </p>

              <p>
                For requests that are processed
                synchronously, the number of threads equals the number of requests, as each
                request runs in a single thread. If the processing is asynchronous, the number of
                threads may differ from the number of requests.
                Imagine that an incoming
                request starts processing and is running a long lasting action. The thread is
                handed over to ASP.NET and IIS accepts the next incoming request. This leads to
                more concurrently running requests than threads. ASP.NET gets the request as
                incoming IIS I/O thread. The CLR ThreadPool is immediately asked to create and
                start a new thread and this thread becomes responsible for this very request.
                As quickly as it starts, it returns with status of “Pending". After this, IIS
                checks the number of requests currently executing. If this value is too high,
                the next request is put in a process-wide global queue. This queue is in native
                code within IIS7.

              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Configuring the ThreadPool">
            Configuring the ThreadPool
            <Element Type="Text">

              <p>
                In the <code>&lt;processModel&gt;</code> configuration settings are the following parameters:
              </p>
              <ul>
                <li>
                  <code>autoConfig</code>
                </li>
                <li>
                  <code>maxWorkerThreads</code>
                </li>
                <li>
                  <code>maxIoThreads</code>
                </li>
                <li>
                  <code>minWorkerThreads</code>
                </li>
                <li>
                  <code>minIoThreads</code>
                </li>
              </ul>
              <p>
                The settings for IIS6 <code>minFreeThreads</code> and <code>minFreeThreads</code> in the <code>httpRuntime</code>
                tag are still there, but they do nothing. They are there merely for
                backwards compatibility. But where can you find the settings for IIS7? With
                .NET 3.5 SP1 the settings become available in web.config, as shown below:
              </p>
              <pre>
                &lt;system.web&gt;
                  &lt;applicationPool maxConcurrentRequestsPerCPU=&quot;12&quot;
                                  maxConcurrentThreadsPerCPU=&quot;0&quot;
                                  requestQueueLimit=&quot;5000&quot;/&gt;
                &lt;/system.web&gt;
              </pre>
            </Element>
            <Element Type="Text">
              <p>
                The <i>web.config</i> settings
                override the settings in the Registry mentioned in the footnote.
              </p>

              <p>
                They are not values that you
                would change frequently. You might experiment with different quantities, but
                the default is usually appropriate. The current settings are a compromise
                between requests for static resources such as images, and dynamic resources such
                as aspx pages.
              </p>

              <p>
                In chapter 6, I’ll explain the
                extensibility concepts of resource management. This includes the creation of
                design time expressions to retrieve resources. It’s possible to suppress code
                compilation when your aspx pages consist solely of declarative markup,
                resources, and expressions. This is a way to optimize overall system
                performance under particular circumstances.
              </p>
              <p>
                Now, you could try setting the
                number of threads per request to 0. If you have only static requests and no (or
                very few) dynamic ones, and if these dynamic requests are fast due to
                such
                techniques
                , this might
                improve performance. Imagine that the requests are now being executed within
                the IIS I/O thread and that there is no handover procedure to the CLR
                ThreadPool. Less overhead leads to faster resource processing.
              </p>

              <p>
                The opposite scenario appears
                when you have many heavily asynchronous operations. In this case, the limit of twelve
                threads might be too low. Imagine a scenario you’ll probably work with: Ajax
                enabled applications. These applications have fewer page requests but many
                background tasks created by JavaScript/web service pairs. This is heavily asynchronous
                and a single webpage can send large numbers of such requests. If you look into
                browser-based Outlook clients or Word-like text processing interfaces, you’ll
                see that a lot of background work happens even when the user merely moves the mouse
                pointer. Settings of up to
                several thousand are possible in order to handle many simple requests. 5000 is
                the limit, without making changes elsewhere in the system.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Server Too Busy">
            Server Too Busy
            <Element Type="Text">

              <p>
                You might be wondering when and why the
                “Server Too Busy" status is sent to the client. This is HTTP status error 503
                and appears when the limit of concurrent requests exceeds the default value of
                5000. The actual value is exposed by the “ASP.NET/Requests Current" performance
                counter.
              </p>

              <p>
                See the section “Install a Performance
                Counter" for details on how to monitor and log such values and discover what is
                happening to your server at any given moment.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Tune the threading">
          Tune the threading
          <Element Type="Text">
            <p>
              The previous explanations might
              discourage you from changing the settings. However, they’re worth exploring
              when performance issues arise or strange errors occur. This section shows some
              solutions for the following error messages:
            </p>
            <ul>
              <li>A process serving application pool ‘name’ exceeds time limits during shut down</li>
              <li>System.InvalidOperationException: There are not enough free threads in the ThreadPool object to complete the operation.</li>
              <li>HttpException (0x80004005): Request timed out.</li>
            </ul>
            <p>
              To solve the problems above, try the
              following:
            </p>
            <ul>
              <li>Limit the number of requests that can execute at the same time to approximately twelve per CPU. This limit works well for most applications.</li>
              <li>Permit web service callbacks to freely use threads in the ThreadPool. </li>
              <li>
                Select an appropriate value for the <code>maxconnections</code> attribute. Base your selection on the number of IP addresses and AppDomains that are used (more details follow).
              </li>
            </ul>

          </Element>
        </Element>
        <Element Type="Section" Name="Tuning Task by Task">
          Tuning Task by Task
          <Element Type="Text">

            <p>
              This section gives some examples of how
              and when to change the default settings of the following values:
            </p>
            <ul>
              <li>maxWorkerThreads </li>
              <li>minWorkerThreads </li>
              <li>maxIoThreads </li>
              <li>minFreeThreads </li>
              <li>minLocalRequestFreeThreads </li>
              <li>maxconnection </li>
              <li>executionTimeout </li>
            </ul>

          </Element>
        </Element>
        <Element Type="Section" Name="Set maxWorkerThreads and maxIoThreads">
          Set maxWorkerThreads and maxIoThreads
          <Element Type="Text">

            <p>
              ASP.NET uses the following two
              configuration settings to limit the number of worker threads and completion
              threads used:
            </p>

          </Element>
          <Element Type="Listing">

            &lt;processModel maxWorkerThreads=&quot;20&quot; maxIoThreads=&quot;20&quot;&gt;

          </Element>
          <Element Type="Text">
            <p>
              The <code>maxWorkerThreads</code> attribute and the <code>
                maxIoThreads
              </code> attribute are
              implicitly multiplied by the number of CPUs. In the example, the maximum number
              of worker threads is 40 if you have a dual-core processor.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set minFreeThreads and minLocalRequestFreeThreads">
          Set minFreeThreads and minLocalRequestFreeThreads
          <Element Type="Text">

            <p>
              ASP.NET also contains the following
              configuration settings which determine how many worker threads and completion
              port threads must be available to start a remote request or a local request:
            </p>

          </Element>
          <Element Type="Listing">

            &lt;httpRuntime minFreeThreads=&quot;8&quot; minLocalRequestFreeThreads=&quot;8&quot;&gt;

          </Element>
          <Element Type="Text">
            <p>
              If there are insufficient threads
              available, the request is queued until sufficient threads are free to handle
              the request. Therefore, ASP.NET will not execute more than the following number
              of requests at the same time:
            </p>

            <p class="Query">(maxWorkerThreads  numCPUs ) - minFreeThreads</p>

            <p>
              The <code>minFreeThreads</code> parameter and the <code>
                minLocalRequestFreeThreads
              </code> attributes are not implicitly multiplied by the number of CPUs.
              Assuming you have four CPUs, the formula given equals 24 parallel requests ((8
              x 4) – 8).
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set minWorkerThreads">
          Set minWorkerThreads
          <Element Type="Text">

            <p>
              ASP.NET also contains a configuration
              setting for the number of worker threads to be made available immediately to
              service a remote request.
            </p>

          </Element>
          <Element Type="Listing">

            &lt;processModel minWorkerThreads=&quot;1&quot;&gt;
          </Element>
          <Element Type="Text">

            <p>
              Threads that are controlled by
              this setting can be created at a much faster rate than worker threads that are
              created from the CLR’s default capabilities.
            </p>

            <p>
              Requests may suddenly fill the
              request queue due to a slow-down on a back end server, a sudden burst of
              requests from the client end, or something similar that would cause a sudden
              rise in the number of requests in the queue.
            </p>

            <p>
              The default value for the <code>minWorkerThreads</code> parameter is
              1. Microsoft recommends that you set the value for the
              <code>minWorkerThreads</code> parameter to half of the <code>
                maxWorkerThreads
              </code> value. By default, the <code>
                minWorkerThreads
              </code> parameter is implicitly multiplied by the number of CPUs.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set maxconnection">
          Set maxconnection
          <Element Type="Text">

            <p>
              The <code>maxconnection</code> attribute determines how many connections can be made to a specific
              IP address. The setting was mentioned before, but here is a more complex
              scenario:
            </p>

          </Element>
          <Element Type="Listing">

            &lt;connectionManagement&gt;
                &lt;add address=&quot;&quot; maxconnection=&quot;2&quot;&gt;
                &lt;add address=&quot;10.6.205.84&quot; maxconnection=&quot;20&quot;&gt;
            &lt;/connectionManagement&gt;

          </Element>
          <Element Type="Text">

            <p>
              The <code>maxconnection</code> setting applies at the AppDomain level. Consequently, only two
              connections (by default) can be made to a specific IP address from each
              AppDomain in your process.
            </p>
            <p>
              In this example, all IP addresses
              accept two connections, except for the specified one at 10.6.205.84, which accepts
              20.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Set executionTimeout">
          Set executionTimeout
          <Element Type="Text">

            <p>
              ASP.NET uses the following
              configuration setting to limit the request execution time (in seconds):
            </p>

          </Element>
          <Element Type="Listing">

            &lt;httpRuntime executionTimeout=&quot;90&quot;/&gt;

          </Element>
          <Element Type="Text">
            <p>
              This refers to the <code>Server.ScriptTimeout</code> property exposed by the
              <code>HttpServer</code>
              object. If you increase the value of the <code>executionTimeout</code> attribute, you may
              have to also modify the <code>responseDeadlockInterval</code> attribute of the
              <code>&lt;processModel&gt;</code>
              tag.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name="Install a Performance Counter">
          Install a Performance Counter
          <Element Type="Text">
            <p>
              To monitor the current workload, you can
              use a Performance Counter. Open the <i>Reliability and Performance Monitor </i>tool
              (PerfMon) by entering <i>PerfMon</i> in the <i>Run</i> window. Install the
              counter using these steps:
            </p>
            <ol>
              <li>1. Click on “Performance Monitor" in the tree view.</li>
              <li>2. Right click and choose “New" and then “Data Collector Set".</li>
            </ol>
          </Element>
          <Element Type="Image" Name="Install new data collection using the Performance Monitor tool">
            images/19835f0210.png
          </Element>
          <Element Type="Text">
            <ol start="3">
              <li>
                Give the collection an appropriate name
                (such as “MonitorIIS") and click “Next".
              </li>
              <li>
                Choose a directory in which the data is to
                be saved. The default path is %systemdrive%\PerfLogs\Admin\MonitorIIS, if you have
                named the collection “MonitorIIS". Click “Next".
              </li>
              <li>
                In the last step, you can choose an
                account with which to run the counter. This is, by default, the current
                account. If you’re logged on as Administrator, it’s fine. Otherwise, select an
                appropriate account by clicking on “Change".
              </li>
              <li>
                Finish the wizard with the “Finish"
                button.
              </li>
            </ol>
            <p>
              You can now open your collection within
              the object’s tree view at the left and navigate the path to Reliability and
              Performance &gt; Data Collector Sets &gt; User Defined &gt; MonitorIIS. There
              is a default entry here named “System Monitor Log". You can modify this or add
              a new data collector. Let’s add a new one to demonstrate the process. Right
              click on the leaf entry in the tree named MonitorIIS and choose New &gt; Data
              Collector. A wizard launches and asks for a name and collection type. Name it
              “IISRequest" and choose Performance counter data collector as the type.
            </p>
          </Element>
          <Element Type="Image" Name="Add a new Data Collector">
            images/19835f0211.png
          </Element>
          <Element Type="Text">
            <p>
              Click on “Next" to add the
              counter. On the wizard’s next screen, choose “Add…" and search for the counter.
              In the left hand area you’ll find the Available counters group. Search for the section
              “ASP.NET Application" and expand it. The list is sorted alphabetically. Scroll
              down to “Requests In Application Queue". In the “Instances of selected object"
              group, you’ll find all applications. Accept the default selection __Total__ to view
              all requests. Click “Add&gt;&gt;" and “OK". The monitor begins to watch the
              counter and saves the results in the file chosen.
            </p>
            <p>
              To view the results, open the
              path Reliability and Performance &gt; Reports &gt; User Defined &gt; MonitorIIS
              &gt; IISRequest. It might take some time to load the results, depending on
              workload and settings. There are several ways to modify the counter to bind it
              to specific events. For example, you could add a scheduler to run the counter
              at a specific time. For instance, if you experience problems between 1 and 2
              a.m. on your server, it doesn’t make sense to run the tool the whole day and
              collect an unnecessarily large amount of data.
            </p>
            <p>
              You can define stop conditions
              based on time frame or the size of the log file. You can also launch a task
              when the scheduler stops. Depending on the resources of the server you could
              run an application that automatically analyses the content, sending the log
              file to an email address, or just copying it to another location.
            </p>
            <p>
              This short description does not
              cover the Reliability and Performance Monitor tool in all its glory. It’s just
              a “teaser" so that you know there are powerful tools available to monitor a
              server and find bottlenecks, failures and performance loss easily. You can also
              gather hard data to confirm a problem, find a solution, and validate that your
              solution fixes the problem.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name="Threading and Asynchronous Operations">
          Threading and Asynchronous Operations
          <Element Type="Text">
            <p>
              For most scenarios, the internal thread
              handling is well-designed and functional. However, there are situations where
              you reach the limits of the default settings. In particular, if a site comes
              under pressure from too many requests, the internal thread pool can run out of
              threads and the server will no longer respond as expected. I’ll discuss several
              techniques for overcoming this. I’ll consider how the common language runtime thread pool
              is used by ASP.NET to service requests, as well as looking into the pooling
              mechanisms used for handlers, modules, and applications.
            </p>
            <p>
              I’ll also show the threading usage independent
              of other techniques and the asynchronous processing of requests using internal
              features to solve common issues.
            </p>
          </Element>
          <Element Type="Section" Name="Threading in ASP.NET">
            Threading in ASP.NET
            <Element Type="Text">
              <p>
                To efficiently service multiple client
                requests, web servers make extensive use of concurrency by launching multiple processes
                and spawning multiple threads to service requests. Considering the construction
                and behavior of the ASP.NET engine, it seems that developers need not concern
                themselves with threading at all, as the challenging aspects are handled
                internally. This is correct for most scenarios; page requests are serviced on
                the same thread and a separate instance is created to service each new request.
                However, there are scenarios where you reach the limits of this model—as every
                model has limits—and need to extend the behavior.
              </p>

              <p>
                First of all, a clear understanding of
                the internal behavior is required. Some parts have been explained in the
                previous sections but I will repeat it from the perspective of threading. The
                process-wide CLR thread pool services requests. The thread pool size is set to
                25 worker threads and 25 I/O threads by default. Recall the <code>&lt;processModel&gt;</code>
                settings explained already:
              </p>
              <pre>
                &lt;processModel enable=&quot;true&quot;
                              maxWorkerThreads=&quot;25&quot;
                              maxIoThreads=&quot;25&quot; /&gt;
              </pre>
              <p>
                As explained in chapter 1, for each
                incoming request an instance of the type <code>HttpApplication</code> is created. To avoid
                reallocating applications and modules, each AppDomain holds a pool of applications and modules. The size of this pool is also
                25—that means that 25 requests can be handled per worker process.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name="The Need for Asynchrony">
            The Need for Asynchrony
            <Element Type="Text">
              <p>
                Imagine that you need to exclusively
                request a resource. As long as one person is using an application this is not a
                problem. However, web applications are typically employed by many, if not
                thousands, of concurrent users. The thread pool and thread handling design
                allows several requests to be executed in parallel to improve the user’s
                experience when using a web application.
                Limiting the number of threads is
                important in order to allow more than one request per CPU or core.
                Creating a
                vast number of threads can cause a system to a grind to a halt.
              </p>
              <p>
                However, a request can launch
                different kinds of tasks. Processing a page and sending resources to the client
                is the most common action. Requesting data from a database, RSS feed, or web
                service is another.  Requesting data can be time consuming, rather than processor
                intensive. What happens then? The number of threads in the thread pool quickly reaches
                its limit and subsequent requests are not handled as expected. Despite this,
                the CPU is only idling. As you learned in the previous sections, the settings
                allow you to change the number of concurrent threads. But this is not a solution
                either, as your system has to handle both kinds of requests: short-lived
                requests for resources and long running queries against other servers.
              </p>
              <p>
                To make things clearer, look at
                Listing 2-8. It delays a request while demanding little from the CPU. It displays
                the thread ID to show whether or not a new thread is created to handle the
                request.
              </p>
            </Element>
            <Element Type="Listing" Name="A simple page which slows down a request (Threading/SlowThread.aspx)">
              &lt;%>@ Page Language=&quot;C#&quot; %&gt;
              &lt;%>@ Import Namespace=&quot;System.Reflection&quot; %&gt;
              &lt;%>@ Import Namespace=&quot;System.Threading&quot; %&gt;

              &lt;script runat=&quot;server&quot;&gt;
                protected void Page_Load(object src, EventArgs e)
                {
                  System.Threading.Thread.Sleep(3000);
                  Response.Output.Write(&quot;Slow Response, Thread ID={0}&quot;,
                                 AppDomain.GetCurrentThreadId());
                }
              &lt;/script&gt;
            </Element>
            <Element Type="Text">
              <p>
                To test it, open the page in a browser.
                Open the page in more browser windows and refresh all the pages within the
                three second (3000 millisecond) period. You’ll see that the thread ID exposed
                by the script changes for each request. Once the period is over the next
                request receives a recycled thread from a previous request. Several long
                running requests can fill the thread pool and easily reach the limit of 25
                concurrent threads.
              </p>
              <p>
                Removing the <code>Sleep</code> call (Listing 2-9) will result in a faster running page. You won’t
                be able to request the page again while the server is handling the previous
                one. The thread IDs demonstrate that all requests run on the same thread, and the
                thread pool is never filled up to its limit.
              </p>
            </Element>
            <Element Type="Listing" Name="A simple page which performs well (Threading/FastThread.aspx)">
              &lt;%>@ Page Language=&quot;C#&quot; %&gt;
              &lt;%>@ Import Namespace=&quot;System.Reflection&quot; %&gt;

              &lt;script runat=&quot;server&quot;&gt;
                protected void Page_Load(object src, EventArgs e)
                {
                  Response.Output.Write(&quot;Fast Response, Thread ID={0}&quot;,
                                 AppDomain.GetCurrentThreadId());
                }
              &lt;/script&gt;
            </Element>
            <Element Type="Text">

              <p>
                Microsoft offers a stress test tool for
                simulating multiple concurrent requests even in the development environment.
                See
                the sidebar about the Web Stress Tool for more information.

              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Box">
              <header>Web Stress TOOL</header>
              <aside>
                <p>The web application stress tool can be downloaded from:</p>
                <ul>
                  <li>http://www.microsoft.com/downloads/details.aspx?familyid=e2c0585a-062a-439e-a67d-75a89aa36495&amp;displaylang=en</li>
                </ul>
                <p>
                  Unfortunately the tool is quite old and
                  Microsoft has not refreshed it to support newer environments. So if you run it
                  on Vista, a DLL named msvcp50.dll is missing. You may find the file on the web
                  or you can safely copy it from the support files section provided with this
                  book. Perform these steps to install the stress test tool:
                </p>
                <ul>
                  <li>Download the setup.exe from the address shown above</li>
                  <li>Download msvcp50.dll from the Apress support web site</li>
                  <li>Copy the unzipped file to folder %WinDir%\system (you must run with higher privileges to do this). Note that this is really system, not system32!</li>
                  <li>Install the stress test tool</li>
                  <li>Run it once to check that it’s working. Start it as an Administrator.</li>
                </ul>
                <p>Now you can use the tool as outlined in the following sections.</p>
              </aside>

            </Element>
          </Element>
          <Element Type="Section" Name="Working with the Stress Test Tool">
            Working with the Stress Test Tool
            <Element Type="Text">

              <p>
                A stress test is what the name
                implies—your application is forced to handle as many requests as necessary to
                feel stressed. To walk through this stress test, you’ll need to set up the
                pages shown above (Listings 2-8 and 2-9) within your IIS environment, which you’re
                able to run from a browser manually. Follow the steps below to set up the
                script in the stress test tool. I have set IIS to use this path:
              </p>

              <p class="Query">http://localhost/Threading/SlowThread.aspx</p>

              <p class="Query">http://localhost/Threading/FastThread.aspx</p>

              <p>
                Firstly, set up the script by adding the
                content tree—the pages requested from the tool.
              </p>

            </Element>
            <Element Type="Image" Name="Set the content for a stress test">
              images/19835f0206.png
            </Element>
            <Element Type="Text">

              <p>
                The content tree allows you to set the
                actions the tool performs several times. Alternatively, you can record a session
                to save the page load action. However, in this script, only one page is called
                using a GET command, so recording is not necessary.
              </p>

            </Element>
            <Element Type="Image" Name="Settings used to force the test">
              images/19835f0207.png
            </Element>
            <Element Type="Text">

              <p>
                The settings define how the
                tool operates on the server. In Figure 2-9 I set thirty threads, which create thirty
                concurrent requests. This runs for twenty seconds as quickly as possible. There
                is no throttling and no other options are used. This is the configuration that
                should cause the server to create twenty five threads and bring the thread pool
                to its limit.
              </p>

              <p>
                Table 2-2 shows the results of some
                stress tests. Remember that there is a wide range of possible values for
                response time depending on your machine, its configuration, and what other applications
                and services are currently running. It’s the relative values that are
                significant here.
              </p>

            </Element>
            <Element Type="Table" Name="Test results using a web stress test tool">
              <table>
                <tr>
                  <th> </th>
                  <th>Threads File</th>
                  <th>Hits </th>
                  <th>Average response time</th>
                </tr>

                <tr>
                  <td>100</td>
                  <td>FastThread.aspx</td>
                  <td>21093</td>
                  <td>45 ms</td>
                </tr>

                <tr>
                  <td>20</td>
                  <td>FastThread.aspx</td>
                  <td>21034</td>
                  <td>8.3 ms</td>
                </tr>

                <tr>
                  <td>100</td>
                  <td>SlowThread.aspx</td>
                  <td>33</td>
                  <td>6,108 ms</td>
                </tr>

                <tr>
                  <td>20</td>
                  <td>SlowThread.aspx</td>
                  <td>32</td>
                  <td>4,654 ms</td>
                </tr>

              </table>
            </Element>
            <Element Type="Text">

              <p>
                These results are not
                surprising. The server is less able to handle the requests as the number of parallel
                threads increases. Because we’re forcing IIS to queue the requests, this causes
                additional overhead.
                Running the client against both FastThread.aspx and SlowThread.aspx,
                however, reduces the average response time for FastThread.aspx requests to 2.05
                seconds and only 98 hits being handled.

                For SlowThread.aspx, the number of threads makes no significant difference. This is
                the worst case—because of long running requests, fast ones are not served
                quickly. Increasing the CPU power will not help. The slow page does not consume
                any CPU power because there is nothing to calculate. The delay you see is due
                to the saturation of the thread pool. Even the fast requests are queued until a
                thread is released.
              </p>

              <p>
                This demonstrates that some pages
                can influence the performance of other requests even if they have nothing to do
                with each other. What is the solution?
              </p>

              <p>
                I discussed previously the various
                settings available for improving the system’s behavior. In the stress test I
                used 100 threads. Increasing the thread pool limits might help. However, the
                real world does not have a defined number of requests regularly arriving.
                Finding the right value is anything but easy. It could change depending on user
                behavior, server settings, network connection, and application code—which means
                that there is no right answer.
              </p>
              <p>
                The solution we’re looking for
                should free the threads in the thread pool to hold the utilization low and have
                enough threads available at any time. In other words, each page should behave like
                a fast running page. This brings us to asynchronous handlers.
              </p>

            </Element>
            <Element Type="Sidebar" SidebarType="Note">
              <header>Note</header>
              <aside>
                next chapter is
                dedicated the world of handlers and modules. Here we discuss only the portion
                directly related to threading issues. For more information about handlers,
                refer to chapter 3.
              </aside>
            </Element>
          </Element>
          <Element Type="Section" Name="Custom Thread Pool and Asynchronous Handlers">
            Custom Thread Pool and Asynchronous Handlers
            <Element Type="Text">

              <p>
                While most ASP.NET pages and handlers
                are serviced synchronously on threads drawn from the thread pool, it is
                possible to create handlers and pages that service requests asynchronously.
              </p>

              <p>
                Asynchronous handlers implement the <code>IHttpAsyncHandler</code> interface, which derives from <code>
                  IHttpHandler
                </code>.
              </p>

            </Element>
            <Element Type="Listing" Name="Definition of the IHttpAsynchHandler interface">

              public interface IHttpAsyncHandler : IHttpHandler
              {
                IAsyncResult BeginProcessRequest(HttpContext ctx,
                                                 AsyncCallback cb,
                                                 object obj);
                void EndProcessRequest(IAsyncResult ar);
              }

            </Element>
            <Element Type="Text">

              <p>
                The interface follows the typical pattern
                for asynchronous actions—it has a method for indicating the beginning and one for
                indicating the end of a process. Usually handlers have a method named <code>ProcessRequest</code>.
                Instead of calling this method, the asynchronous handler calls the <code>BeginProcessRequest</code>
                method. In this method, you launch a new thread and manage things, which can take some time. The method returns immediately, providing a reference
                to an <code>IAsyncResult</code> instance. This frees the thread from the thread pool. A new thread
                is then used to perform the long running action. When the internal (or private)
                thread returns, the <code>EndProcessRequest</code>
                method is called. The <code>IAsyncResult</code> instance
                is handed over in order to parameterize the call. Cleanup actions, such as closing
                a database connection, are best placed here.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Handler with a Delegate">
            <Element Type="Text">
              <p>
                Creating an asynchronous handler with a
                delegate is the most common approach. Delegates called with <code>BeginInvoke</code> implicitly create a new thread.
              </p>

            </Element>

            <Element Type="Listing" Name="A handler using IHttpAsyncHandler">
              &lt;%>@ WebHandler Language=&quot;C#&quot; Class=&quot;Apress.Threading.AsyncHandlers.AsyncHandler&quot; %&gt;

              using System;
              using System.Web;
              using System.Threading;
              using System.Diagnostics;
              using System.Reflection;

              namespace Apress.Threading.AsyncHandlers
              {

                  public delegate void ProcessRequestDelegate(HttpContext ctx);

                  public class AsyncHandler : IHttpAsyncHandler
                  {
                      public void ProcessRequest(HttpContext ctx)
                      {
                          System.Threading.Thread.Sleep(2000);
                          ctx.Response.Output.Write(
                                       &quot;Async Delegate, Thread ID={0}&quot;,
                                       AppDomain.GetCurrentThreadId());
                      }

                      public bool IsReusable
                      {
                          get { return true; }
                      }

                      public IAsyncResult BeginProcessRequest(HttpContext ctx,  style='font-family: Wingdings'>
                                                              AsyncCallback cb,  style='font-family:Wingdings'>
                                                              object obj)
                      {
                          ProcessRequestDelegate prg = new ProcessRequestDelegate(ProcessRequest);
                          return prg.BeginInvoke(ctx, cb, obj);
                      }

                      public void EndProcessRequest(IAsyncResult ar)
                      {
                      }

                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                Call this handler by using a browser, as
                before, to test that it’s running properly:
              </p>

              <p class="Query">http://localhost/Threading/AsyncThreadDelegate.ashx</p>

              <p>
                The process starts with the
                method <code>BeginProcessRequest</code>. Using the delegate and its <code>
                  BeginInvoke
                </code>
                method, the method <code>ProcessRequest</code> is
                called. Then the <code>Sleep</code> method simulates
                something long running without performing anything on the CPU. Because there is
                nothing to clean up, no code is required  in <code>EndProcessRequest</code>.
              </p>

              <p>
                Now it’s time to see what the
                stress test tool is reporting.
              </p>

              <p>
                If you run the test as before,
                you can see that the results are nearly identical. What is going on here? Why write
                asynchronous delegates if there is no speed improvement at all? The reason is in
                the way ASP.NET internally handles the threading.
              </p>

              <p>
                Recall that when I first
                introduced the term “thread pool", it was called a “process wide thread pool".
                The asynchronous handler still runs in the very same process, which leads to a lack
                of improvement. The original thread is freed, but the new one is taken from the
                same thread pool. The same thing would happen if you used <code>ThreadPool.QueueUserWorkItem</code>
                from the <code>System.Threading</code>
                namespace. We need to find where we can get a new thread from another thread source.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Handler with Custom Threads">
            Asynchronous Handler with Custom Threads
            <Element Type="Text">

              <p>
                Before we can implement the whole
                solution, another interface is required—<code>IAsynchResult</code>—as the return result is now essential. The definition is short—just
                four properties (Listing 2-12).
              </p>

            </Element>
            <Element Type="Listing" Name="The definition of IAsyncResult">

              public interface IAsyncResult
              {
                public object     AsyncState             { get; }
                public bool       CompletedSynchronously { get; }
                public bool       IsCompleted            { get; }
                public WaitHandle AsyncWaitHandle        { get; }
              }

            </Element>
            <Element Type="Text">

              <p>
                Our actual implementation of the
                <code>IAsynchResult</code> interface (Listing 2-13) has two additional properties: a reference
                to the <code>HttpContext</code> object, and a reference to the callback object. The callback method
                is invoked later, when processing is complete. The
                <code>AsyncState</code> object is optional; you can use it to store private data.
                <code>AsyncWaitHandle</code> returns a <code>
                  WaitHandle
                </code> object,
                which is used to signal when the request is complete. Using the
                <code>CompleteRequest</code> method implemented additionally to the requirements of the interface,
                the calling class can execute the <code>EndProcessRequest</code> method. In this routine, the <code>
                  WaitHandle
                </code>
                object is triggered. Either way, the <code>IsCompleted</code>
                property shows that the object has reached the completed state.
              </p>

            </Element>
            <Element Type="Listing" Name="The implementation of IAsyncResult (from AsyncThreadCallback.ashx)">

              class AsyncRequestState : IAsyncResult
              {

                  internal HttpContext _ctx;
                  internal AsyncCallback _cb;
                  internal object _data;
                  private bool _isCompleted;
                  private ManualResetEvent _ completeEvent;

                  public AsyncRequestState(HttpContext ctx,
                                           AsyncCallback cb,
                                           object data)
                  {
                      _ctx = ctx;
                      _cb = cb;
                      _data = data;
                  }
                  internal HttpContext CurrentContext
                  {
                      get
                      {
                        return _ctx;
                      }
                  }

                  internal void CompleteRequest()
                  {
                      _isCompleted = true;
                      lock (this)
                      {
                          if (_completeEvent!= null)
                              _ completeEvent.Set();
                      }
                      // invoke registered callback, if any
                      if (_cb != null)
                          _cb(this);
                  }

                  public object AsyncState
                  {
                      get
                      {
                          return (_data);
                      }
                  }
                  public bool CompletedSynchronously
                  {
                      get
                      {
                          return (false);
                      }
                  }
                  public bool IsCompleted
                  {
                      get
                      {
                          return (_isCompleted);
                      }
                  }
                  public WaitHandle AsyncWaitHandle
                  {
                      get
                      {
                          lock (this)
                          {
                              if (_completeEvent == null)
                                  _ completeEvent = new ManualResetEvent(false);

                              return _completeEvent;
                          }
                      }
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                The next step is to spawn a new
                thread to process the request. The method called on this new thread will need
                access to the state cached in the <code>AsyncRequestState</code> class shown above. To pass necessary data to this object, a
                parameterized thread is used, based on <code>ParameterizedThreadStart</code> class.
              </p>

              <p>
                The handler itself is similar to
                the one already introduced. The definition for the ashx page looks like this:
              </p>

            </Element>
            <Element Type="Listing">

              &lt;%@ WebHandler Language=&quot;C#&quot;
              Class=&quot;Apress.Threading.AsyncHandlers.CustomAsyncHandler&quot; %&gt;

            </Element>
            <Element Type="Text">

              <p>
                The <code>ProcessRequest</code> method must be present, as it is required by the interface
                <code>IHttpAsyncHandler</code>, but we don’t use it. The whole work is split between the
                <code>BeginProcessRequest</code> and <code>
                  EndProcessRequest
                </code>
                methods. In the <code>BeginProcessRequest</code>
                method the <code>AsyncRequestState</code> object is created,
                along with the reference to the context and callback.
              </p>

            </Element>
            <Element Type="Listing" Name="The implementation of AsyncResult (AsyncThreadCallback.ashx)">

              public class CustomAsyncHandler : IHttpAsyncHandler
              {
                  public void ProcessRequest(HttpContext ctx)
                  {
                      // not used
                  }

                  public bool IsReusable
                  {
                      get { return false; }
                  }

                  public IAsyncResult BeginProcessRequest(HttpContext ctx,
                                                          AsyncCallback cb,
                                                          object obj)
                  {
                      AsyncRequestState reqState = style='font-family:Wingdings'>
                                        new AsyncRequestState(ctx, cb, obj);
                      ParameterizedThreadStart ts = new ParameterizedThreadStart(ProcessThread);
                      Thread t = new Thread(ts);
                      t.Start();

                      return reqState;
                  }

                  public void EndProcessRequest(IAsyncResult ar)
                  {
                      AsyncRequestState ars = ar as AsyncRequestState;
                      if (ars != null)
                      {
                         ars.CurrentContext.Response.Write(&quot;End Request reached&quot;);
                      }
                  }

                  private void ProcessThread(object obj)
                  {
                      Thread.Sleep(2000);
                      AsyncRequestState asr = obj as AsyncRequestState;
                      asr.CurrentContext.Response.Output.Write( style='font-family:Wingdings'>
                                  &quot;Async Thread, Thread ID = {0}&quot;, style='font-family:Wingdings'>
                                  AppDomain.GetCurrentThreadId());
                      // signal end of processing
                      asr.EndRequest();
                  }

              }

            </Element>
            <Element Type="Text">

              <p>
                Let’s look at the code to understand how
                it’s working. Figure 2-10 shows
                the thread usage during internal processing. Initiated by the request, the
                process starts by calling the <code>BeginProcessRequest</code>
                method. The <code>AsyncHandler</code>
                creates the helper objects required and launches the new custom thread
                independent of the thread pool. The custom thread runs and the thread pool
                thread is released. Once the process is completed, the end is signaled via the
                callback method and the request is finished.
              </p>
            </Element>
            <Element Type="Image" Name="First step of the processing using an asynchronous handler">
              images/19835f0208.png
            </Element>
            <Element Type="Text">
              <p>
                The response held in memory is
                waiting for the thread to complete. This might seem disappointing, because it
                doesn’t make anything faster. The page is still waiting for the slow operation
                to finish, and so is the user. Remember the thread pool issue, however; once the
                pool runs out of threads, the performance of the whole server is reduced and no
                more requests are handled properly. The advantage of custom threads is not a
                faster response for one user but for all users.
              </p>

              <p>
                In step two, as shown in Figure 2-11, the call to <code>EndRequest</code> indicates the end of the process and terminates the request. Once
                called, the response is complete and sent to the browser. This means that you
                can add content to the response at any time before the <code>EndProcessRequest</code> method is called. In the example code (Listing 2-14) the
                <code>Response.Output.Write</code> method demonstrates this.
              </p>

            </Element>
            <Element Type="Image" Name="Second step of the processing using an asynchronous handler">
              images/19835f0209.png
            </Element>
            <Element Type="Text">

              <p>
                Run the stress test again to see
                whether
                you find an improvement
                . Under
                pressure it performs better, and the thread pool no longer runs out of threads.
                This allows the site to accept incoming requests at any time, and the whole
                server appears to be more responsive. Again, the processing time for a single
                page is the same.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Handler and a Custom Thread Pool">
            Asynchronous Handler and a Custom Thread Pool
            <Element Type="Text">

              <p>
                This technique is useful for
                many extensibility projects. In Chapter 3, I’ll show more examples of practical
                implementations that solve common issues. All handlers explained there use
                simple synchronous operations. You can implement them all as asynchronous
                counterparts using the techniques described here. Using asynchronous handlers
                you’ll see how to improve the overall performance of an ASP.NET site
                drastically. The thread issues and handlers that I discuss here are just one
                solution.
              </p>

              <p>
                There is another issue that
                can be found easily using the stress test tool. In one of the previous
                paragraphs I wrote “accept incoming requests at any time".
                This is quite a claim, as it assumes that the server will respond no matter how
                many requests arrive, just by creating new threads. However, the operating
                system, CPU power, available memory, and architectural restrictions of the
                hardware may stop the code from creating new threads. It is possible for too
                many threads to be created, in which case they will block each other and make
                the system slow and unresponsive.
              </p>

              <p>
                You might ask “Why not use a
                thread pool?" Unfortunately, .NET has only one thread pool internally and it is
                used by ASP.NET. That’s why using <code>ThreadPool.QueueUserWorkItem</code> does not work. Our task now is the creation
                of our own thread pool. Several people have done this successfully. Mike
                Woodring wrote a version which is useful and fits our needs, using the code in
                an asynchronous handler. The original version can be found on his page:
              </p>

              <p class="Query">http://www.bearcanyon.com/</p>

              <p>
                I have adapted his code to suit
                our needs for a handler.
              </p>

              <p>
                There are several clever aspects
                to this code. The usage of <code>HttpContext</code> is much
                simpler. In the previous example, a reference to the context object was stored
                and the use of <code>HttpContext.Current</code> was forbidden. It is
                not good programming practice to change well known method calls.
              </p>

            </Element>
            <Element Type="Listing" Name="Delegates and base interface for the thread pool">

              public delegate void WorkRequestDelegate(object state,  style='font-family:Wingdings'> DateTime requestEnqueueTime );
              public delegate void ThreadPoolDelegate();

              #region IWorkRequest interface
              public interface IWorkRequest
              {
                  bool Cancel();
              }
              #endregion
            </Element>
            <Element Type="Text">

              <p>
                The following code shows the
                implementation in several steps. The core functionality is explained inline.
              </p>

            </Element>
            <Element Type="Listing" Name="The basic thread pool implementation">

              public sealed class ThreadPool : WaitHandle
              {
                  #region ThreadPool constructors                  public ThreadPool( int initialThreadCount, int maxThreadCount, string poolName )
                      : this( initialThreadCount, maxThreadCount, poolName,
                              DEFAULT_NEW_THREAD_TRIGGER_TIME,
                              DEFAULT_DYNAMIC_THREAD_DECAY_TIME,
                              DEFAULT_THREAD_PRIORITY,
                              DEFAULT_REQUEST_QUEUE_LIMIT )
                  {
                  }

                  public ThreadPool( int initialThreadCount,
              int maxThreadCount, string poolName,
                                     int newThreadTrigger, int dynamicThreadDecayTime,
                                     ThreadPriority threadPriority, int requestQueueLimit )
                  {

                      Handle = stopCompleteEvent.Handle;

                      if( maxThreadCount &lt; initialThreadCount )
                      {
                          throw new ArgumentException(&quot;Maximum thread count must be &gt;= initial style='font-family:Wingdings'>
                                                       thread count.&quot;, &quot;maxThreadCount&quot;);
                      }

                      if( dynamicThreadDecayTime &lt;= 0 )
                      {
                          throw new ArgumentException(&quot;Dynamic thread decay time cannot be &lt;= 0.&quot;
                                                   , &quot;dynamicThreadDecayTime&quot;);
                      }

                      if( newThreadTrigger &lt;= 0 )
                      {
                          throw new ArgumentException(&quot;New thread trigger time cannot be &lt;= 0.&quot;
                                                     , &quot;newThreadTrigger&quot;);
                      }
                      this.initialThreadCount = initialThreadCount;
                      this.maxThreadCount = maxThreadCount;
                      this.requestQueueLimit = (requestQueueLimit &lt; 0 ?  style='font-family:Wingdings'>
                                                DEFAULT_REQUEST_QUEUE_LIMIT : requestQueueLimit);
                      this.decayTime = dynamicThreadDecayTime;
                      this.newThreadTrigger = new TimeSpan(TimeSpan.TicksPerMillisecond   style='font-family:Wingdings'>
                                                            newThreadTrigger);
                      this.threadPriority = threadPriority;
                      this.requestQueue = new Queue(requestQueueLimit &lt; 0 ?  style='font-family: Wingdings'>
                                                     4096 : requestQueueLimit);
                      if( poolName == null )
                      {
                          throw new ArgumentNullException(&quot;poolName&quot;,  style='font-family:Wingdings'>
                                                          &quot;Thread pool name cannot be null&quot;);
                      }
                      else
                      {
                          this.threadPoolName = poolName;
                      }
                  }

            </Element>
            <Element Type="Text">

              <p>
                The next region sets several ThreadPool
                properties. The <code>Priority</code> and the
                <code>DynamicThreadDecay</code> properties are not thread safe. They can only be set before
                <code>Start</code> is called.
              </p>

            </Element>
            <Element Type="Listing">

                  public ThreadPriority Priority
                  {
                      get { return(threadPriority); }
                      set
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Cannot adjust thread  style='font-family:Wingdings'>
                                              priority after pool has been started.&quot;);
                          }

                          threadPriority = value;
                      }
                  }

                  public int DynamicThreadDecay
                  {
                      get { return(decayTime); }
                      set
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Cannot adjust dynamic thread style='font-family:Wingdings'>
                                                decay time after pool has been started.&quot;);
                          }

                          if( value &lt;= 0 )
                          {
                              throw new ArgumentException(&quot;Dynamic thread decay time cannot   style='font-family:Wingdings'>
                                                            be &lt;= 0.&quot;, &quot;value&quot;);
                          }

                          decayTime = value;
                      }
                  }
                  public int NewThreadTrigger
                  {
                      get { return((int)newThreadTrigger.TotalMilliseconds);}
                      set
                      {
                          if( value &lt;= 0 )
                          {
                              throw new ArgumentException(&quot;New thread trigger time cannot  style='font-family:Wingdings'>
                                                            be &lt;= 0.&quot;, &quot;value&quot;);
                          }

                          lock( this )
                          {
                              newThreadTrigger = new TimeSpan(TimeSpan.TicksPerMillisecond   style='font-family:Wingdings'>
                                                              value);
                          }
                      }
                  }

                  public int RequestQueueLimit
                  {
                      get { return(requestQueueLimit); }
                      set { requestQueueLimit = (value &lt; 0 ? DEFAULT_REQUEST_QUEUE_LIMIT : value);
                  }

                  public int AvailableThreads
                  {
                      get { return(maxThreadCount - currentThreadCount); }
                  }

                  public int MaxThreads
                  {
                      get { return(maxThreadCount); }

                      set
                      {
                          if( value &lt; initialThreadCount )
                          {
                              throw new ArgumentException(&quot;Maximum thread count must be  style='font-family:Wingdings'>
                                                          &gt;= initial thread count.&quot;,  style='font-family:Wingdings'>
                                                          &quot;MaxThreads&quot;);
                          }
                          maxThreadCount = value;
                      }
                  }

                  public bool IsStarted
                  {
                      get { return(hasBeenStarted); }
                  }

                  public bool PropogateThreadPrincipal
                  {
                      get { return(propogateThreadPrincipal); }
                      set { propogateThreadPrincipal = value; }
                  }

                  public bool PropogateCallContext
                  {
                      get { return(propogateCallContext); }
                      set { propogateCallContext = value; }
                  }

                  public bool PropogateHttpContext
                  {
                      get { return(propogateHttpContext); }
                      set { propogateHttpContext = value; }
                  }

                  public bool PropogateCASMarkers
                  {
                      get { return(propogateCASMarkers); }

                      // When CompressedStack get/set is opened up,
                      // add the following setter back in.
                      //
                      // set { propogateCASMarkers = value; }
                  }

                  public bool IsBackground
                  {
                      get { return(useBackgroundThreads); }

                      set
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Cannot adjust background  style='font-family:Wingdings'>
                                                      status after pool has been started.&quot;);
                          }

                          useBackgroundThreads = value;
                      }
                  }
                  #endregion                  #region ThreadPool events
                  public event ThreadPoolDelegate Started;
                  public event ThreadPoolDelegate Stopped;
                  #endregion                  public void Start()
                  {
                      lock( this )
                      {
                          if( hasBeenStarted )
                          {
                              throw new InvalidOperationException(&quot;Pool has already  style='font-family:Wingdings'> been started.&quot;);
                          }

                          hasBeenStarted = true;

            </Element>
            <Element Type="Text">

              <p>
                Next, we have to check to see if there
                were already items posted to the queue before <code>Start</code> was
                called.  If this is the case, we’ll reset their timestamps to the current time.
              </p>

            </Element>
            <Element Type="Listing">

                          if( requestQueue.Count &gt; 0 )
                          {
                              ResetWorkRequestTimes();
                          }

                          for( int n = 0; n &lt; initialThreadCount; n++ )
                          {
                              ThreadWrapper thread = style='font-family:Wingdings'>
                                  new ThreadWrapper( this, true, threadPriority,  style='font-family:Wingdings'>
                                                 string.Format(&quot;{0} (static)&quot;, threadPoolName) );
                              thread.Start();
                          }

                          if( Started != null )
                          {
                              Started();
                          }
                      }
                  }
            </Element>
            <Element Type="Text">

              <p>
                The <code>Stop</code> method
                can be used to stop the whole pool immediately. The <code>StopAndWait</code> method lets all threads run until they end normally and then stops
                the pool. The overloaded version defines a timeout to prevent the method
                blocking due to threads held in a deadlock.
              </p>

            </Element>
            <Element Type="Listing">

                  public void Stop()
                  {
                      InternalStop(false, Timeout.Infinite);
                  }

                  public void StopAndWait()
                  {
                      InternalStop(true, Timeout.Infinite);
                  }

                  public bool StopAndWait( int timeout )
                  {
                      return InternalStop(true, timeout);
                  }

            </Element>
            <Element Type="Text">

              <p>
                <code>InternalStop</code> is the method that
                completes the order. After checking that there is something to stop we set the
                property that exposes the stopping process. <code>Monitor.PulseAll</code> informs all threads that the state of the object has changed.
              </p>

              <p>
                If the wait option is set, the thread is
                waiting using <code>WaitOne</code>. This method is defined in the
                base class <code>WaitHandle</code>.
              </p>

            </Element>
            <Element Type="Listing">

                  private bool InternalStop( bool wait, int timeout )
                  {
                      if( !hasBeenStarted )
                      {
                          throw new InvalidOperationException(&quot;Cannot stop a thread pool style='font-family:Wingdings'> that has not been started yet.&quot;);
                      }

                      lock(this)
                      {
                          stopInProgress = true;
                          Monitor.PulseAll(this);
                      }

                      if( wait )
                      {
                          bool stopComplete = WaitOne(timeout, true);

                          if( stopComplete )
                          {
                              hasBeenStarted = false;
                              stopInProgress = false;
                              requestQueue.Clear();
                              stopCompleteEvent.Reset();
                          }

                          return(stopComplete);
                      }

                      return(true);
                  }

                  #endregion                  #region ThreadPool.PostRequest(early bound)

                  // Overloads for the early bound WorkRequestDelegate-based targets.
                  //
                  public bool PostRequest( WorkRequestDelegate cb )
                  {
                      return PostRequest(cb, (object)null);
                  }

                  public bool PostRequest( WorkRequestDelegate cb, object state )
                  {
                      IWorkRequest notUsed;
                      return PostRequest(cb, state, out notUsed);
                  }

                  public bool PostRequest( WorkRequestDelegate cb, object state,  style='font-family:Wingdings'>
                                           out IWorkRequest reqStatus )
                  {
                      WorkRequest request =
                          new WorkRequest( cb, state,
                                           propogateThreadPrincipal, propogateCallContext,
                                           propogateHttpContext, propogateCASMarkers );
                      reqStatus = request;
                      return PostRequest(request);
                  }

                  #endregion                  #region ThreadPool.PostRequest(late bound)

                  // Overloads for the late bound Delegate.DynamicInvoke-based targets.
                  //
                  public bool PostRequest( Delegate cb, object[] args )
                  {
                      IWorkRequest notUsed;
                      return PostRequest(cb, args, out notUsed);
                  }
               
                 public bool PostRequest( Delegate cb, object[] args, out IWorkRequest reqStatus )
                  {
                      WorkRequest request =
                          new WorkRequest( cb, args,
                                          propogateThreadPrincipal, propogateCallContext,
                                          propogateHttpContext, propogateCASMarkers );
                      reqStatus = request;
                      return PostRequest(request);
                  }

                  #endregion                  // The actual implementation of PostRequest.
                  //
                  bool PostRequest( WorkRequest request )
                  {
                      lock(this)
                      {

            </Element>
            <Element Type="Text">

              <p>
                A <code>requestQueueLimit</code> of -1 means the queue is “unbounded" and that there is no explicit
                limit on the maximum number of requests allowed in the queue.
              </p>

            </Element>
            <Element Type="Listing">

                          if( (requestQueueLimit == -1) ||  style='font-family:Wingdings'>
                              (requestQueue.Count &lt; requestQueueLimit) )
                          {
                              try
                              {
                                  requestQueue.Enqueue(request);
                                  Monitor.Pulse(this);
                                  return(true);
                              }
                              catch
                              {
                              }
                          }
                      }

                      return(false);
                  }

                  void ResetWorkRequestTimes()
                  {
                      lock( this )
                      {
                          DateTime newTime = DateTime.Now;
                          foreach( WorkRequest wr in requestQueue )
                          {
                              wr.workingTime = newTime;
                          }
                      }
                  }
            </Element>
            <Element Type="Text">

              <p>
                The class comes with few default
                parameters. The time values are provided in milliseconds. The constant
                <code>DEFAULT_DYNAMIC_THREAD_DECAY_TIME</code> is set to five minutes.
              </p>
            </Element>
            <Element Type="Listing">
                  const int DEFAULT_DYNAMIC_THREAD_DECAY_TIME = 5  60  1000;
                  const int DEFAULT_NEW_THREAD_TRIGGER_TIME = 500;
                  const ThreadPriority DEFAULT_THREAD_PRIORITY = ThreadPriority.Normal;
                  const int DEFAULT_REQUEST_QUEUE_LIMIT = -1; // unbounded
                  #endregion                  #region Private ThreadPool member variables                  private bool                hasBeenStarted = false;
                  private bool                stopInProgress = false;
                  private readonly string     threadPoolName;
                  private readonly int        initialThreadCount;     // Initial # of threads to create (called &quot;static threads&quot; in this class).
                  private int                 maxThreadCount;         // Cap for thread count.  Threads added above initialThreadCount are called &quot;dynamic&quot; threads.
                  private int                 currentThreadCount = 0; // Current # of threads in the pool (static + dynamic).
                  private int                 decayTime;              // If a dynamic thread is idle for this period of time w/o processing work requests, it will exit.
                  private TimeSpan            newThreadTrigger;       // If a work request sits in the queue this long before being processed, a new thread will be added to queue up to the max.
                  private ThreadPriority      threadPriority;
                  private ManualResetEvent    stopCompleteEvent = new ManualResetEvent(false); // Signaled after Stop called and last thread exits.
                  private Queue               requestQueue;
                  private int                 requestQueueLimit;      // Throttle for maximum # of work requests that can be added.
                  private bool                useBackgroundThreads = true;
                  private bool                propogateThreadPrincipal = false;
                  private bool                propogateCallContext = false;
                  private bool                propogateHttpContext = false;
                  private bool                propogateCASMarkers = false;

            </Element>
            <Element Type="Listing" Name="Private embedded class that holds thread information">

                  class ThreadInfo
                  {
                      public static ThreadInfo Capture( bool propogateThreadPrincipal, bool propogateCallContext,
                                                        bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          return new ThreadInfo( propogateThreadPrincipal, propogateCallContext,
                                                 propogateHttpContext, propogateCASMarkers );
                      }

                      public static ThreadInfo Impersonate( ThreadInfo ti )
                      {
                          if( ti == null ) throw new ArgumentNullException(&quot;ti&quot;);

                          ThreadInfo prevInfo = Capture(true, true, true, true);
                          Restore(ti);
                          return(prevInfo);
                      }

                      public static void Restore( ThreadInfo ti )
                      {
                          if( ti == null ) throw new ArgumentNullException(&quot;ti&quot;);
                          if( miSetLogicalCallContext != null )
                          {
                             miSetLogicalCallContext.Invoke(Thread.CurrentThread, style='font-family:Wingdings'> new object[]{ti.callContext});
                          }

            </Element>
            <Element Type="Text">

              <p>
                Restore <code>HttpContext</code> assigns
                the stored context as current one.
              </p>

            </Element>
            <Element Type="Listing">

                         CallContext.SetData(HttpContextSlotName, ti.httpContext);

            </Element>
            <Element Type="Text">

              <p>
                The thread identity is restored.  It's
                important that this is done after restoring call context, since restoring call
                context also overwrites the current thread principal setting. If <code>
                  propogateCallContext
                </code> and <code>
                  propogateThreadPrincipal
                </code> are both true, then the following is redundant. However, since propagating
                call context requires the use of reflection to capture and restore call
                context, the author wanted that behavior to be independently switchable so that
                it could be disabled. The thread principal
                12.0pt'> is still allowed to be propagated.
                In the event that call context  12.0pt'> propagation changes it no longer propagates the
                thread principal.
              </p>
            </Element>
            <Element Type="Listing">

                          Thread.CurrentPrincipal = ti.principal;
                      }

                      private ThreadInfo( bool propogateThreadPrincipal,  style='font-family:Wingdings'>
                                          bool propogateCallContext,  style='font-family:Wingdings'>
                                          bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          if( propogateThreadPrincipal )
                          {
                              principal = Thread.CurrentPrincipal;
                          }

                          if( propogateHttpContext )
                          {
                              httpContext = HttpContext.Current;
                          }

                          if( propogateCallContext &amp;&amp; (miGetLogicalCallContext != null) )
                          {
                              callContext = style='font-family:Wingdings'>
                                       (LogicalCallContext)miGetLogicalCallContext.Invoke(style='font-family:Wingdings'>
                                                           Thread.CurrentThread, null);
                              callContext = (LogicalCallContext)callContext.Clone();
                          }
                      }

                      IPrincipal principal;
                      LogicalCallContext callContext;
                      HttpContext httpContext;

                      // Cached type information.
                      //
                      const BindingFlags bfNonPublicInstance = BindingFlags.Instance | BindingFlags.NonPublic;
                      const BindingFlags bfNonPublicStatic = BindingFlags.Static | BindingFlags.NonPublic;

                      static MethodInfo miGetLogicalCallContext =
                              typeof(Thread).GetMethod(&quot;GetLogicalCallContext&quot;, bfNonPublicInstance);

                      static MethodInfo miSetLogicalCallContext =
                              typeof(Thread).GetMethod(&quot;SetLogicalCallContext&quot;, bfNonPublicInstance);

                      static string HttpContextSlotName;

                      static ThreadInfo()
                      {
            </Element>
            <Element Type="Text">
              <p>
                Look up the value of <code>HttpContext.CallContextSlotName</code>—if it exists—
                to find the name of the call context slot where <code>HttpContext.Current</code>
                is stored. If this field isn’t present, try for the original “HttpContext"
                slot name.
              </p>
              <pre>
                            FieldInfo fi = typeof(HttpContext).GetField(&quot;CallContextSlotName&quot;, bfNonPublicStatic);
                            if( fi != null )
                            {
                                HttpContextSlotName = (string)fi.GetValue(null);
                            }
                            else
                            {
                                HttpContextSlotName = &quot;HttpContext&quot;;
                            }
                        }
                    }
              </pre>
            </Element>
            <Element Type="Listing" Name="Implementation of the base interface to handle the incoming requests">

                  class WorkRequest : IWorkRequest
                  {
                      internal const int PENDING = 0;
                      internal const int PROCESSED = 1;
                      internal const int CANCELLED = 2;

                      public WorkRequest( WorkRequestDelegate cb, object arg,  style='font-family:Wingdings'>
                                          bool propogateThreadPrincipal,  style='font-family:Wingdings'>
                                          bool propogateCallContext,  style='font-family:Wingdings'>
                                          bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          targetProc = cb;
                          procArg = arg;
                          procArgs = null;

                          Initialize( propogateThreadPrincipal, propogateCallContext,
                                      propogateHttpContext, propogateCASMarkers );
                      }

                      public WorkRequest( Delegate cb, object[] args,  style='font-family:Wingdings'>
                                          bool propogateThreadPrincipal,  style='font-family:Wingdings'>
                                          bool propogateCallContext,  style='font-family:Wingdings'>
                                          bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          targetProc = cb;
                          procArg = null;
                          procArgs = args;

                          Initialize( propogateThreadPrincipal, propogateCallContext,
                                      propogateHttpContext, propogateCASMarkers );
                      }

                      void Initialize( bool propogateThreadPrincipal, bool propogateCallContext,
                                       bool propogateHttpContext, bool propogateCASMarkers )
                      {
                          workingTime = timeStampStarted = DateTime.Now;
                          threadInfo = ThreadInfo.Capture( propogateThreadPrincipal, propogateCallContext,
                                                           propogateHttpContext, propogateCASMarkers );
                      }

                      public bool Cancel()
                      {

            </Element>
            <Element Type="Text">
              <p>
                If the work request was pending, it’s
                marked as cancelled. Otherwise, this method was called too late. Note that this
                call can cancel an operation without any race conditions.  But if the result of
                this test-and-set indicates the request is in the “processed" state, it might
                actually be about to be processed.
              </p>
              <pre>
                           return(Interlocked.CompareExchange(ref state, CANCELLED, PENDING) == PENDING);
                        }

                        internal Delegate      targetProc;         // Function to call.
                        internal object        procArg;            // State to pass to function.
                        internal object[]      procArgs;           // Used with Delegate.DynamicInvoke.
                        internal DateTime      timeStampStarted;   // Time work request was originally enqueued (held constant).
                        internal DateTime      workingTime;        // Current timestamp used for triggering new threads (moving target).
                        internal ThreadInfo    threadInfo;         // Everything we know about a thread.
                        internal int           state = PENDING;    // The state of this particular request.
                    }
              </pre>
            </Element>
            <Element Type="Listing" Name="An internal wrapper class around the pool">

                  class ThreadWrapper
                  {
                      ThreadPool      pool;
                      bool            isPermanent;
                      ThreadPriority  priority;
                      string          name;

                      public ThreadWrapper( ThreadPool pool, bool isPermanent,
                                            ThreadPriority priority, string name )
                      {
                          this.pool = pool;
                          this.isPermanent = isPermanent;
                          this.priority = priority;
                          this.name = name;

                          lock( pool )
                          {
                              // Update the total # of threads in the pool.
                              //
                              pool.currentThreadCount++;
                          }
                      }

                      public void Start()
                      {
                          Thread t = new Thread(new ThreadStart(ThreadProc));
                          t.ApartmentState = ApartmentState.MTA;
                          t.Name = name;
                          t.Priority = priority;
                          t.IsBackground = pool.useBackgroundThreads;
                          t.Start();
                      }

                      void ThreadProc()
                      {
                          bool done = false;
                          while( !done )
                          {
                              WorkRequest wr = null;
                              ThreadWrapper newThread = null;
                              lock( pool )
                              {

            </Element>
            <Element Type="Text">
              <p>
                As long as the request queue is empty
                and a shutdown hasn’t been initiated, wait for a new work request to arrive.
              </p>
              <pre>
                                    bool timedOut = false;

                                    while( !pool.stopInProgress &amp;&amp; !timedOut &amp;&amp; (pool.requestQueue.Count == 0) )
                                    {
                                        if( !Monitor.Wait(pool, (isPermanent ? Timeout.Infinite : pool.decayTime)) )
                                        {
              </pre>
              <p>
                Timed out waiting for something to do. 
                Only dynamically created threads will reach this point, so bail out.
              </p>
              <pre>

                                           //
                                            timedOut = true;
                                        }
                                    }

              </pre>
              <p>
                The loop above exited because one of the
                following conditions was met:
              </p>
              <ul>
                <li>  ThreadPool.Stop was called to initiate a shutdown.</li>
                <li>  A dynamic thread timed out waiting for a work request to arrive.</li>

                <li>  There were items in the work queue to process.</li>
              </ul>
              <p>
                If the loop exited because there was work
                to be done, this means that a shutdown hadn’t been initiated, and the code wasn’t
                running in a dynamic thread that timed out. Pull the request off the queue and
                prepare to 12.0pt'> process it:
              </p>
              <pre>

                                    if( !pool.stopInProgress &amp;&amp;  style='font-family: Wingdings'>
                                        !timedOut &amp;&amp; (pool.requestQueue.Count &gt; 0) )
                                    {
                                        wr = (WorkRequest)pool.requestQueue.Dequeue();
                                        Debug.Assert(wr != null);
              </pre>
              <p>
                Check whether this work request
                languished in the queue too long.  If it was in the queue longer than the new
                thread trigger time, and if it hadn’t reached the max thread count cap, add a
                new thread to the pool.
              </p>
              <p>
                If that was the case, create the
                new thread object and update12.0pt'> the current number of threads in the pool, but defer starting the
                new thread until the lock is released.
              </p>
              <pre>
                                        TimeSpan requestTimeInQ =
                                                    DateTime.Now.Subtract(wr.workingTime);

                                        if( (requestTimeInQ &gt;= pool.newThreadTrigger) &amp;&amp;
                                            (pool.currentThreadCount &lt; pool.maxThreadCount) )
                                        {

              </pre>
              <p>
                Note that the constructor for <code>ThreadWrapper</code> will update <code>pool.currentThreadCount</code>.
              </p>
              <pre>

                                            newThread =
                                                new ThreadWrapper( pool, false, priority,
                                                                  string.Format(&quot;{0} (dynamic)&quot;,
                                                                  pool.threadPoolName) );

              </pre>

              <p>
                Since the current request we just
                dequeued is stale, everything else behind it in the queue is also stale.
                Therefore, reset the timestamps of the remaining pending work requests so that
                we don’t start creating threads for every subsequent request.
              </p>

              <pre>

                                           pool.ResetWorkRequestTimes();
                                        }
                                    }
                                    else
                                    {

              </pre>

              <p>
                Code flow should only reach this point if
                this is a dynamic thread that 12.0pt'> timed out waiting for a work request, or if the pool is shutting
                down.
              </p>

              <pre>

                                        pool.currentThreadCount--;
                                        if( pool.currentThreadCount == 0 )
                                        {
              </pre>
              <p>
                If there is no thread running in the
                pool, the pool stops and this is signaled.
              </p>

              <pre>

                                            if( pool.Stopped != null )
                                            {
                                                pool.Stopped();
                                            }

                                            pool.stopCompleteEvent.Set();
                                        }

                                        done = true;
                                    }
                                } // lock
              </pre>
            </Element>
            <Element Type="Text">
              <p>After all this is completed, the lock is no longer required.</p>
            </Element>
            <Element Type="Listing">

                              if( !done &amp;&amp; (wr != null) )
                              {

            </Element>
            <Element Type="Text">

              <p>
                Now check to see if this request has
                been cancelled while stuck in the work queue. If the work request was pending,
                mark it processed and proceed to handle. Otherwise, the request must have been
                cancelled before we plucked it off the request queue.
              </p>

            </Element>
            <Element Type="Listing">

                                  if( Interlocked.CompareExchange(ref wr.state, style='font-family:Wingdings'>
                                       WorkRequest.PROCESSED, WorkRequest.PENDING) !=  style='font-family:Wingdings'>
                                       WorkRequest.PENDING )
                                  {
            </Element>
            <Element Type="Text">

              <p>
                The request was cancelled before flow
                could get here and we have to bail out.
              </p>

            </Element>
            <Element Type="Listing">

                                      continue;
                                  }

                                  if( newThread != null )
                                  {

            </Element>
            <Element Type="Text">

              <p>
                Add a dynamic thread to the pool just by
                starting it.
              </p>

            </Element>
            <Element Type="Listing">

                                      newThread.Start();
                                  }

            </Element>
            <Element Type="Text">

              <p>Dispatch the work request.</p>

            </Element>
            <Element Type="Listing">

                                  ThreadInfo originalThreadInfo = null;

                                  try
                                  {

            </Element>
            <Element Type="Text">

              <p>
                Impersonate as much as possible what we
                know about the thread that issued the work request.
              </p>

            </Element>
            <Element Type="Listing">

                                      originalThreadInfo = ThreadInfo.Impersonate(wr.threadInfo);
                                      WorkRequestDelegate targetProc = wr.targetProc as  style='font-family:Wingdings'>
                                                                      WorkRequestDelegate;

                                      if( targetProc != null )
                                      {
                                          targetProc(wr.procArg, wr.timeStampStarted);
                                      }
                                      else
                                      {
                                          wr.targetProc.DynamicInvoke(wr.procArgs);
                                      }
                                  }
                                  catch( Exception e )
                                  {
                                  }
                                  finally
                                  {

            </Element>
            <Element Type="Text">

              <p>Restore our worker thread's identity.</p>

            </Element>
            <Element Type="Listing">

                                     ThreadInfo.Restore(originalThreadInfo);
                                  }
                              }
                          }

            </Element>
            <Element Type="Text">

              <p>The worker thread is now exiting the pool.</p>

            </Element>
            <Element Type="Listing">

                      }
                  }

              }

            </Element>
          </Element>
          <Element Type="Section" Name="Using the Custom Thread Pool">
            Using the Custom Thread Pool
            <Element Type="Text">

              <p>
                Now that we have a custom thread pool
                implementation, it’s time to
                use it. The following example is simply an extended version of the previous
                one. Instead of using single threads, however, and risking having too many of
                them, we can use the custom thread pool and set some limitations.
              </p>

            </Element>

            <Element Type="Listing" Name="Using the thread pool">

              &lt;!-- File: AsyncPool.ashx --&gt;
              &lt;%@ WebHandler Language=&quot;C#&quot;
                  Class=&quot;Apress.Threading.HttpPipeline.AsyncHandler&quot; %&gt;

              namespace Apress.Threading.HttpPipeline
              {

                public class AsyncHandler : IHttpAsyncHandler
                {
                  static DevelopMentor.ThreadPool _threadPool;

                  static AsyncHandler()
                  {
                    _threadPool =
                      new DevelopMentor.ThreadPool(2, 25, &quot;AsyncPool&quot;);
                    _threadPool.PropogateCallContext = true;
                    _threadPool.PropogateThreadPrincipal = true;
                    _threadPool.PropogateHttpContext = true;
                    _threadPool.Start();
                  }

                  public void ProcessRequest(HttpContext ctx)
                  {
                   // not used
                  }

                  public bool IsReusable
                  {
                    get { return false;}
                  }

                  public IAsyncResult BeginProcessRequest(HttpContext ctx,
                                   AsyncCallback cb, object obj)
                  {
                    AsyncRequestState reqState =
                                   new AsyncRequestState(ctx, cb, obj);
                    _threadPool.PostRequest( new Apress.Threading.CustomThreadPool. style='font-family:Wingdings'>
                                                 WorkRequestDelegate(ProcessRequest),
                                   reqState);

                    return reqState;
                  }

                  public void EndProcessRequest(IAsyncResult ar)
                  {
                  }

                  void ProcessRequest(object state, DateTime requestTime)
                  {
                    AsyncRequestState reqState = state as AsyncRequestState;

                    // Take some time to do it
                    Thread.Sleep(2000);

                    reqState._ctx.Response.Output.Write
                                 &quot;AsyncThreadPool, {0}&quot;,
                                 AppDomain.GetCurrentThreadId);

                    // tell asp.net you are finished processing this request
                    reqState.CompleteRequest();
                  }

                }
              }

            </Element>
            <Element Type="Text">

              <p>
                In theory, this thread pool will never
                run out of threads. However, there are some limitations such as available
                memory, CPU power, and operating system restrictions. This is why the pool was
                designed: so that you can optionally specify limits. The code shown above is a
                good platform for experimenting with threads and thread pools and for monitoring
                the number of threads for your application. If you want to replace the internal
                thread pool, try out the custom pool to learn how ASP.NET requests threads and
                find out where to improve performance.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Pages">
            Asynchronous Pages
            <Element Type="Text">

              <p>
                So far, all of the examples of
                asynchronous request handling have involved building custom handlers. In
                chapter 3, I’ll cover such handlers in more detail.
              </p>

              <p>
                There may be many .aspx pages
                in your ASP.NET applications that are also good candidates for asynchronous
                execution because they perform non-CPU-bound tasks that take significant
                amounts of time. Such pages are also potential bottlenecks for the ASP.NET
                thread pool.
              </p>

              <p>
                Because pages are also managed
                by a handler, it seems easy to let pages execute asynchronously. This is
                already implemented by the framework for us and there is nothing to do but set
                a property.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Define the Right Page Handler">
            Define the Right Page Handler
            <Element Type="Text">

              <p>
                Building asynchronous pages is pretty
                simple. Begin by including an attribute in the page’s <code>@Page</code> directive:
              </p>

              <pre>
                &lt;%@ Page Async=&quot;true&quot; ... %&gt;
              </pre>

            </Element>
            <Element Type="Text">

              <p>
                Behind the scenes, this tells ASP.NET to
                implement <code>IHttpAsyncHandler</code> in the page instead of <code>IHttpHandler</code>
                used regularly. Next, call the <code>AddOnPreRenderCompleteAsync</code> method early in the page’s lifetime. For example, in
                <code>Load</code>, this is early enough. Register a <code>Begin</code> method
                and an <code>End</code> method, as shown in the following code:
              </p>
              <pre>
                AddOnPreRenderCompleteAsync (
                    new BeginEventHandler(MyBeginMethod),
                    new EndEventHandler (MyEndMethod)
                );
              </pre>
              <p>
                The page runs through its normal
                processing lifecycle until shortly after the <code>
                  PreRender
                </code>
                event fires. Then ASP.NET calls the <code>
                  Begin
                </code> method
                that you registered using <code>
                  AddOnPreRenderCompleteAsync
                </code>. The <code>Begin</code> method launches
                an asynchronous operation and returns immediately. This is a lengthy operation which
                might require more time, such as a database query or a webservice call to
                another server. At this point, the thread assigned to the request returns to
                the thread pool. Furthermore, the <code>Begin</code> method
                returns an <code>IAsyncResult</code> that allows ASP.NET to determine
                when the asynchronous operation has been completed. ASP.NET then extracts a
                thread from the thread pool and calls your <code>End</code> method.
                After <code>End</code> returns, it executes the remaining portion of the page’s lifecycle.
                This might sound confusing—getting the thread back from thread pool would again
                block the thread. But between the time <code>Begin</code>
                returns and <code>End</code> gets called, the request-processing
                thread is free to service other requests. Keep in mind that the page processing
                usually takes only a few milliseconds. The time-consuming operation in the
                asynchronous handler might run for seconds. The process of freeing the thread
                pool thread for this time allows ASP.NET to process hundreds if not thousands
                of regular pages on this very same thread. However, until <code>End</code> is called, the rendering of the current asynchronous page is
                delayed. This is the same as in the previous example. It improves the situation
                not only for one user, but for all users. In the sample code, you might look
                for the <code>IAsyncResult</code> implementation. Instead of implementing our own version, we take
                one that the Framework implements for us.
              </p>

            </Element>
            <Element Type="Image" Name="Synchronous vs. Asynchronous Page Processing">
              ASPNETEXT_Chapter_02_V1.0-Dateien/image001.gif
            </Element>
            <Element Type="Text">

              <p>
                Figure 2-12 illustrates the difference between a synchronous page and an
                asynchronous page. When a synchronous page is requested, ASP.NET assigns the
                request a thread from the thread pool and executes the page on that thread.
              </p>

              <p>
                That’s enough theory for now.
                It’s time to look at some samples to get a better appreciation of how to
                implement asynchronous pages. The two examples address two common problems:
              </p>
              <ul>
                <li>Call a database operation asynchronously</li>
                <li>
                  Call a webservice—a current exchange rate service that converts between US$ and Euro.
                </li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Data Binding">
            Asynchronous Data Binding
            <Element Type="Text">

              <p>
                It is a common task to query databases
                and data bind the results. Using asynchronous pages to perform asynchronous
                data binding seems like a perfect symbiosis. The code behind class in Listing
                2-21 shows one way to go.
              </p>

            </Element>
            <Element Type="Listing" Name="Asynchronous binding to a data source (AsyncDataBind.aspx.cs)">

              using System;
              using System.Data;
              using System.Data.SqlClient;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;
              using System.Web.Configuration;

              public partial class AsyncDataBind : System.Web.UI.Page
              {
                  private SqlConnection _connection;
                  private SqlCommand _command;
                  private SqlDataReader _reader;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                      if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          // Register async methods
                          AddOnPreRenderCompleteAsync(
                              new BeginEventHandler(BeginAsyncOperation),
                              new EndEventHandler(EndAsyncOperation)
                          );
                      }
                  }
                  IAsyncResult BeginAsyncOperation (object sender, EventArgs e,
                      AsyncCallback cb, object state)
                  {
                      string connect = WebConfigurationManager.ConnectionStrings
                         [&quot;PubsConnectionString&quot;].ConnectionString;
                      _connection = new SqlConnection(connect);
                      _connection.Open();
                      _command = new SqlCommand
                          &quot;SELECT title_id, title, price FROM titles&quot;, _connection);
                      return _command.BeginExecuteReader (cb, state);
                  }
                  void EndAsyncOperation(IAsyncResult ar)
                  {
                      _reader = _command.EndExecuteReader(ar);

                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _reader;
                      Output.DataBind();
                  }

                  public override void Dispose()
                  {
                      if (_connection != null) _connection.Close();
                      base.Dispose();
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                The <code>AsyncDataBind</code> class uses the <code>AddOnPreRenderCompleteAsync</code> pattern. In its
                <code>BeginAsyncOperation</code>
                method, it calls <code>SqlCommand.BeginExecuteReader</code> to perform an asynchronous database query. When the call is
                completed, <code>EndAsyncOperation</code> calls
                <code>SqlCommand.EndExecuteReader</code> to get a <code>SqlDataReader</code>, which it
                stores in a private field. In an event handler for the <code>PreRenderComplete</code> event, which fires after the asynchronous operation completes but
                before the page is rendered, it binds the <code>SqlDataReader</code> to the Output <code>GridView</code> control. On
                the outside, the page looks like a normal synchronous page that uses a <code>GridView</code> to render the results of a database query. On the inside, this page
                is much more scalable >because it
                doesn't tie up a thread-pool thread waiting for the query to return.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Calling Web Services Asynchronously">
            Calling Web Services Asynchronously
            <Element Type="Text">

              <p>
                Another I/O-related task
                commonly performed by ASP.NET Web pages is calling to a Web service. Since Web
                service calls can take a long time to return, pages that execute them are ideal
                candidates for asynchronous processing.
              </p>

              <p>
                Listing 2-22 shows one way to build an asynchronous
                page that calls a Web service. It uses the same <code>AddOnPreRenderCompleteAsync</code> mechanism featured in this section. The page’s <code>Begin</code> method launches an asynchronous Web service call by calling the Web
                service proxy’s asynchronous <code>Begin</code> method. The page’s
                <code>End</code> method caches in a private field a reference to the <code>DataSet</code> returned by the Web method, and the <code>
                  PreRenderComplete
                </code> handler binds the <code>DataSet</code> to a
                <code>GridView</code>. For reference, the Web method targeted by the call is shown in the
                following code:
              </p>

            </Element>
            <Element Type="Listing" Name="Calling a webservice from an ASP.NET page asynchronously">

              [WebMethod]
              public DataSet GetTitles ()
              {
                  string connect = WebConfigurationManager.ConnectionStrings
                      [&quot;PubsConnectionString&quot;].ConnectionString;
                  SqlDataAdapter adapter = new SqlDataAdapter
                      (&quot;SELECT title_id, title, price FROM titles&quot;, connect);
                  DataSet ds = new DataSet();
                  adapter.Fill(ds);
                  return ds;
              }

            </Element>
            <Element Type="Listing" Name="AsyncWSInvoke1.aspx.cs">

              using System;
              using System.Data;
              using System.Configuration;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;

              public partial class AsyncWSInvoke1 : System.Web.UI.Page
              {
                  private WS.PubsWebService _ws;
                  private DataSet _ds;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                      if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          // Register async methods
                          AddOnPreRenderCompleteAsync(
                              new BeginEventHandler(BeginAsyncOperation),
                              new EndEventHandler(EndAsyncOperation)
                          );
                      }
                  }

                  IAsyncResult BeginAsyncOperation (object sender, EventArgs e,
                      AsyncCallback cb, object state)
                  {
                      _ws = new WS.PubsWebService();
                      // Fix up URL for call to local VWD-hosted Web service
                      _ws.Url = new Uri(Request.Url, &quot;Pubs.asmx&quot;).ToString();
                      _ws.UseDefaultCredentials = true;
                      return _ws.BeginGetTitles (cb, state);
                  }

                  void EndAsyncOperation(IAsyncResult ar)
                  {
                      _ds = _ws.EndGetTitles(ar);
                  }

                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _ds;
                      Output.DataBind();
                  }

                  public override void Dispose()
                  {
                      if (_ws != null) _ws.Dispose();
                      base.Dispose();
                  }
              }

            </Element>
            <Element Type="Text">
              <p>
                This is one way to do it, but
                it’s not the only way. The Web service proxy supports two mechanisms for
                placing asynchronous calls to Web services. One is the per-method <code>Begin</code>
                and <code>End</code> . The other is the
                new <code>MethodAsync</code> methods and <code>MethodCompleted</code> events.
                Even if the Begin/End pattern seems to be easy to read and adopt, because it is
                similar to the asynchronous pattern of the page’s handler, there are a few
                advantages to using the other pattern.
              </p>

              <p>
                If a Web service has a method
                named <code>Foo</code>, then in addition to having methods named
                <code>Foo</code>, <code>BeginFoo</code>, and
                <code>EndFoo</code>, a Web service proxy includes a method named
                <code>FooAsync</code> and an event named <code>FooCompleted</code>. You can
                call <code>Foo</code> asynchronously by registering a handler for the
                <code>FooCompleted</code> event and calling <code>FooAsync</code>, like this:
              </p>
              <pre>
                proxy.FooCompleted += new FooCompletedEventHandler (OnFooCompleted);
                proxy.FooAsync (...);
                ...
                void OnFooCompleted (Object source, FooCompletedEventArgs e)
                {
                    // Called when Foo completes
                }
              </pre>
              <p>
                The asynchronous call begins
                when <code>FooAsync</code> completes, and a <code>FooCompleted</code> event
                fires then, causing your <code>FooCompleted</code> event
                handler to be called. Both the delegate wrapping the event handler (<code>FooCompletedEventHandler</code>) and the second parameter passed to it (
                <code>FooCompletedEventArgs</code>) are generated with the Web service proxy. You can access
                <code>Foo’s</code> return value through <code>FooCompletedEventArgs.Result</code>.
              </p>

              <p>
                Listing 2-24 presents a code behind
                class that calls a Web service's GetTitles method asynchronously using the
                <code>MethodAsync</code> pattern. Functionally, this page is identical to the one shown in
                Listing 2-23. Internally, it’s quite different. AsyncWSInvoke2.aspx includes a
                <code>Page</code> directive with property <code>Async</code> set to
                true. But it doesn’t call <code>AddOnPreRenderCompleteAsync</code>; it registers a handler for <code>
                  GetTitlesCompleted
                </code> events and calls <code>GetTitlesAsync</code> on the
                Web service proxy. ASP.NET still delays rendering the page until
                <code>GetTitlesAsync</code> completes. Under the hood, it uses an instance of
                <code>System.Threading.SynchronizationContext</code>
                , a class that receives notifications when the asynchronous calls
                begin and when they complete.
              </p>

            </Element>

            <Element Type="Listing" Name="AsyncWSInvoke2.aspx.cs">

              using System;
              using System.Data;
              using System.Configuration;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;

              public partial class AsyncWSInvoke2 : System.Web.UI.Page
              {
                  private WS.PubsWebService _ws;
                  private DataSet _ds;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                     if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          // Call the Web service asynchronously
                          _ws = new WS.PubsWebService();
                          _ws.GetTitlesCompleted += new
                              WS.GetTitlesCompletedEventHandler(GetTitlesCompleted);
                          _ws.Url = new Uri(Request.Url, &quot;Pubs.asmx&quot;).ToString();
                          _ws.UseDefaultCredentials = true;
                          _ws.GetTitlesAsync();
                      }
                  }

                  void GetTitlesCompleted(Object source,
                      WS.GetTitlesCompletedEventArgs e)
                  {
                      _ds = e.Result;
                  }

                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _ds;
                      Output.DataBind();
                  }

                  public override void Dispose()
                  {
                      if (_ws != null) _ws.Dispose();
                      base.Dispose();
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                There are two advantages to using <code>MethodAsync</code> rather than <code>
                  AddOnPreRenderCompleteAsync
                </code> to implement asynchronous pages. Firstly,
                <code>MethodAsync</code> supports forwarding impersonation, culture, and
                <code>HttpContext.Current</code> to the <code>
                  MethodCompleted
                </code> event
                handler. Secondly, if the page makes multiple asynchronous calls and must delay
                rendering until all calls have been completed, using
                <code>AddOnPreRenderCompleteAsync</code> requires you to compose an <code>
                  IAsyncResult
                </code>
                that remains unsignaled until all the calls are finished. This is not necessary
                in <code>MethodAsync</code>; simply place the calls, as many of them as you like, and the
                ASP.NET engine will delay the rendering phase until the final call returns.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Asynchronous Tasks">
            Asynchronous Tasks
            <Element Type="Text">

              <p>
                <code>MethodAsync</code> is a convenient way to make
                multiple asynchronous Web service calls from an asynchronous page and delay the
                rendering phase until all the calls complete. Calling a Web service is not the
                only task that requires asynchronous programming. I/O-operations can be slow, too,
                especially when the server comes under pressure.
              </p>
            </Element>
            <Element Type="Section" Name="Register Asynchronous Tasks">
              <Element Type="Text">

                <p>
                  The <code>Page</code> class
                  introduces another method of facilitating asynchronous operations:
                  <code>RegisterAsyncTask</code>. <code>
                    RegisterAsyncTask
                  </code> has several advantages.
                  In addition to <code>Begin</code> and <code>End</code> methods,
                  <code>RegisterAsyncTask</code> lets you register a timeout method that’s called if an asynchronous
                  operation takes too long to complete. You can set the timeout declaratively by
                  including an <code>AsyncTimeout</code> attribute in the page’s
                  <code>Page</code> directive. For example, to set the timeout to ten seconds:
                </p>
                <pre>
                  AsyncTimeout=&quot;10&quot;
                </pre>
                <p>
                  The second advantage is that
                  you can call <code>RegisterAsyncTask</code> several times in one
                  request to register several asynchronous operations. As with
                  <code>MethodAsync</code> and all other solutions, ASP.NET delays rendering the page until
                  all operations have been completed. Thirdly, you can use the fourth parameter
                  of <code>RegisterAsyncTask</code> to pass the state to your <code>
                    Begin
                  </code>
                  methods. Finally, <code>RegisterAsyncTask</code> forwards
                  impersonation, culture, and <code>HttpContext.Current</code> to
                  the <code>End</code> and <code>Timeout</code> methods for
                  easy and transparent access. As mentioned earlier, the same is not true of an
                  <code>End</code> method registered with <code>AddOnPreRenderCompleteAsync</code>.
                </p>

                <p>
                  In other respects, an
                  asynchronous page that relies on <code>RegisterAsyncTask</code> is similar to one that relies on <code>
                    AddOnPreRenderCompleteAsync
                  </code>. The attribute in the page directive <code>
                    Async=&quot;true&quot;
                  </code> is still required, and it still executes as normal through the
                  <code>PreRender</code> event. Listing 2-25 demonstrates <code>
                    RegisterAsyncTask
                  </code> in a short example.
                </p>

              </Element>
              <Element Type="Listing" Name="AsyncPageTask.aspx.cs">

                using System;
                using System.Web;
                using System.Web.UI;
                using System.Web.UI.WebControls;
                using System.Net;
                using System.IO;
                using System.Text;
                using System.Text.RegularExpressions;

                public partial class AsyncPageTask : System.Web.UI.Page
                {
                    private WebRequest _request;

                    protected void Page_Load(object sender, EventArgs e)
                    {
                        PageAsyncTask task = new PageAsyncTask
                            new BeginEventHandler(BeginAsyncOperation),
                            new EndEventHandler(EndAsyncOperation),
                            new EndEventHandler(TimeoutAsyncOperation),
                            null
                        );
                        RegisterAsyncTask(task);
                    }

                   IAsyncResult BeginAsyncOperation(object sender, EventArgs e,
                        AsyncCallback cb, object state)
                    {
                        _request = WebRequest.Create(&quot;http://msdn.microsoft.com&quot;);
                        return _request.BeginGetResponse(cb, state);
                    }
                    void EndAsyncOperation(IAsyncResult ar)
                    {
                        string text;
                        using (WebResponse response = _request.EndGetResponse(ar))
                        {
                            using (StreamReader reader =
                                new StreamReader(response.GetResponseStream()))
                            {
                                text = reader.ReadToEnd();
                            }
                        }

                        Regex regex = new Regex(&quot;href\\s=\\s\&quot;([^\&quot;])\&quot;&quot;,
                            RegexOptions.IgnoreCase);
                        MatchCollection matches = regex.Matches(text);

                        StringBuilder builder = new StringBuilder(1024);
                        foreach (Match match in matches)
                        {
                            builder.Append(match.Groups[1]);
                            builder.Append(&quot;&lt;br/&gt;&quot;);
                        }
                        Output.Text = builder.ToString();
                    }

                    void TimeoutAsyncOperation(IAsyncResult ar)
                    {
                        Output.Text = &quot;Data temporarily unavailable&quot;;
                    }
                }

              </Element>
              <Element Type="Text">

                <p>
                  The primary advantage of <code>RegisterAsyncTask</code> is that it allows asynchronous pages to fire off multiple
                  asynchronous calls and delays rendering until all the calls have been completed.
                  It works equally well for one asynchronous call, and it offers a timeout option
                  that <code>AddOnPreRenderCompleteAsync</code>
                  does not provide. If you build an asynchronous page which makes
                  just one asynchronous call, you can use <code>AddOnPreRenderCompleteAsync</code> or
                  <code>RegisterAsyncTask</code>. But for asynchronous
                  pages that place two or more such calls, <code>RegisterAsyncTask</code> simplifies your life considerably.
                </p>

              </Element>
              <Element Type="Section" Name="Setting Properties">
                Setting Properties
                <Element Type="Text">

                  <p>
                    There are a number of relevant properties
                    that can be set programmatically. (It was not possible to demonstrate all
                    aspects in the sample code.) Please refer to the documentation to see what else
                    is possible and how to modify its behavior. The intention of this chapter is to
                    show ways to improve the overall performance of a web server through
                    understanding the basics of thread pooling and request handling.
                  </p>

                </Element>
              </Element>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Summary">
        Summary
        <Element Type="Text">
          <p>
            In this chapter you got in-depth
            information about the internal request processing and how to tweak the worker
            process and the threading. You got an idea how the thread pool works and how to
            extend the behavior. Using asynchronous process might increase performance and
            handle high workload. A custom thread pool was introduced to demonstrate how to
            change internal parts of the processing pipeline transparently. In a anticipation
            to Chapter 3 you got a first look into asynchronous handlers and there usage.
          </p>
        </Element>
      </Element>
    </Element>
    <Element Type="Section" Name = "Modules and Handlers" >
      Modules and Handlers
      <Element Type="Text">
        <p>
          In this chapter, we will look more
          closely at the extensibility of ASP.NET through the addition of custom modules
          and handlers. Handlers and modules are integrated into IIS so that your web
          applications can perform and scale well. In the previous chapter, you learned
          how to use asynchronous handlers to handle custom threads. Here, we’ll learn
          more about how ASP.NET can be extended using handlers. The objectives of this
          chapter are:
        </p>
        <ul>
          <li>Learn what internal modules are for</li>
          <li>Find out how to create, activate, and debug custom modules</li>
          <li>Discover the handlers included in ASP.NET</li>
          <li>Extend, customize, and replace handlers</li>
          <li>Write your own handlers with both synchronous and asynchronous behavior</li>
        </ul>
      </Element>
      <Element Type="Section" Name="Module, handlers and IIS">
        Module, handlers and IIS
        <Element Type="Text">

          <p>
            IIS7 Web server features fit into one
            of two categories:
          </p>
          <ul>
            <li>Modules</li>
            <li>Handlers</li>
          </ul>
          <p>
            Similar to the <i>ISAPI filter</i>
            in previous IIS versions, a module participates in the processing of each request.
            Its role is to change or add content to the request. Examples of some out-of-the-box
            modules in IIS7 include authentication modules, compression modules, and
            logging modules. The names indicate the function of each module.
          </p>

          <p>
            A module is a .NET class that implements
            the <code>System.Web.IHttpModule</code> interface and uses APIs in the <code>
              System.Web
            </code>
            namespace to participate in one or more of ASP.NET’s request processing stages.
            I explained the stages of this ‘pipeline’ in chapter 1.
          </p>

          <p>
            By contrast, a handler,
            similar to the <i>ISAPI extension</i> in previous IIS versions, is responsible
            for handling requests and creating responses for specific content types. The
            main difference between modules and handlers is that handlers are typically
            mapped to a particular request path or extension. They also support the
            processing of a specific resource to which that path or extension corresponds. Handlers
            provided with IIS7 include ASP.NET’s <code>
              PageHandlerFactory
            </code>, which processes .aspx pages, among others. This kind of a handler
            is a .NET class that implements the ASP.NET <code>
              System.Web.IHttpHandler
            </code> or <code>
              System.Web.IHttpAsyncHandler
            </code> interface.
            It uses APIs in the <code>
              System.Web
            </code> namespace to
            produce an HTTP response for the specific content it creates.
          </p>

          <p>
            When developing an IIS7
            feature or ASP.NET extension, you’ll need to decide whether a module or a
            handler is appropriate. No common task requires both. If your feature is
            responsible for serving requests to a specific URL or file extension, like
            *.png, then a handler is the right choice as handlers are primarily for
            specific tasks. Alternatively, if you want to respond to some or all requests,
            a module is appropriate.
          </p>

          <p>
            Creating images on the fly corresponds
            to a specific file type—use a handler to achieve this. Adding footers to all
            your pages from one location is a good idea—implement a module to do that.
          </p>

        </Element>
      </Element>
      <Element Type="Section" Name="Modules">
        Modules
        <Element Type="Text">
          <p>
            This section explains how to create
            internal modules and gives some examples that you can use in your own
            applications.
          </p>

        </Element>
        <Element Type="Section" Name="IIS7 Architecture">
          IIS7 Architecture
          <Element Type="Text">

            <p>
              ASP.NET is tightly integrated with
              IIS7. Even though it’s possible to run ASP.NET with any host, thanks to its modular
              architecture, you should keep in mind that IIS is the best platform “by
              design". Extending and customizing ASP.NET is only possible with a good
              understanding of IIS and its parts.
            </p>

            <p>
              Microsoft changed large parts
              of the architecture of IIS7 compared to previous versions. One of the major changes
              was the greatly enhanced extensibility. Instead of a powerful but monolithic
              Web server, with IIS7 there is now a Web server engine to which you can add or
              remove components. These components are called modules.
            </p>

            <p>
              Modules build the features offered
              by the Web server. All modules have one primary task—processing a request. This
              can become complicated, however, as a request isn’t just a call to static
              resources. Consider requests involving the authentication of client
              credentials, compression and decompression, or cache management.
            </p>

            <p>
              Assuming that IIS7 is the
              primary platform for running ASP.NET, any discussion about extensibility does
              not make sense without understanding what accompanies IIS7. IIS7 comes with two
              module types:
            </p>
            <ul>
              <li>Native Modules</li>
              <li>Managed Modules</li>
            </ul>

          </Element>
          <Element Type="Section" Name="Native Modules">
            Native Modules
            <Element Type="Text">

              <p>
                Native modules perform all the basic
                tasks of a Web server. However, not all modules manage common requests. It
                depends on your installation and configuration as to whether a module is
                available and running. Inside IIS7 are:
              </p>
              <ul>
                <li>HTTP Modules</li>
                <li>Security Modules</li>
                <li>Content Modules</li>
                <li>Compression Modules</li>
                <li>Caching Modules</li>
                <li>Logging and Diagnosing Modules</li>
                <li>Integration of Managed Modules</li>
              </ul>
              <p>
                You can find all modules—apart from
                those whose full path is given below—in the following directory:
              </p>

              <p class="Query">%WinDir%\System32\InetSrv</p>

              <p>
                The HTTP modules perform tasks specific
                to Hypertext Transfer Protocol.
              </p>
            </Element>
            <Element Type="table" Name="HTTP Modules">
              <table>
                <tr>
                  <th>Module Name</th>
                  <th>DLL</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>

                      CustomErrorModule
                    </code>
                  </td>
                  <td>Custerr.dll</td>
                  <td>
                    Sends
                    default and configured HTTP error messages when an error status code is set on
                    a response.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>
                      HttpRedirectionModule
                    </code>
                  </td>
                  <td>Redirect.dll</td>
                  <td>
                    Supports
                    configurable redirection for HTTP requests.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>ProtocolSupportModule</code>
                  </td>
                  <td>Protsup.dll</td>
                  <td>
                    Performs protocol-related actions, such as
                    setting response headers and redirecting headers based on configuration.
                  </td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">

              <p>
                Security is essential for a Web server,
                as shown by the number of modules in this section.
              </p>

            </Element>
            <Element Type="table" Name="Security Modules">
              <table>
                <tr>
                  <th>Module Name</th>
                  <th>DLL</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>

                      AnonymousAuthenticationModule
                    </code>
                  </td>
                  <td>Authanon.dll</td>
                  <td>
                    Performs
                    anonymous authentication when no other authentication method succeeds.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      BasicAuthenticationModule
                    </code>
                  </td>
                  <td>Authbas.dll</td>
                  <td>Performs Basic authentication.</td>
                </tr>
                <tr>
                  <td>
                    <code>

                      CertificateMappingAuthenticationModule
                    </code>
                  </td>
                  <td>Authcert.dll</td>
                  <td>
                    Performs
                    Certificate Mapping authentication using Active Directory.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      DigestAuthenticationModule
                    </code>
                  </td>
                  <td>Authmd5.dll</td>
                  <td>
                    Performs
                    Digest authentication.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      IISCertificateMappingAuthenticationModule
                    </code>
                  </td>
                  <td>Authmap.dll</td>
                  <td>
                    Performs Certificate Mapping
                    authentication using IIS certificate configuration.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      RequestFilteringModule
                    </code>
                  </td>
                  <td>Modrqflt.dll</td>
                  <td>
                    Performs
                    URLScan tasks such as configuring allowed verbs and file extensions, setting
                    limits, and scanning for bad character sequences.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      UrlAuthorizationModule
                    </code>
                  </td>
                  <td>Urlauthz.dll</td>
                  <td>
                    Performs
                    URL authorization.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      WindowsAuthenticationModule
                    </code>
                  </td>
                  <td>Authsspi.dll</td>
                  <td>
                    Performs
                    NTLM integrated authentication.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>IpRestrictionModule</code>
                  </td>
                  <td>iprestr.dll</td>
                  <td>
                    Restricts IPv4 addresses listed in the IpSecurity
                    list in configuration.
                  </td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">

              <p>
                Once the request is accepted and
                authorized, the requested resources must be handled. Several modules perform these
                specific tasks.
              </p>

            </Element>
            <Element Type="table" Name="Content Modules">
              <table>
                <tr>
                  <th>Module Name</th>
                  <th>DLL</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>

                      CgiModule
                    </code>
                  </td>
                  <td>Cgi.dll</td>
                  <td>
                    Executes
                    Common Gateway Interface (CGI) processes to build response output.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      DefaultDocumentModule
                    </code>
                  </td>
                  <td>Defdoc.dll</td>
                  <td>
                    Attempts
                    to return a default document for requests made to the parent directory.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      DirectoryListingModule
                    </code>
                  </td>
                  <td>dirlist.dll</td>
                  <td>
                    Lists
                    the contents of a directory.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      IsapiModule
                    </code>
                  </td>
                  <td>Isapi.dll</td>
                  <td>
                    Hosts ISAPI
                    extension DLLs.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      IsapiFilterModule
                    </code>
                  </td>
                  <td>Filter.dll</td>
                  <td>
                    Supports
                    ISAPI filter DLLs.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      ServerSideIncludeModule
                    </code>
                  </td>
                  <td>Iis_ssi.dll</td>
                  <td>
                    Processes
                    server-side includes code.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      StaticFileModule
                    </code>
                  </td>
                  <td>Static.dll</td>
                  <td>
                    Serves
                    static files.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>FastCgiModule</code>
                  </td>
                  <td>iisfcgi.dll</td>
                  <td>
                    Supports FastCGI, which provides a high-performance
                    alternative to CGI.
                  </td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">
              <p>
                Compression is a common way to save
                bandwidth and transfer large files more efficiently.
              </p>

            </Element>
            <Element Type="table" Name="Compression Modules">
              <table>
                <tr>
                  <th>Module Name</th>
                  <th>DLL</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>

                      DynamicCompressionModule
                    </code>
                  </td>
                  <td>Compdyn.dll</td>
                  <td>
                    Compresses
                    responses using <i>gzip</i> compression transfer coding on-the-fly.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>StaticCompressionModule</code>
                  </td>
                  <td>Compstat.dll</td>
                  <td>
                    Performs pre-compression of static
                    content.
                  </td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">
              <p>
                Caching is another way to improve
                performance. Several modules store files so that the delivery process is either
                accelerated or eliminated altogether.
              </p>

            </Element>
            <Element Type="table" Name="Caching Modules">
              <table>
                <tr>
                  <th>Module Name</th>
                  <th>DLL</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>

                      FileCacheModule
                    </code>
                  </td>
                  <td>Cachfile.dll</td>
                  <td>
                    Provides
                    user mode caching for files and file handles.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      HTTPCacheModule
                    </code>
                  </td>
                  <td>Cachhttp.dll</td>
                  <td>
                    Provides
                    kernel mode and user mode caching in HTTP.sys.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      TokenCacheModule
                    </code>
                  </td>
                  <td>Cachtokn.dll</td>
                  <td>
                    Provides
                    user mode caching of user name and token pairs for modules that produce Windows
                    user principals.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>UriCacheModule</code>
                  </td>
                  <td>Cachuri.dll</td>
                  <td>Provides user mode caching of URL information.</td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">

              <p>
                Knowing what is happening is essential
                for Web server administrators. There are several steps from the code on your
                server—where you probably have debug capabilities—to the browser, where you might
                miss seeing the desired output. Even production systems do not always behave as
                expected. Logging and diagnostic modules help you understand the internal
                processing of requests and responses.
              </p>

            </Element>
            <Element Type="table" Name="Table 3-6. Logging and Diagnostic Modules">
              <table>
                <tr>
                  <th>Module Name</th>
                  <th>DLL</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>

                      CustomLoggingModule
                    </code>
                  </td>
                  <td>Logcust.dll</td>
                  <td>
                    Loads
                    custom logging modules.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      FailedRequestsTracingModule
                    </code>
                  </td>
                  <td>Iisfreb.dll</td>
                  <td>
                    Supports
                    the Failed Request Tracing feature.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>
                      HttpLoggingModule
                    </code>
                  </td>
                  <td>Loghttp.dll</td>
                  <td>
                    Passes
                    information and processing status to HTTP.sys for logging.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      RequestMonitorModule
                    </code>
                  </td>
                  <td>Iisreqs.dll</td>
                  <td>
                    Tracks
                    requests currently executing in worker processes and reports information with
                    Runtime Status and Control Application Programming Interface (RSCA).
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>TracingModule</code>
                  </td>
                  <td>Iisetw.dll</td>
                  <td>
                    Reports events to Microsoft Event Tracing
                    for Windows (ETW).
                  </td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">

              <p>
                Finally, you need an interface to the
                managed world. In chapter 1, you saw how modules interacted. The next table
                shows which modules are involved in this interaction.
              </p>
            </Element>
            <Element Type="table" Name="Integration of Managed Modules">
              <table>
                <tr>
                  <th>Module Name</th>
                  <th>DLL/Assembly</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>ManagedEngine</code>
                  </td>
                  <td>Microsoft.NET\Framework\v2.0.50727\webengine.dll</td>
                  <td>
                    Provides integration of managed code modules in the IIS request-processing
                    pipeline.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>ConfigurationValidationModule</code>
                  </td>
                  <td>
                    validcfg.dll
                  </td>
                  <td>
                    Validates configuration issues, such as when
                    an application is running in Integrated mode but has handlers or modules
                    declared in the system.web section.
                  </td>
                </tr>
              </table>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Managed Modules">
          Managed Modules
          <Element Type="Text">

            <p>
              While extending IIS7 via native modules
              is one method of writing high performance applications, for most projects, this
              is not necessary or desirable. Extending ASP.NET using managed modules has
              significant advantages in development time and reliability. IIS7 includes several
              built-in, managed modules, which show that it is possible to write low-level
              infrastructure components in managed code.
            </p>

            <p>
              You can find the definition of security
              modules in the <code>System.Web.Security</code> namespace.
            </p>

          </Element>
          <Element Type="table" Name="Managed code Security Modules shipped with IIS7">
            <table>
              <tr>
                <th>Module Name</th>
                <th>Class</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>AnonymousIdentification</td>
                <td>
                  <code>AnonymousIdentificationModule</code>
                </td>
                <td>
                  Manages anonymous identifiers, which are used by features that
                  support anonymous identification such as the ASP.NET profile.
                </td>
              </tr>
              <tr>
                <td>DefaultAuthentication</td>
                <td>
                  <code>DefaultAuthenticationModule</code>
                </td>
                <td>
                  Ensures that an authentication object is present in the
                  context.
                </td>
              </tr>
              <tr>
                <td>FileAuthorization</td>
                <td>
                  <code>FileAuthorizationModule</code>
                </td>
                <td>Verifies that a user has permission to access the requested file.</td>
              </tr>
              <tr>
                <td>FormsAuthentication</td>
                <td>
                  <code>FormsAuthenticationModule</code>
                </td>
                <td>Supports authentication using Forms authentication.</td>
              </tr>
              <tr>
                <td>RoleManager</td>
                <td>
                  <code>RoleManagerModule</code>
                </td>
                <td>Manages a RolePrincipal instance for the current user.</td>
              </tr>
              <tr>
                <td>UrlAuthorization </td>
                <td>
                  <code>UrlAuthorizationModule</code>
                </td>
                <td>
                  Determines whether the current user is permitted access to the
                  requested URL, based on the user name or membership of a suitable role.
                </td>
              </tr>
              <tr>
                <td>WindowsAuthentication</td>
                <td>
                  <code>WindowsAuthenticationModule</code>
                </td>
                <td>
                  Sets the identity of the user for an ASP.NET application when
                  Windows authentication is enabled.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">

            <p>
              The definition of the cache module is
              stored in <code>System.Web.Caching</code>. This module is declared as <code>internal</code> and is not accessible by user code.
            </p>

          </Element>
          <Element Type="table" Name="Managed code Caching Modules shipped with IIS7">
            <table>
              <tr>
                <th>Module Name</th>
                <th>Class</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>OutputCache</td>
                <td>
                  <code>OutputCacheModule</code>
                </td>
                <td>Supports output caching.</td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">

            <p>
              The module for profile handling is in the
              <code>System.Web.Profile</code> namespace.
            </p>

          </Element>
          <Element Type="table" Name="Managed code Profiles Modules shipped with IIS7">
            <table>
              <tr>
                <th>Module Name</th>
                <th>Class</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>Profile</td>
                <td>
                  <code>ProfileModule</code>
                </td>
                <td>
                  Manages user profiles by using the ASP.NET profile, which
                  stores and retrieves user settings in a data source such as a database.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">

            <p>
              For session handling modules, look into
              the <code>System.Web.SessionState</code> namespace.
            </p>

          </Element>
          <Element Type="table" Name="Managed code Session Modules shipped with IIS7">
            <table>
              <tr>
                <th>Module Name</th>
                <th>Class</th>
                <th>Description </th>
              </tr>
              <tr>
                <td>Session</td>
                <td>
                  <code>SessionStateModule</code>
                </td>
                <td>
                  Supports the maintenance of a session state, which enables the
                  storage of data specific to a single client within an application on the server.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">

            <p>
              The modules for URL handling are stored
              in the root namespace <code>
                System.Web
              </code>.
            </p>

          </Element>
          <Element Type="table" Name="Managed code URL Modules shipped with IIS7">
            <table>
              <tr>
                <th>Module Name</th>
                <th>Class</th>
                <th>Description </th>
              </tr>
              <tr>
                <td>UrlMappingsModule</td>
                <td>
                  <code>UrlMappingsModule</code>
                </td>
                <td>Supports mapping a real URL to a more user-friendly URL.</td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">

            <p>
              Given this list of modules, you might
              feel that there is no need to write custom modules to perform standard tasks. This
              is true; the developers of ASP.NET and IIS have delivered everything you need
              for common infrastructure work. However, if you’d like to program an application-specific
              task, writing your own module is an excellent way to extend ASP.NET and add
              sophisticated features of your choice.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="The IIS7 Managed Module Starter Kit">
          The IIS7 Managed Module Starter Kit
          <Element Type="Text">

            <p>
              Microsoft provides a starter kit to
              make it easy to write your first module for the new IIS7 managed API. This
              Visual Studio Content Installer contains a project template for building IIS7
              Modules using the .NET Framework.
            </p>

          </Element>
          <Element Type="Section" Name="Get the Starter Kit">
            Get the Starter Kit
            <Element Type="Text">

              <p>
                The Starter Kit is available at no cost
                from Microsoft at the www.iis.net website:
              </p>

              <p class="Query">http://www.iis.net/downloads/default.aspx?tabid=34&amp;i=1302&amp;g=6</p>

              <p>
                Click on Download, save the file and
                unzip to a current folder. The kit is a Visual Studio template installer, provided
                as a .vsi file.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name="Benefits of Module Development Kit">
            Benefits of Module Development Kit
            <Element Type="Text">

              <p>
                Since IIS7 supports development using managed
                code, it means you can program HTTP request processing in managed code. The
                entire event structure of IIS7, written in native API (C/C++), is also
                available to managed code developers.
              </p>

            </Element>

            <Element Type="Image" Name="Installing the template">
              images/19835f0301.png
            </Element>
            <Element Type="SideBar" SidebarType="Note">
              <header>Note</header>
              <aside>
                the Starter Kit
                simplifies the first steps. However, you don’t need it to run the samples
                provided in this chapter.
              </aside>
            </Element>
            <Element Type="Text">
              <p>Once the template is installed, you can add new modules by using the right item for your project. </p>
            </Element>
            <Element Type="Image" Name="Adding a new module code item to a current project">
              images/19835f0302.png
            </Element>
            <Element Type="Text">
              <ul>
                <li>This item creates a class skeleton, which looks like</li>
              </ul>

            </Element>
            <Element Type="Listing" Name="Skeleton of a module class"></Element>

            using System;
            using System.Web;
            namespace Apress.HttpModules
            {
                public class DirListModule : IHttpModule
                {
                    /// &lt;summary&gt;
                    /// You will need to configure this module in the web.config file
            /// and register it with IIS before being able to use it.
                    /// For more information
            /// see the following link: http://go.microsoft.com/?linkid=8101007
                    /// &lt;/summary&gt;
                    #region IHttpModule Members                    public void Dispose()
                    {
                        //clean-up code here.
                    }

                    public void Init(HttpApplication context)
                      {         
            // Below is an example of how you can handle LogRequest
                        // event and provide
                        // custom logging implementation for it
                        context.LogRequest += new EventHandler(OnLogRequest);
                    }

                    #endregion                    public void OnLogRequest(Object source, EventArgs e)
                    {
                        //custom logging logic can go here
                    }
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              For the sake of clarity and space, I
              will not repeat this part of the module code in the following sections when
              examining the various examples.
            </p>

          </Element>
          <Element Type="Section" Name="Building a Module">
            Building a Module
            <Element Type="Text">

              <p>
                As requests move through the pipeline,
                a number of events fire on the <code>
                  HttpApplication
                </code> object.
                As you’ve seen already, these events are published as event methods in <i>Global.asax</i>.
                This approach is application-specific, but not always ideal. If you want to
                build generic <code>
                  HttpApplication
                </code> event hooks that can be
                plugged into any Web application, you can use <code>
                  HttpModules
                </code>.
                These are reusable and require an entry in <i>web.config</i> instead of application-specific
                code.
              </p>

            </Element>
            <Element Type="Section" Name="Define the Modules">
              Define the Modules
              <Element Type="Text">
                <p>
                  Modules allow you to hook events for any
                  request that passes through the ASP.NET <code>HttpApplication</code> object. These modules are stored as classes in external assemblies configured
                  in <i>web.config</i>, which causes them to load when the application starts. By
                  implementing specific interfaces and methods, the module is hooked up to the <code>HttpApplication</code> event chain. Multiple
                  <code>HttpModules</code> can hook the same event. Their order is determined by their order of appearance
                  in <i>web.config</i>. A handler definition in <i>web.config</i>
                  looks like:
                </p>
              </Element>
              <Element Type="Listing" Name="Register a module in web.config">
                &lt;configuration&gt;
                  &lt;system.web&gt;
                    &lt;httpModules&gt;
                                  &lt;add Name= &quot;MyModule&quot; type=&quot;Apress.HttpModules.Modules,MyModule&quot; /&gt;
                    &lt;/httpModules&gt;
                  &lt;/system.web&gt;
                &lt;/configuration&gt;
              </Element>
              <Element Type="Text">
                <p>
                  Note that you need to specify both a
                  full type name and an assembly name without the DLL extension.
                </p>
                <p>
                  Modules allow you observe each
                  incoming request and perform an action based on the events that fire. Modules
                  are excellent for modifying a request or responding to particular content in
                  order to provide custom authentication or pre- or post-processing to each request
                  that arrives.
                </p>
                <p>
                  Many of ASP.NET’s features,
                  such as the Authentication and Session engines, are implemented as HTTP
                  Modules. While <code>HttpModules</code> might feel similar to <i>ISAPI Filters</i>
                  in that they examine every request that arrives through an ASP.NET
                  Application, in reality they are limited to scrutinizing requests mapped to a
                  single specific ASP.NET application or virtual directory.
                </p>
                <p>
                  You can thus inspect all .aspx
                  pages or any other custom extensions that are mapped to this application. However,
                  you cannot look at standard .html or image files unless you explicitly map the
                  extension to the ASP.NET ISAPI.dll.
                </p>
              </Element>
            </Element>
            <Element Type="Section" Name="Example—Write a Simple Authentication Module">
              Example—Write a Simple Authentication Module
              <Element Type="Text">
                <p>
                  This first example shows how to
                  intercept the authentication procedure of the request pipeline. It also
                  demonstrates how to add your own authentication module to handle tasks independently
                  of the existing code.
                </p>
                <p>
                  Implementing an HTTP Module is very easy.
                  Implement the <code>IHttpModule</code> interface, which contains
                  two methods: <code>Init</code> and <code>Dispose</code>.
                </p>
              </Element>
              <Element Type="SideBar" SidebarType="Note">
                <header>Note</header>
                <aside>
                  The Starter Kit item
                  additionally creates a <code>LogRequest</code> handler. You
                  can safely remove the handler and event assignment if you don’t need it.
                </aside>
              </Element>
              <Element Type="Text">
                <p>
                  The event parameters passed include a
                  reference to the <code>HTTPApplication</code> object,
                  which in turn gives you access to the <code>HttpContext</code>
                  object. Using the <code>Init</code> method, you can
                  hook up to <code>HttpApplication</code> events. For example, if
                  you want to hook the <code>AuthenticateRequest</code>
                  event to a module you would do so as shown in Listing 3-3.
                </p>
              </Element>
              <Element Type="Listing" Name="Simple implementation of an HTTP Module">
                public class BasicAuthCustomModule : IHttpModule
                {
                  public void Init(HttpApplication application)
                  {
                     application.AuthenticateRequest +=
                        new EventHandler(this.OnAuthenticateRequest);
                  }

                  public void Dispose() { }

                  public void OnAuthenticateRequest(object source, Even-tArgs eventArgs)
                  {
                    HttpApplication app = (HttpApplication) source;
                    HttpContext Context = HttpContext.Current;
                    // and action
                }

              </Element>
              <Element Type="Text">

                <p>
                  Remember that your Module has access to
                  the <code>HttpContext</code> object and from there to all other intrinsic ASP.NET pipeline
                  objects, such as <code>
                    Response
                  </code> and <code>Request</code>. From here, you can retrieve input, create content, and so forth. However,
                  keep in mind that certain things may not be available until further down the
                  chain.
                </p>
                <p>
                  You can hook as many events as you like
                  in the <code>Init</code> method so that your module is able to manage multiple operations with
                  different functions. It is tidier to separate differing logic into separate modules.
                  This ensures that the modules are, indeed, modular, as their name implies. In
                  many cases, any functionality that you implement could require hooking multiple
                  events. For example, a logging filter might log the start time of a request in <code>BeginRequest</code> and then write the request completion into the log in <code>EndRequest</code>.
                </p>

              </Element>
              <Element Type="SideBar" SidebarType="Warning">
                <header>Warning</header>
                <aside>
                  Modules work deep inside the
                  processing pipeline. Calling certain methods can prevent the pipeline from proceeding
                  to the next step. In particular, <code>Response.End</code>
                  and <code>Application.CompleteRequest</code> complete the request and force the pipeline to end, thus skipping
                  all subsequent steps. The pipeline will return control to the Web server and no
                  further modules will be invoked. A better practice is to leave the pipeline
                  running, but use a context variable to inform subsequent modules not to execute.
                </aside>
              </Element>
              <Element Type="Text">

                <p>
                  The purpose of the <code>Dispose</code> method is to clean up any resources when the module unloads and to
                  release other resources before the garbage collector finalizes the module
                  instance. If there is nothing to dispose, leave the method body blank.
                </p>
                <p>
                  The <code>Init</code> method
                  is the main method of interest. Here, you can initialize your module and wire it
                  up to one or more request processing events available on the <code>HttpApplication</code> class. Keep in mind that events fire when the appropriate step in
                  the pipeline is reached, in a defined order and in conjunction with other
                  modules. Without a clear understanding of the pipeline architecture explained
                  in chapter 1, you’ll have difficulty writing sophisticated modules which
                  perform well.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name="Example—Check for a Specific Header">
              Example—Check for a Specific Header
              <Element Type="Text">

                <p>
                  The following example checks for a
                  specific header, called a referrer, which provides information about the
                  referring page. The referrer is, paradoxically, named “referer". Don’t worry
                  about the misspelled word (the sidebar explains more).
                </p>

              </Element>
              <Element Type="Sidebar" SidebarType="Box">

                <header>Wikipedia on the Word, Referer</header>
                <aside>
                  <p>
                    <i>Referer</i> is
                    a common misspelling of the word <i>referrer</i>. It is so common, in fact,
                    that it made it into the official specification of HTTP – the communication
                    protocol of the World Wide Web – and has therefore become a widely used
                    industry spelling when discussing HTTP referrers. The misspelling usage is not
                    universal; the correct spelling of &quot;referrer&quot; occurs in some web
                    specifications such as the Document Object Model. [Source: http://en.wikipedia.org/wiki/Referer]
                  </p>
                  <p>I advise you to pay attention to which word you’re using! </p>
                </aside>

              </Element>
              <Element Type="Text">

                <p>
                  In this example, we’ll look for
                  a specific referrer or referring page—the URL of the previous page. (It’s the
                  page containing the link to the page we’re currently processing.) The usage of
                  the header is voluntary, according to HTTP standards, but most sites use it to
                  track users or manage logging. However, some pages are not intended to be
                  called from outside our site. If linked to from another page within our application,
                  such pages will execute correctly, but if linked to from anywhere else, we’ll treat
                  that as an exception. Such external links typically occur when a user bookmarks
                  a specific page deep within your application. When attempting to open one of
                  these pages, it is not possible, because there are several prerequisite steps
                  to be completed beforehand. Using a module like the one in Listing 3-4, you can
                  capture these requests outside the common page code and redirect users to a suitable
                  page, such as one which explains appropriate usage of bookmarks.
                </p>

              </Element>
              <Element Type="Listing" Name="An HTTP Module that looks for the Referer Header">

                public class ReferrerModule : IHttpModule
                {
                    #region IHttpModule Members                    public void Dispose()
                    {
                        //clean-up code here.
                    }

                    public void Init(HttpApplication context)
                    {
                        context.PreRequestHandlerExecute +=
                             new EventHandler(context_PreRequestHandlerExecute);
                    }
                    void context_PreRequestHandlerExecute(object sender, EventArgs e)
                    {
                        HttpApplication app = (HttpApplication)sender;
                        HttpRequest request = app.Context.Request;
                        if (!request.Url.LocalPath.EndsWith(&quot;Default.aspx&quot;))
                        {
                            if (String.IsNullOrEmpty(request.Headers[&quot;Referer&quot;]))
                            {
                                throw new HttpException(403, &quot;Bookmarking is not allowed&quot;);
                            }
                        }

                    }

                    #endregion                }

              </Element>
              <Element Type="Text">

                <p>
                  This code assumes that you have a page
                  called Default.aspx linking to another page in your application. The name of
                  the other page doesn’t matter.
                </p>
                <p>To test this module:</p>
                <ol>
                  <li>
                    1. Configure <i>web.config</i> to activate the module.
                  </li>
                  <li>2. Create two pages, Default.aspx and RefererTest.aspx. Default.aspx has a hyperlink to RefererTest.aspx.</li>
                  <li>3. Compile and start the application by launching the Default.aspx page.</li>
                  <li>4. Click the hyperlink on Default.aspx—the RefererTest.aspx page is displayed.</li>
                  <li>5. Bookmark the RefererTest.aspx page.</li>
                  <li>6. Close your browser, re-open it, and load the bookmark, then press F5 to force a refresh of the page from the server.</li>
                  <li>7. An exception occurs and the browser shows a 403 error.</li>
                </ol>
                <p>
                  You might insist that this all can be
                  accomplished on the page level using conventional code. This is correct, but fundamental
                  tasks are best handled on a fundamental level. In addition, intercepting
                  low-level events to handle low-level action is faster, more secure, and more reliable.
                  Adding more pages with the same behavior does not require any change to the
                  code. It simply works because the module tests all pages in the application.
                </p>

              </Element>

            </Element>
          </Element>
          <Element Type="Section" Name="Interaction between Modules">
            Interaction between Modules
            <Element Type="Text">

              <p>
                Writing private modules is a powerful technique
                for extending ASP.NET. However, extending can mean replacing existing
                functionality. Sometimes a smart solution results simply from using the internal
                modules and your own module together.
              </p>

              <p>
                To begin with, you’ll need access to the
                internal modules at runtime. You should make connections in the <code>Init</code> event in order to have access at an early stage. The next example
                shows you how to retrieve information about internal modules and other kinds of
                modules attached to the pipeline so far.
              </p>

            </Element>
            <Element Type="Listing" Name="Retrieving information about modules">

              public class SessionLogModule : IHttpModule
              {
                  #region IHttpModule Members                  public void Dispose()
                  {
                  }

                  public void Init(HttpApplication application)
                  {
                      HttpContext context = HttpContext.Current;
                      foreach (string key in application.Modules.AllKeys)
                      {
                          context.Response.Write( String.Format(&quot;{0}= {1} {2}&lt;br&gt;&quot;,
                              key,
                              application.Modules[key].GetType().IsPublic ? &quot;public&quot; : &quot;internal&quot;,
                              application.Modules[key].GetType().AssemblyQualifiedName));
                      }
                  }

                  #endregion
              }

            </Element>
            <Element Type="Text">

              <p>
                The current context is used to output
                the text directly into the current page where the request is handled. You can
                use the <code>Modules</code> property to get a list of the modules and where they are defined.
              </p>

            </Element>
            <Element Type="Image" Name="Modules already available">
              images/19835f0307.png
            </Element>
            <Element Type="Text">

              <p>
                You probably need to use this method of
                getting access to an embedded module, as not all modules offer direct access to
                their states and events. Once you know the name and type of a specific module,
                you can cast the type and get the object you need.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Configuration and Deployment">
          Configuration and Deployment
          <Element Type="Text">

            <p>
              Now that the module is implemented, we
              can compile it into an assembly that ASP.NET is able to load at runtime. This
              is straightforward as long as the module is in the web application. No special
              action is required. You will probably want to create several modules and have
              them in different assemblies for easy reuse. The assemblies will need to be referenced
              by your web project. To construct such a module, choose “Class Library" as the project
              template. Remove the default class created by the template, and add an object
              of type “ASP.NET Module".
            </p>

          </Element>
          <Element Type="Image" Name="Add a module to current project">
            images/19835f0306.png
          </Element>
          <Element Type="Section" Name="Configuring the Default Web Server and Development Environment">
            Configuring the Default Web Server and Development Environment
            <Element Type="Text">

              <p>
                To test the module,  you’ll need to
                configure the settings in <i>web.config</i>. Place the appropriate lines in the
                <code>&lt;system.web&gt;</code> section:
              </p>

              <p class="CodeFirst">&lt;httpModules&gt;</p>

            </Element>
            <Element Type="Listing">

                &lt;add Name=&quot;ReferrerModule&quot;
                     type=&quot;Apress.AspNetExtensibility.HttpModules.ReferrerModule &quot;/&gt;
              &lt;/httpModules&gt;

            </Element>
            <Element Type="Text">

              <p>
                The settings for the development
                environment also apply for IIS5, IIS6, and IIS7 in classic mode. There are
                several advantages to running the IIS7 integrated pipeline, however, which  requires
                different settings:
              </p>

            </Element>
            <Element Type="table" Name="Options of the httpModule settings">
              <table>
                <tr>
                  <th>Attribute</th>
                  <th>
                    Typical
                    Values
                  </th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>name</code>
                  </td>
                  <td>any string</td>
                  <td>
                    The module name
                    that appears in settings dialogs
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>type</code>
                  </td>
                  <td>
                    class,
                    assembly
                  </td>
                  <td>Module type</td>
                </tr>
              </table>
            </Element>
          </Element>
          <Element Type="Section" Name="Configuring IIS7 Settings">
            Configuring IIS7 Settings
            <Element Type="Text">

              <p>
                In the main (web) project, add a
                reference to the project containing the module. Assuming the namespace of the
                external project is <code>
                  Apress.HttpHandler.ImageHandler,
                </code> add the following to <i>web.config</i>:
              </p>

              <p>&lt;system.webServer&gt;</p>

            </Element>
            <Element Type="Listing">

                &lt;modules&gt;
                  &lt;add Name=&quot;ReferrerModule&quot;
                       type=&quot;Apress.HttpHandler.ImageHandler&quot; resourceType=&quot;File&quot;
                       requireAccess=&quot;Read&quot; preCondition=&quot;integratedMode&quot; /&gt;
                &lt;/modules&gt;
              &lt;/system.webServer&gt;

            </Element>
            <Element Type="Text">

              <p>
                Compile both the project containing the module
                and the web project. Add the mapping in Internet Information Services Manager,
                as shown before. The mapping will now function perfectly for both the
                development environment and direct usage from the local IIS7.
              </p>

            </Element>
            <Element Type="table" Name="Options for the handler settings for IIS7 integrated mode">
              <table>
                <tr>
                  <th>Attribute</th>
                  <th>
                    Typical
                    Values
                  </th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>

                      name
                    </code>
                  </td>
                  <td>any string</td>
                  <td>
                    The module name
                    that appears in settings dialogs
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>

                      precondition
                    </code>
                  </td>
                  <td>string</td>
                  <td>
                    Name of
                    another handler or module required before this one
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>type</code>
                  </td>
                  <td>
                    class,
                    assembly
                  </td>
                  <td>Type information of the handlers definition</td>
                </tr>
              </table>
            </Element>
          </Element>
          <Element Type="Section" Name="Configure using IIS Management Console">
            Configure using IIS Management Console
            <Element Type="Text">

              <p>
                Rather than
                adding the IIS7 integrated mode settings to <i>web.config</i> you can simply use
                the IIS Management Console. The settings correspond directly. Altering <i>web.config</i>
                will result in an immediate change to the Management Console settings, and vice
                versa. To configure using the IIS Management Console:
              </p>

              <p class="NumListFirst">
                1. Open Internet Information Service
                Manager.
              </p>

              <p class="NumList">2. Open the web you want to change.</p>

              <p class="NumList">
                3. In the IIS section, double click on the Modules
                icon.
              </p>

              <p class="NumList">
                4. Click on “Add managed module" in the task
                list to the right.
              </p>

              <p class="NumList">5. Enter these values in the dialog:</p>

              <p class="NumSubList">
                a.  Give the module an
                appropriate name
              </p>
              <p class="NumSubList">
                b.  Open the type drop down
                and select the module’s type
              </p>

              <p class="NumSubList">
                g.  Close the dialog by
                clicking “OK"
              </p>

              <p class="NumListLast">6. Close the main dialog by pressing “OK".</p>

              <p>
                No restart is required to activate the
                new settings.
              </p>

            </Element>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Handlers">
        Handlers
        <Element Type="Text">

          <p>
            This section focuses on developing HTTP
            handlers for IIS7 using the .NET Framework. We’ll look at when it is
            appropriate to develop an IIS7 handler rather than a module.
          </p>

        </Element>
        <Element Type="Section" Name="Built-in Handlers"></Element>
        Built-in Handlers
        <Element Type="Text">

          <p>
            ASP.NET offers several default HTTP
            handlers:
          </p>
          <ul>
            <li>Page Handler (.aspx) – Handles Web pages</li>
            <li>User Control Handler (.ascx) – Handles Web user control pages</li>
            <li>Web Service Handler (.asmx) – Handles Web service pages</li>
            <li>Trace Handler (trace.axd) – Handles trace functionality</li>
            <li>Assembly Resource Loader (WebResource.axd) – Handles embedded resources in assemblies</li>
            <li>Script resource handler (ScriptResource.axd) – Handles the scripting support for AJAX enabled projects</li>
            <li>Forbidden Handler (.config) – Denies access to files that contain confidential information</li>
          </ul>
          <p>
            The IIS configuration defines the
            assignments. You will also find other assignments there. Extensions such as .xoml,
            .rem, .soap, and .svc relate to the capabilities provided by Windows
            Communication Foundation (WCF) and its predecessor, .NET remoting.
          </p>

        </Element>
        <Element Type="Section" Name="Extending ASP.NET using Http Handlers">
          Extending ASP.NET using Http Handlers
          <Element Type="Text">

            <p>
              While modules are low level, and run against
              every inbound request to the ASP.NET application, HTTP Handlers focus more on a
              specific request mapping. This is usually a mapping of a file extension.
            </p>
            <p>
              HTTP Handler implementations
              are very simple in their concept, but having access to the <code>HttpContext</code> object enables enormous versatility. Handlers are implemented
              through the <code>
                IHttpHandler
              </code> interface, or its
              asynchronous counterpart, <code>
                IHttpAsyncHandler
              </code>. The
              interface consists of a single method, <code>
                ProcessRequest
              </code> and a single property <code>
                IsReusable
              </code>. The
              asynchronous version has a pair of methods (<code>
                BeginProcessRequest
              </code> and <code>
                EndProcessRequest
              </code>) and
              the same <code>IsReusable</code> property. The vital ingredient is <code>
                ProcessRequest
              </code>, which receives an instance of the <code>
                HttpContext
              </code>
              object. This single method is responsible for handling a Web request from start
              to finish.
            </p>

            <p>
              However, simple does not imply simplistic.
              As you may know, the regular page processing code and the web service
              processing code are implemented as handlers. Both are anything but simple. Their
              power originates from the <code>
                HttpContext
              </code> object,
              which has access to both the request information and the response data. This
              means that, like a web server, a handler can control the whole process on its
              own. Whatever you want to implement on the level of specific mapping is
              achievable using handlers.
            </p>

          </Element>
          <Element Type="Section" Name="Scenarios when to use HTTP Handlers">
            Scenarios when to use HTTP Handlers
            <Element Type="Text">

              <p>
                To better understand the power of
                handlers, let’s take a look at what others have implemented on top of <code>IHttpHandler</code>:
              </p>
              <ul>
                <li>Creating dynamic images</li>
                <li>Watermarking existing images</li>
                <li>“Pretty printing" of the page’s source code</li>
                <li>Generating dynamic content pulled from a database or external resource</li>
                <li>Transforming content from other resources, such as XML into HTML</li>
                <li>Extracting resources from assemblies on the fly</li>
                <li>Redirecting to/from SSL</li>
                <li>Implementing Pingback and Trackback capabilities, even if the site is not a blog</li>
              </ul>
              <p>
                Additionally, you can implement handlers
                asynchronously. This vastly extends the potential usage scenarios. Because
                asynchronous calls are closely related to threading and performance, we looked
                at threading and how it could benefit from asynchronous programming in chapter
                2. In this section, I will focus more on common usages of basic HTTP handler
                implementations.
              </p>

            </Element>
            <Element Type="Section" Name="Getting Started">
              Getting Started
              <Element Type="Text">

                <p>
                  For an HTTP Handler, all the action
                  occurs through a single call to <code>
                    ProcessRequest
                  </code>. This
                  can be as simple as:
                </p>
                <pre>
                  public void ProcessRequest(HttpContext context)
                  {
                     context.Response.Write(&quot;Hello World&quot;);
                  }
                </pre>

              </Element>
              <Element Type="Text">

                <p>
                  Using the <code>HttpContext</code> object, you have access to the <code>
                    Request
                  </code>, <code>Response</code>, <code>
                    Session
                  </code> and <code>Cache</code> objects. You have all the key features of an ASP.NET request at
                  your disposal, and you can use this to determine what users submitted and to return
                  content back to the client. (Refer to chapter 1 to see why <code>HttpContext</code> plays such an important role in the request processing process.)
                </p>

                <p>
                  The key operation of the handler
                  is to write output into the <code>
                    Response
                  </code> object—or, more
                  specifically, the <code>
                    Response
                  </code> object’s <code>OutputStream</code>. This output is what is sent back to the client. Behind the scenes,
                  the <code>ISAPIWorkerRequest</code> sends the <code>
                    OutputStream
                  </code> back to
                  the ISAPI <code>ecb.WriteClient</code> method, which actually performs the IIS output generation. Again,
                  refer to chapter 1 and chapter 2 to learn more about these steps.
                </p>

              </Element>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Building a Handler">
          Building a Handler
          <Element Type="Text">
            <p>
              Now, let’s build a simple handler. To
              do this, we define a class, which implements the <code>
                System.Web.IHttpHandler
              </code> interface.
            </p>

            <p>
              Despite the prominence of the <code>ProcessRequest</code> method, you’ll also need to implement a property—<code>IsReusable</code>. This property, which returns a Boolean value, indicates whether the
              instance can be re-used for subsequent requests. In some cases, after
              processing a request, your handler may not be in a valid state for processing
              further requests—especially if data about the previous request was stored in
              member variables. This is because the ASP.NET runtime can handle many requests at
              the same time. As long as there are threads available in the thread pool, a new
              request will be processed even if another one is still running. Each thread requires
              a new instance of the handler, even if the handler is marked “is reusable". When
              a request is completed, the current handler instance is retained in memory, and
              re-used for the next request. This can lead to odd behavior, depending on the workload
              and on the existence of other instances of the handler. Such problems can be unpredictable
              and difficult to simulate or recognize in a development environment.
            </p>

            <p>
              For stable and reliable behavior,
              you might assume that setting the <code>
                IsReusable
              </code>
              property to <code>
                false
              </code> is the solution. After all, this
              would create a new instance of the object any time a request is about to be
              processed. However, depending on how “intensive" your code is, this can lead to
              higher memory consumption, more CPU workload, and less throughput. There is no
              strict rule about it, but re-using the instances is the preferred solution. Keep
              in mind that access to members is not exactly what you might expect. Therefore,
              it is advisable to avoid private members that hold data, if possible. If you
              still wish to use member variables, remember that they need to be thread safe. When
              replacing regular members with static methods, you’ll have to implement thread
              safe code. If any of these requirements cannot be fulfilled, you should set <code>IsReusable</code> to <code>
                false
              </code>. Otherwise, the implementation will
              look like:
            </p>

          </Element>
          <Element Type="Listing">

            public bool IsReusable
            {
                get
                {
                  return true;
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              <code>IsReusable</code> should be a constant.
            </p>

          </Element>
          <Element Type="Section" Name="The Entry Point">
            The Entry Point
            <Element Type="Text">

              <p>
                The <code>ProcessRequest</code> method is the main entry point for the handler. Its role is to work
                off the request specified by the <code>HttpRequest</code>
                instance, from the provided <code>HttpContext</code> instance,
                and generate an appropriate response using the <code>HttpResponse</code>
                instance. The <code>ProcessRequest</code> method is invoked by the .NET
                runtime during the <code>ExecuteRequestHandler</code>
                request processing stage, assuming that the mapping is able to route the
                request to the specific handler. This is in contrast to modules, which receive all
                requests passing through the pipeline.
              </p>

              <p>
                Finally, let’s implement the <code>ProcessRequest</code> method, so that our handler has something to do. To keep things
                simple, our handler will return the current time of the server. We can specify the
                time zone in the query string. Our goal is to request a URL, such as http://myserver/page.time,
                and obtain the current time of the server. In addition, we can get the universal
                coordinated time (UTC) by requesting http://myserver/page.time?utc=true. Here’s
                the implementation:
              </p>

            </Element>
            <Element Type="Listing" Name="Simple Handler mapped to a new *.time file extension">

              public class TimeHandler : IHttpHandler
              {
                  #region IHttpHandler Members                  public bool IsReusable
                  {
                      get { return true; }
                  }

                  public void ProcessRequest(HttpContext context)
                  {
                      DateTime dt;
                      string useUtc = context.Request.QueryString[&quot;utc&quot;];
                      if (!String.IsNullOrEmpty(useUtc) &amp;&amp; useUtc.Equals(&quot;true&quot;))
                      {
                          dt = DateTime.UtcNow;
                      }
                      else
                      {
                          dt = DateTime.Now;
                      }
                      context.Response.Write(
                          String.Format(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;{0}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;,
                                         dt.ToLongTimeString()
                                         ));

                  }

                  #endregion
              }

            </Element>
            <Element Type="Text">

              <p>
                As we assign this handler to a specific
                extension—time—we’ll only receive it when the client uses this specific URL.
                The response is simple and creates a small HTML page. You could even tailor the
                response to suit clients that are not browsers.
              </p>

              <p>
                We use the <code>HttpRequest.QueryString</code> collection to retrieve a query string variable, and write the
                current time in response using the <code>
                  HttpResponse.Write
                </code> method. I recommend using the <code>
                  OutputStream
                </code>
                if other handlers are processing the request, or if you want to add to the
                existing response. In the example above, we write a complete response in the
                one handler and thus the <code>
                  Write
                </code> method is appropriate.
              </p>

            </Element>
            <Element Type="Image" Name="Setting the mapping of a managed handler in IIS7">
              images/19835f0320.png
            </Element>
            <Element Type="Text">

              <p>
                IIS7 does not require a restart or any
                other action in order to activate the handler. A request that uses the mapped
                extension should work immediately.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Example—Image Handler">
            Example—Image Handler
            <Element Type="Text">

              <p>
                A very common scenario for handlers is
                the manipulation of images. As with any other resource, a browser obtains an
                image by sending a GET request. Handling large numbers of images at multiple
                resolutions can be a challenge. Imagine a web shop with thousands of product
                images stored at one resolution. However, different image sizes are required
                throughout the site, from catalog thumbnails to large preview panes and icons in
                the shopping basket. Converting all these images into several different sizes
                could be expensive, even with a batch script. Images change frequently, and maintaining
                all current pictures in many different source sizes is an image management
                headache.
              </p>

              <p>
                Writing code and creating images
                dynamically is a typical task for a handler. Attaching requests to an image
                could achieved by using a path filter like *.png. The following example shows
                how easy it is to manipulate content and send it to a client.
              </p>

            </Element>
            <Element Type="Listing" Name="Adding a watermark to an image using a handler">

              namespace Apress.HttpHandler
              {
                public class ImageHandler : IHttpHandler
                {
                  #region IHttpHandler Members                  private const float FONTSIZE = 72F;
                  private const string FONT = &quot;Verdana&quot;;
                  private const string TEXT = &quot;Watermark&quot;;

                  public bool IsReusable
                  {
                    get { return true; }
                  }
                  public void ProcessRequest(HttpContext context)
                  {
                    // determine an image request
                    if ((Path.GetDirectoryName(
                         context.Request.Url.AbsolutePath)).EndsWith(&quot;Images&quot;))  
                    {
                        // load image and add watermark
                        Bitmap img = (Bitmap) Bitmap.FromFile(
                                      context.Server.MapPath(context.Request.Url.AbsolutePath));
                        Graphics g = Graphics.FromImage(img);
                        Brush b = new SolidBrush(Color.Silver);
                        Font f = new Font(FONT, FONTSIZE);
                        SizeF stringMeasure = g.MeasureString(TEXT, f);
                        // calculate the string position to center output
                        float x, y;
                        x = img.Width / 2 - stringMeasure.Width / 2;
                        y = img.Height / 2 - stringMeasure.Height / 2;
                        g.DrawString(TEXT, new Font(FONT, FONTSIZE), b, x, y);
                        // output to the response stream
                        img.Save(context.Response.OutputStream, ImageFormat.Jpeg);
                        img.Dispose();
                      }
                    }
                  }

                  #endregion                }
              }

            </Element>
            <Element Type="Text">

              <p>
                The handler first checks that it is dealing
                with a file from a particular directory. While the file mapping forces the
                handler to run for every request for an image with the specified extension, this
                test restricts the special processing to images in the “Images" folder only.
                The handler loads the image from disk, resolving the local path via <code>Server.MapPath</code>. Then it applies the watermark to the image. The <code>MeasureString</code> method measures the string size in order to align it with the image
                so that the text appears centered horizontally and vertically. Streams simplify
                the output of the image. The <code>
                  Save
                </code> method sends the
                output directly into an output stream in JPEG format. Disposing of the image is
                required, as frequent use of a handler on a system with high workload could
                prevent the garbage collector from freeing the memory often enough.
              </p>

            </Element>
            <Element Type="Image" Name="Adding a watermark to an image on the fly">
              images/19835f0305.png
            </Element>
            <Element Type="Text">

              <p>
                Dynamic image manipulation is powerful
                and flexible, and there are numerous possibilities for using an image handler
                in your applications. The final step in creating such a handler is to configure
                it in <i>web.config</i>. Please refer to the section “Configuration and
                Deployment" to read more about the various settings.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Example—Read Dynamic CSS from Resource">
            Example—Read Dynamic CSS from Resource
            <Element Type="Text">

              <p>
                In the next example, I describe a
                handler that loads stylesheets stored as embedded resources in an assembly. It
                replaces any call to a stylesheet by delivering a specific .css file. The
                definition in the <i> 12.0pt'>web.config</i> looks like this:
              </p>

            </Element>
            <Element Type="Listing">

              &lt;add verb=&quot;GET&quot;
              path=&quot;*.css&quot; type=&quot;Apress.HttpHandler.CssHandler&quot; /&gt;

            </Element>
            <Element Type="Text">

              <p>
                See the section “Configuration
                and Deployment" for more information about configuring a handler for the IIS7
                integrated mode.
              </p>

              <p>
                To obtain the style files, they
                must be marked as an Embedded Resource. There are several ways to handle data
                from sources other than the file system.
              </p>

            </Element>
            <Element Type="Image" Name="To handle files as embedded resources, use the file’s Property box">
              images/19835f0308.png
            </Element>
            <Element Type="Text">

              <p>
                The code itself does not have any
                quirks. It processes whatever it encounters, and decides how to proceed from
                the information in <code>
                  HttpContext
                </code>.
              </p>

            </Element>
            <Element Type="Listing" Name="Dynamic handling of CSS from embedded resources">

              public class CssHandler : IHttpHandler
              {
                  #region IHttpHandler Members                  public bool IsReusable
                  {
                      get { return false; }
                  }

                  public void ProcessRequest(HttpContext context)
                  {
                      UnmanagedMemoryStream s;
                      if (context.Request.UserAgent.Contains(&quot;MSIE&quot;))
                      {
                          s = (UnmanagedMemoryStream)
                             this.GetType().Assembly.GetManifestResourceStream(
                             &quot;Apress.HttHandler.HandlerAssembly.Css.ie.css&quot;);
                      }
                      else
                      {
                          s = (UnmanagedMemoryStream)
                               this.GetType().Assembly.GetManifestResourceStream(
                               &quot;Apress.HttHandler.HandlerAssembly.Css.ff.css&quot;);
                      }
                      s.Seek(0, SeekOrigin.Begin);
                      using (MemoryStream ms = new MemoryStream((int)s.Length))
                      {
                          byte[] buffer = new byte[s.Length];
                          s.Read(buffer, 0, buffer.Length);
                          ms.Write(buffer, 0, buffer.Length);
                          ms.WriteTo(context.Response.OutputStream);
                      }
                  }

                  #endregion
              }

            </Element>
            <Element Type="Text">

              <p>
                Firstly, let’s locate the
                current user agent in this code by using the property <code>UserAgent</code> of the <code>
                  HttpRequest
                </code> object. If
                the <code>UserAgent</code> is “MSIE", indicating an Internet Explorer browser, then the
                resource named “ie.css" is retrieved from the assembly. For any other
                <code>UserAgents</code>, “ff.css" is loaded instead. The stream is copied to
                a <code>MemoryStream</code> object. The <code>
                  MemoryStream
                </code> is helpful
                as it is able to copy its own content to another stream by using the <code>WriteTo</code>
                method. In the case of a handler, this is the output stream provided by the <code>
                  HttpResponse
                </code> object
                through the <code>
                  Response
                </code> property.
              </p>

              <p>
                This technique can be re-used.
                By looking for specific file extensions and for the “user-agent" header, you can
                block certain clients from reading the content of these resources or supply
                them with a replacement resource. Alternatively, reading resources from a
                database instead of an assembly gives more flexibility without adding code to
                the pages themselves.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Example—Handler That Does Not Create Content">
            Example—Handler That Does Not Create Content
            <Element Type="Text">

              <p>
                Handlers usually create content—typically
                HTML or data that builds an image. However, it’s not imperative. Handlers are
                primarily invoked by the associated file extension. Imagine you define a custom
                extension named “.counter" and associate it with a handler. Your handler might
                execute some code, but ignore the Writer and not send anything back to the
                client. Another idea is to only write data to the client when you run the
                handler in debug mode and save bandwidth when running on a production server.
                Whether or not the output is required, you’ll still have to invoke the handler
                by issuing a GET or POST request to the server. Therefore, you’ll need an
                element that can force the browser to create such a request. There are only few
                ways to do this:
              </p>
              <ul>
                <li>Image element</li>
                <li>Form element</li>
                <li>IFrame element</li>
                <li>JavaScript code</li>
              </ul>
              <p>
                I’m using an IFRAME element in the
                example below, because I want to show the content when in debug mode, and leave
                the content empty, otherwise. The definition of the IFRAME demonstrates how we
                invoke the handler:
              </p>

            </Element>
            <Element Type="Listing" Name="Invoke a handler using a registered extension">

              &lt;iframe src=&quot;my.counter&quot; width=&quot;100&quot; height=&quot;50&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;

            </Element>
            <Element Type="Text">

              <p>
                Furthermore, the handler itself shows
                the processing within the <code>ProcessRequest</code> method.
              </p>

            </Element>
            <Element Type="Listing" Name="Code of the handler">

              public class CounterHandler : IHttpHandler
              {

                  #region IHttpHandler Members                  public bool IsReusable
                  {
                      get { return true; }
                  }

                  public void ProcessRequest(HttpContext context)
                  {
                      string path = context.Request.UrlReferrer.LocalPath;
                      string file = context.Server.MapPath(&quot;Counter.xml&quot;);
                      XDocument cntDoc = XDocument.Load(file);
                      var cnt = (from e in cntDoc.Root.Elements(&quot;page&quot;) where
                                      e.Attribute(&quot;path&quot;).Value.Equals(path)
                                      select e).FirstOrDefault&lt;XElement&gt;();
                      if (Debugger.IsAttached)
                      {
                          // In debug mode read only and create output
                          // reading XML is thread safe
                          context.Response.Write(String.Format(&quot;Counter = {0}&quot;,
                                                 cnt.Attribute(&quot;count&quot;).Value));
                      }
                      else
                      {
                          // in production just store values
                          ReaderWriterLock rwl = new ReaderWriterLock();
                          rwl.AcquireWriterLock(TimeSpan.FromSeconds(2));
                          if (cnt == null)
                          {
                              // page does not exist yet
                              XElement newPage = new XElement(&quot;page&quot;,
                                  new XAttribute(&quot;count&quot;, 1),
                                  new XAttribute(&quot;path&quot;, path));
                              cntDoc.Element(&quot;Pages&quot;).Add(newPage);
                          }
                          else
                          {
                              // increase counter, set time stamp
                              int i = Int32.Parse(cnt.Attribute(&quot;count&quot;).Value);
                              cnt.Attribute(&quot;count&quot;).Value = (++i).ToString();
                          }
                          cntDoc.Save(file);
                          rwl.ReleaseWriterLock();
                      }
                  }

                  #endregion
              }

            </Element>
            <Element Type="Text">

              <p>
                The handler stores the number of page
                requests in a single XML document. Other developers can add the IFRAME code to
                the pages they want included in the counter total. Internally, the file access
                is shared read mode. The <code>
                  FileStream
                </code> class used
                behind the scenes in <code>
                  XDocument.Load
                </code> supports
                reading from different threads. However, write access requires an exclusive
                lock, blocking other threads. To achieve this, a <code>
                  ReaderWriterLock
                </code> class monitors the threads and blocks other threads from accessing
                the file during write mode. This isn’t a very efficient method. In a real life
                scenario, consider replacing the XML access with a database operation. After obtaining
                access to the XML, LINQ to XML is used to either create elements for the first
                time or add to the existing counter when the page is requested again.
              </p>

              <p>
                In the example, we want to distinguish between debug mode and production
                mode. You can ascertain debug mode by using the <code>
                  Debugger.IsAttached
                </code> property. In debug mode, the content of the IFRAME is filled with
                the counter for the current page. The LINQ statement prepared at the beginning
                of the <code>ProcessRequest</code> method returns either <code>
                  null
                </code> or the
                element containing the counter information.
              </p>

              <p>
                The figure shows the output in
                debug mode. The counter does not increase for requests in debug mode. In
                production mode, the counter increases but no output is displayed.
              </p>

            </Element>
            <Element Type="Image" Name="Output of the handler in debug mode">
              images/19835f0309.png
            </Element>
            <Element Type="Text">

              <p>
                In this example, I showed a handler that
                doesn’t create content with every use. The concepts behind this are, at a
                glance:
              </p>
              <ul>
                <li>Defining how and where to invoke the handler</li>
                <li>Remembering that concurrent threads access the code</li>
                <li>Recognizing that creating output is not mandatory</li>
              </ul>

            </Element>
          </Element>
          <Element Type="Section" Name="Example—Using IHttpHandlerFactory to Perform URL Rewriting">
            Example—Using IHttpHandlerFactory to Perform URL Rewriting
            <Element Type="Text">

              <p>
                In this example, we’ll introduce another
                interface. For more flexibility with creating handlers on the fly, the <code>IHttpHandlerFactory</code>
                interface is available. A closer look at the default <code>PageHandlerFactory</code>
                used to process .aspx pages shows that it is not derived from <code>IhttpHandler,</code>
                but from <code>IHttpHandlerFactory</code>.
              </p>
              <p>
                You don’t have to create a factory, but
                it gives more control over the creation process. It can be useful in more
                complex scenarios. First, let’s look into the interface definition:
              </p>

            </Element>
            <Element Type="Listing">

              public interface IHttpHandlerFactory
              {
                  IHttpHandler GetHandler(HttpContext context,
                                          string requestType,
                                          string url,
                                          string pathTranslated);
                  void ReleaseHandler(IHttpHandler handler);
              }

            </Element>
            <Element Type="SideBar" SidebarType="Note">
              <header>Note</header>
              <aside>
                If you decode this using
                Reflector, you may see another interface named"
                <code>IHttpHandlerFactory2</code>. This provides another overload for the
                <code>GetHandler</code> method. We don’t need this at this stage as we’ll only be using the
                <code>IHttpHandlerFactory</code>.
              </aside>
            </Element>
            <Element Type="Text">

              <p>
                Imagine you have a page with content such
                as:
              </p>
              <pre>
                &lt;% = DateTime.Now.ToString(&quot;M&quot;) %&gt;
              </pre>

            </Element>
            <Element Type="Text">

              <p>Set the current culture by adding the culture ID to the URL. Typical URLs look like this:</p>
              <ul>
                <li>http://localhost/Chapter03/UrlRewriteFactoryHandler/Default.aspx</li>
                <li>http://localhost/Chapter03/UrlRewriteFactoryHandler/en-us/Default.aspx</li>
                <li>http://localhost/Chapter03/UrlRewriteFactoryHandler/de-de/Default.aspx</li>
                <li>http://localhost/Chapter03/UrlRewriteFactoryHandler/fr-fr/Default.aspx</li>
              </ul>
              <p>
                Our goal is to find a way to extract the culture code (such as “de-de" or “en-us") from the URL, set it as the current
                culture of the thread, and process the page without the culture code, as shown in the first URL.
              </p>

            </Element>
            <Element Type="Listing" Name="Using a factory to rewrite a URL">

              public abstract class RewriteFactoryHandler : IHttpHandlerFactory 
              {
                  protected RewriteFactoryHandler()
                      : base() 
              { 
              }  
                  IHttpHandler IHttpHandlerFactory.GetHandler(HttpContext context,
                                                              string requestType,
                                                              string url,
                                                              string pathTranslated) 
                  {
                      Pair target = GetRemapInfo(context, requestType, url, pathTranslated); 
                      string filename = context.Server.MapPath(target.First.ToString());  
                      context.RewritePath(url, url, target.Second.ToString());
                      IHttpHandler appHandler =
                             PageParser.GetCompiledPageInstance(target.First.ToString(),
                                                                filename, context); 
                      return appHandler;  
                  } 
                  void IHttpHandlerFactory.ReleaseHandler(IHttpHandler handler)  
                  { 
                  } 

                  protected abstract Pair GetRemapInfo(HttpContext context, string requestType,
                                                       string url, string pathTranslated);
              }

              public class CultureRewriteHandler : RewriteFactoryHandler
              {
                  protected override Pair GetRemapInfo(HttpContext context,
                                                       string requestType,
                                                       string url,
                                                       string pathTranslated)
                  {
                      string originalPath = HttpContext.Current.Request.Path;
                      string stemPath = style='color:#A31515'>&quot;/&quot;;
                      string newPath = originalPath.Substring(originalPath.IndexOf(stemPath) +
                                                              stemPath.Length);
                      string[] segments = newPath.Split(style='color:#A31515'>'/');
                      string queryString = HttpContext.Current.Request.Url.Query;
                      try
                      {
                          string languagePart = segments[0];
                          CultureInfo ci = new CultureInfo(languagePart);
                          System.Threading.Thread.CurrentThread.CurrentCulture = ci;
                          return new Pair(style='color:#A31515'>&quot;/&quot; + stemPath + string.Join(style='color:#A31515'>&quot;/&quot;, segments, 1,
                                          segments.Length - 1), queryString);
                      }
                      catch (NullReferenceException)
                      {
                      }
                      return new Pair(originalPath, queryString);
                  }
              }

            </Element>
            <Element Type="Text">

              <p>
                The definition in <i>web.config</i>
                or IIS settings is the same as for any other handler. This means that the
                ASP.NET engine will accept both <code>
                  IHttpHandler
                </code> and <code>IHttpHandlerFactory</code>
                in order to obtain access to the handler object.
              </p>

              <p>
                The code is simplified for
                clarity. You can extend the error handling by adding code to handle the stem path,
                even if it’s set to a value other than the root path. The core implementation
                is around the <code>
                  GetHandler
                </code> method, which returns the used
                handler. If resources are blocked and need to be freed or disposed of, the
                required code will appear in the <code>
                  ReleaseHandler
                </code> method. As shown in the example, this is not always necessary. Keep
                in mind that the memory consumption of the handler might be an issue if the
                server has a high workload, in which case releasing resources could help.
              </p>

              <p>
                Figure 3-9 shows the behavior
                for several languages. URL rewriting is a flexible, search engine friendly method
                of modifying behavior.    
              </p>

            </Element>
            <Element Type="Image" Name="Use URL rewriting to set the current culture of a Web application">
              images/19835f0316.png
            </Element>
            <Element Type="Text">

              <p>
                This example demonstrated a very basic
                handler factory. In the abstract base class, the <code>
                  GetHandler
                </code>
                method rewrites using <code>
                  HttpContext.RewritePath
                </code>.
                The default page handler is subsequently retrieved and returned. This is
                required because otherwise, the processing of all .aspx pages is remapped to
                the new factory. Redefining the internal handler with your own one replaces the
                mapping, as only one handler can process a specific request. Remapping the
                default handler requires either a complete implementation of a handler with
                similar behavior, or creating the original handler and returns it using a
                factory. From the perspective of extensibility, the latter is the better
                option.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name="Advanced Usage of Handlers">
          Advanced Usage of Handlers
          <Element Type="Text">

            <p>
              The standard handlers cover most, but
              not all, tasks. Http Handlers can go further. In this section, I’ll discuss
              advanced extensibility topics:
            </p>
            <ul>
              <li>Accessing the session state</li>
              <li>Dynamically dealing with handlers in the pipeline</li>
            </ul>

          </Element>
          <Element Type="Section" Name="Handlers and Session State">
            Handlers and Session State
            <Element Type="Text">

              <p>
                Handlers are low level programming constructs.
                They are critical for overall performance and if badly written or configured, could
                degrade the server’s throughput. While there are ways to deal with long-running
                threads in the handler code (as you saw in chapter 2), it’s preferable to write
                handlers that run as fast as possible. To maximize handler speed, Microsoft
                removed session information from the default handlers. The previous examples
                show useful tasks accomplished without needing session information.
              </p>
              <p>
                If you do need to access session state
                information, it is available by implementing one of the following two
                interfaces:
              </p>
              <ul>
                <li>
                  <code>IRequiredSessionState</code>
                </li>
                <li>
                  <code>IReadOnlySessionState</code>
                </li>
              </ul>
              <p>
                It’s possible to obtain session
                information with minimal performance loss. If you only require read access to
                the session data, the <code>
                  IReadOnlySessionState
                </code>
                is ideal. <code>IRequiredSessionState</code> gives full access to all session data. When adding either interface
                to your class, you’ll notice that Visual Studio does not attempt to implement
                any method bodies. Both interfaces are simply marker interfaces which modify
                the internal processing within the base class. Your class declaration should
                look like this:
              </p>
              <pre>
                public class TimeHandler : IHttpHandler, IRequiredSessionState
              </pre>
            </Element>
            <Element Type="Text">

              <p>
                The session information is now provided to
                the <code>HttpContext</code> object, and available through the <code>
                  context
                </code>
                parameter of the entry method.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Accessing the Pipeline Using the Context">
            Accessing the Pipeline Using the Context
            <Element Type="Text">

              <p>
                You can use these three properties of
                the <code>HttpContext</code> object to further modify the behavior of the handler or to retrieve
                more information about what’s taking place: 
              </p>
              <ul>
                <li>
                  <code>context.Handler</code>
                </li>
                <li>
                  <code>context.PreviousHandler</code>
                </li>
                <li>
                  <code>context.RemapHandler</code>
                </li>
              </ul>
              <p>
                Using the <code>
                  Handler
                </code>
                property, you have access to the current handler employed in the current
                context. As the context is available as a static property, it’s easy to access
                the handler in classes defined elsewhere. This also applies to the
                <code>PreviousHandler</code> property, a property which is set when the handler is remapped.
                Remapping a handler might occur in complex scenarios where a default handler
                processes all requests, but remaps to another handler under certain circumstances.
                Listing 3-12 demonstrates this technique:
              </p>

            </Element>
            <Element Type="Listing" Name="Remapping to another handler">
              public class RemapHandler : IHttpHandler
              {
                  #region IHttpHandler Members                  public bool IsReusable
                  {
                      get { return true; }
                  }
                  public void ProcessRequest(HttpContext context)
                  {
                      IHttpHandler remapHandler = null;
                      // determine an image request and handle with private handler
                      if ((Path.GetExtension(context.Request.Url.AbsolutePath)).Equals(&quot;.png&quot;))
                      {
                          remapHandler = new ImageHandler();
                      }
                      else
                      {
                          // process any other request with default handler
                          string virtualPath = context.Request.Url.AbsolutePath;
                          string filename = HttpContext.Current.Request.Path;
                          remapHandler = PageParser.GetCompiledPageInstance(virtualPath,
                                                                           filename, context);
                      }
                      context.RemapHandler(remapHandler);
                  }

                  #endregion
              }

            </Element>
            <Element Type="Text">

              <p>
                In this code, the handler searches for
                .png extensions and assigns private handlers to process them. Otherwise, we use
                the standard page processing; no other custom code is involved. Simply call
                <code>context.RemapHandler(remapHandler)</code>
                to assign to a different handler. All internal processing is
                redirected to the new handler from the beginning of the pipeline. As there’s no
                additional overhead, there are no performance issues with the handler
                remapping.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name="Configuration and Deployment">
            Configuration and Deployment
            <Element Type="Text">

              <p>
                To create a handler, you chose “Class
                Library" as the project template, removed the default class created by the
                template and added an object of type “ASP.NET Handler". Now that you have implemented
                the handler, you can compile it into an assembly loaded by ASP.NET at runtime.
                As long as the handler remains in the web application, this is simple. No
                special action is required. You’ll probably want to implement several handlers
                and keep them in different assemblies for easy reuse. Simply reference the
                assemblies in your web project.
              </p>

            </Element>
            <Element Type="Image" Name="Add a handler to project">
              images/19835f0304.png
            </Element>
            <Element Type="Section" Name="Configuring Default Web Server and Development Environment">
              Configuring Default Web Server and Development Environment
              <Element Type="Text">

                <p>
                  To test the handler, you’ll need to
                  configure the settings in <i> 12.0pt'>web.config</i>. Place the appropriate settings in the <code>&lt;system.web&gt;</code> section:
                </p>
                <pre>
                  &lt;httpHandlers&gt;
                    &lt;add verb=&quot;GET&quot; path=&quot;*.png&quot; type=&quot;Apress.HttpHandler.ImageHandler&quot; /&gt;
                  &lt;/httpHandlers&gt;
                </pre>

              </Element>
              <Element Type="Text">

                <p>
                  The settings for the development
                  environment also apply to IIS5, IIS6, and IIS7 in classic mode. There are
                  several advantages to running the IIS7 integrated pipeline, however, which
                  involves different settings:
                </p>

              </Element>
              <Element Type="table" Name="Options of the httpHandler settings">
                <table>
                  <tr>
                    <th>Attribute</th>
                    <th>
                      Typical
                      Values
                    </th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>
                      <code>

                        verb
                      </code>
                    </td>
                    <td>GET, POST</td>
                    <td>
                      The handler
                      responds to the HTTP verbs only
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>
                        path
                      </code>
                    </td>
                    <td>full path or wildcards</td>
                    <td>
                      The
                      path that defines the requests the handlers responds to
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>type</code>
                    </td>
                    <td>
                      class,
                      assembly
                    </td>
                    <td>Type information of the handler’s definition</td>
                  </tr>
                </table>
              </Element>
            </Element>
            <Element Type="Section" Name="Configuring IIS7 Settings">
              Configuring IIS7 Settings
              <Element Type="Text">

                <p>
                  In the main (web) project, add a
                  reference to this project. If the namespace of the external project is <code>Apress.HttHandler.ImageHandler</code>, the following addition to <i>web.config</i> will be required:
                </p>

              </Element>
              <Element Type="Listing">

                &lt;system.webServer&gt;
                  &lt;handlers&gt;
                    &lt;add Name=&quot;ImageHandler&quot; path=&quot;*.png&quot; verb=&quot;GET&quot;
                         type=&quot;Apress.HttpHandler.ImageHandler&quot; resourceType=&quot;File&quot;
                         requireAccess=&quot;Read&quot; preCondition=&quot;integratedMode&quot; /&gt;
                  &lt;/handlers&gt;
                &lt;/system.webServer&gt;

              </Element>
              <Element Type="Text">

                <p>
                  Compile both the project containing the
                  handler and the web project. Add the mapping in Internet Information Services
                  Manager, as shown before. The mapping will now function perfectly for both the
                  development environment and direct usage from the local IIS7.
                </p>

              </Element>
              <Element Type="table" Name="Handler settings for IIS7 integrated mode">
                <table>
                  <tr>
                    <th>Attribute</th>
                    <th>
                      Typical
                      Values
                    </th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>
                      <code>verb</code>
                    </td>
                    <td>GET, POST</td>
                    <td>
                      The handler
                      responds to the HTTP verbs only. Other verbs are DEBUG and HEAD
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>

                        path
                      </code>
                    </td>
                    <td>full path or wildcards</td>
                    <td>
                      The
                      path that defines the requests the handlers respond to
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>

                        resourceType
                      </code>
                    </td>
                    <td>File</td>
                    <td>
                      Expect that
                      the file exists
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>

                        scriptProcessor
                      </code>
                    </td>
                    <td>a path</td>
                    <td>
                      Path to the
                      engine (DLL) that handles the request
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>

                        requireAccess
                      </code>
                    </td>
                    <td>
                      Script, Execute, None,
                      Read
                    </td>
                    <td>Required settings for resource access</td>
                  </tr>
                  <tr>
                    <td>
                      <code>

                        preCondition
                      </code>
                    </td>
                    <td>see below</td>
                    <td>
                      Conditions
                      that must be fulfilled to activate the handler. If the request fails, an HTTP
                      error 412 “precondition failed" is send to the client
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>type</code>
                    </td>
                    <td>
                      class,
                      assembly
                    </td>
                    <td>Type information of the handler’s definition</td>
                  </tr>
                </table>
              </Element>
              <Element Type="Text">

                <p>
                  Typical values for <code>preCondition</code> are these:
                </p>
                <ul>
                  <li>
                    <code>bitness32</code>, <code>bitness64</code>: Activate 32-bit or 64-bit mode respectively
                  </li>
                  <li>
                    <code>runtimeVersion1.1</code>, <code>runtimeVersion2.0</code>: The required runtime on the server
                  </li>
                  <li>
                    <code>classicMode</code>, <code>integratedMode</code>: Mode that IIS7 is running in
                  </li>
                  <li>
                    <code>managedHandler</code>: Requires the handler to be written in managed code
                  </li>
                </ul>

              </Element>
              <Element Type="Section" Name="Configure via IIS Management Console">
                Configure via IIS Management Console
                <Element Type="Text">

                  <p>
                    The settings in <i>web.config</i>
                    required by IIS7 integrated mode can be altered via the IIS Management Console.
                    The settings correspond directly. Altering <i>web.config</i> will result in an
                    immediate change to the Management Console settings, and vice versa. To configure
                    using the IIS Management Console:
                  </p>

                  <p class="NumListFirst">
                    1. Open Internet Information Service Manager.
                  </p>

                  <p class="NumList">2. Open the web you want to change. </p>

                  <p class="NumList">
                    3. In the IIS section, double click on the
                    Handler Assignments.
                  </p>

                  <p class="NumList">
                    4. Click on “Add Managed Handler" in the task
                    list to the right.
                  </p>

                  <p class="NumList">5. Enter these values in the dialog:</p>

                  <p class="NumSubList">             a.  The mapping path: *.time</p>
                  <p class="NumSubList">
                    b.  Choose the handler from the
                    drop down list. The handler will appear in the list, as long as you’re in the
                    right web and the project compiles.
                  </p>

                  <p class="NumSubList">
                    c.  Give the handler an
                    appropriate name
                  </p>

                  <p class="NumSubList">             d.  Click on Restrictions…</p>

                  <p class="NumSubList">             e.  Open the Verb tab</p>

                  <p class="NumSubList">
                    f.  Click on one of the
                    following and enter the value “GET"
                  </p>

                  <p class="NumSubList">
                    g.  Leave the dialog by
                    clicking “OK"
                  </p>

                  <p class="NumListLast">6. Leave the main dialog by clicking “OK".</p>

                </Element>
              </Element>
              <Element Type="Section" Name="Configure Using Generic Handlers">
                Configure Using Generic Handlers
                <Element Type="Text">

                  <p>
                    The final option is not a configuration
                    option, but a way of invoking handlers without configuring them in <i>web.config</i>.
                    By default, ASP.NET defines handlers using the extension .ashx. Therefore,
                    placing the code for a handler in a file using the declarative form below is sufficient
                    to get it working. There is no further need for <i>web.config</i>. An advantage
                    of this is that you won’t need to distinguish between the settings for IIS7
                    integrated mode and other Web servers, nor will you need to maintain settings
                    in the <i>web.config</i> regarding handlers.
                  </p>
                  <p>
                    Creating such a handler involves two
                    steps:
                  </p>
                  <ul>
                    <li>For each handler required, create a file with the extension .ashx</li>
                    <li>Add the following declaration at the top of the file:</li>
                  </ul>
                  <pre>
                    &lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Apress.HttpHandler.MyHandler&quot; %&gt;
                  </pre>

                </Element>
                <Element Type="Text">

                  <p>
                    The <code>
                      WebHandler
                    </code>
                    directive is similar to the Page directive. Only a few options are available,
                    however:
                  </p>

                </Element>
                <Element Type="table" Name="Attributes supported for WebHandler directive">
                  <table>
                    <tr>
                      <th>Attribute</th>
                      <th>
                        Available
                        Values
                      </th>
                      <th>Usage</th>
                    </tr>
                    <tr>
                      <td>
                        <code>

                          Language
                        </code>
                      </td>
                      <td>C#, VB</td>
                      <td>
                        Language of
                        the code section
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>

                          Class
                        </code>
                      </td>
                      <td>Name</td>
                      <td>
                        Name of the class
                        defined in code, including the namespace
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>

                          CodeBehind
                        </code>
                      </td>
                      <td>Name</td>
                      <td>
                        Name of the
                        file containing the code
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>

                          CompilerOptions
                        </code>
                      </td>
                      <td></td>
                      <td>
                        Options for
                        on-the-fly compilation
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>

                          Debug
                        </code>
                      </td>
                      <td>True, False</td>
                      <td>
                        Compile in
                        debug or release mode. In debug mode the symbol file (.pdb) is created
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>

                          WarningLevel
                        </code>
                      </td>
                      <td>0 to 4</td>
                      <td>Warning level</td>
                    </tr>
                    <tr>
                      <td>
                        <code>Description</code>
                      </td>
                      <td></td>
                      <td>
                        A
                        description for documentation purposes only. The page parser does not recognize
                        this attribute.
                      </td>
                    </tr>
                  </table>
                </Element>
                <Element Type="Text">

                  <p>
                    Whether you use the configuration file
                    or the .ashx extension is a matter of preference. However, there are some basic
                    guidelines for selecting the best option. Using the .ashx file within an
                    application is better for small projects or handlers that have simple, but
                    specific, tasks. If you plan to reuse the handler several times, or in several
                    projects on the server, you should separate it into its own assembly and
                    register it in the Global Assembly Cache (GAC). Storing handlers in assemblies
                    with signing and deployment capabilities is for larger projects involving
                    handler reuse.
                  </p>

                </Element>
              </Element>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Asynchronous Pages">
        Asynchronous Pages
        <Element Type="Text">

          <p>
            So
            far, all of the examples of asynchronous request handling have involved
            building custom handlers. In chapter 3, I’ll cover such handlers in more
            detail.
          </p>

          <p>
            There
            may be many *.aspx pages in your ASP.NET applications that are also good
            candidates for asynchronous execution because they perform non-CPU-bound tasks
            that take significant amounts of time. Such pages are also potential
            bottlenecks for the ASP.NET thread pool.
          </p>

          <p>
            Because
            pages are also managed by a handler, it seems easy to let pages execute
            asynchronously. This is already implemented by the framework for us and there
            is nothing to do but set a property.
          </p>

        </Element>
        <Element Type="Section" Name="Define the Right Page Handler">
          Define the Right Page Handler
          <Element Type="Text">

            <p>
              Building
              asynchronous pages is pretty simple. Begin by including an attribute in the
              page’s <code>
                @Page
              </code>
              directive:
            </p>
            <pre>
              &lt;%@ Page Async=&quot;true&quot; ... %&gt;
            </pre>
            <p>
              Behind the
              scenes, this tells ASP.NET to implement <code>
                IHttpAsyncHandler
              </code>
              in the page instead of <code> IHttpHandler</code>
              used regularly. Next, call the <code> AddOnPreRenderCompleteAsync</code>
              method early in the page’s lifetime. For
              example, in <code>
                10.0pt;Load
              </code> style='background:
              yellow'>, this is early enough. Register a <code>
                Begin
              </code>
              method and an <code> End</code>
              method, as shown in the following code:
            </p>
            <pre>
              AddOnPreRenderCompleteAsync (
                  new BeginEventHandler(MyBeginMethod),
                  new EndEventHandler (MyEndMethod)
              );
            </pre>
            <p>
              The page runs
              through its normal processing lifecycle until shortly after the <code> PreRender</code>
              event fires. Then ASP.NET calls the <code> Begin</code>
              method that you registered using <code> AddOnPreRenderCompleteAsync</code>
              . The <code>
                Begin
              </code>
              method launches an asynchronous operation
              and returns immediately. This is a lengthy
              operation which might require more time, such as a
              database query or a webservice call to another server. At this point, the
              thread assigned to the request returns to the thread pool. Furthermore, the <code> Begin</code>
              method returns an <code> IAsyncResult</code>
              that allows ASP.NET to determine when the
              asynchronous operation has been completed. ASP.NET then extracts a thread from
              the thread pool and calls your <code>
                End
              </code>
              method. After <code>
                End
              </code>
              returns, it executes the remaining
              portion of the page’s lifecycle. This might sound confusing—getting the thread
              back from thread pool would again block the thread. But between the time <code> Begin</code>
              returns and <code> End</code>
              gets called, the request-processing
              thread is free to service other requests. Keep in mind that the page processing
              usually takes only a few milliseconds. The time-consuming operation in the asynchronous
              handler might run for seconds. The process of freeing the thread pool thread
              for this time allows ASP.NET to process hundreds if not thousands of regular
              pages on this very same thread. However, until <code>
                End
              </code>
              is called, the rendering of the current
              asynchronous page is delayed. This is the same as in the previous example. It
              improves the situation not only for one user, but for all users. In the sample
              code, you might look for the <code>
                IAsyncResult
              </code>
              implementation. Instead of implementing
              our own version, we take one that the Framework implements for us.
            </p>

          </Element>
          <Element Type="Image" Name="Synchronous vs. Asynchronous Page Processing">
            ASPNETEXT_Chapter_03_V1.0-Dateien/image001.png
          </Element>
          <Element Type="Text">
            <p>
              Figure 2-12 illustrates the difference between
              a synchronous page and an asynchronous page. When a synchronous page is
              requested, ASP.NET assigns the request a thread from the thread pool and
              executes the page on that thread.
            </p>
            <p>
              That’s
              enough theory for now. It’s time to look at some samples to get a better
              appreciation of how to implement asynchronous pages. The two examples address
              two common problems:
            </p>
            <ul>
              <li>Call a database operation asynchronously</li>
              <li>Call a webservice—a current exchange rate service that converts between US$ and Euro.</li>
            </ul>

          </Element>
        </Element>
        <Element Type="Section" Name="Asynchronous Data Binding">
          Asynchronous Data Binding
          <Element Type="Text">

            <p>
              It is a common
              task to query databases and data bind the results. Using asynchronous pages to
              perform asynchronous data binding seems like a perfect symbiosis. The code
              behind class in Listing 2-21 shows one way to go.
            </p>

          </Element>
          <Element Type="Listing" Name="Asynchronous binding to a data source (AsyncDataBind.aspx.cs)">

            using System;
            using System.Data;
            using System.Data.SqlClient;
            using System.Web;
            using System.Web.UI;
            using System.Web.UI.WebControls;
            using System.Web.Configuration;

            public partial class AsyncDataBind : System.Web.UI.Page
            {
                private SqlConnection _connection;
                private SqlCommand _command;
                private SqlDataReader _reader;
                protected void Page_Load(object sender, EventArgs e)
                {
                    if (!IsPostBack)
                    {
                        // Hook PreRenderComplete event for data binding
                        this.PreRenderComplete +=
                            new EventHandler(Page_PreRenderComplete);

                        //Register async methods
                        AddOnPreRenderCompleteAsync(
                            new BeginEventHandler(BeginAsyncOperation),
                            new EndEventHandler(EndAsyncOperation)
                        );
                    }
                }
                IAsyncResult BeginAsyncOperation (object sender, EventArgs e,
                    AsyncCallback cb, object state)
                {
                    string connect = WebConfigurationManager.ConnectionStrings
                       [&quot;PubsConnectionString&quot;].ConnectionString;
                    _connection = new SqlConnection(connect);
                    _connection.Open();
                    _command = new SqlCommand(
                       &quot;SELECT title_id, title, price FROM titles&quot;, _connection);
                    return _command.BeginExecuteReader (cb, state);
                }

                void EndAsyncOperation(IAsyncResult ar)
                {
                    _reader = _command.EndExecuteReader(ar);
                }

                protected void Page_PreRenderComplete(object sender, EventArgs e)
                {
                    Output.DataSource = _reader;
                    Output.DataBind();
                }

                public override void Dispose()
                {
                    if (_connection != null) _connection.Close();
                    base.Dispose();
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              The <code>  AsyncDataBind</code>
              class uses the <code> AddOnPreRenderCompleteAsync</code>
              pattern. In its <code> BeginAsyncOperation</code>
              method, it calls <code> SqlCommand.BeginExecuteReader</code>
              to perform an asynchronous database query. When the call is completed, <code>
                EndAsyncOperation
              </code>
              calls <code>
                SqlCommand.EndExecuteReader
              </code>
              to get a <code>
                SqlDataReader
              </code>
              , which it stores in a private field. In
              an event handler for the <code>
                PreRenderComplete
              </code>
              event, which fires after the asynchronous
              operation completes but before the page is rendered, it binds the
              <code> SqlDataReader</code>
              to the Output <code> GridView</code>
              control. On the outside, the page looks
              like a normal synchronous page that uses a <code>
                GridView
              </code>
              to render the results of a database
              query. On the inside, this page is much more scalable because it doesn't tie up a thread-pool thread
              waiting for the query to return.
            </p>

          </Element>
          <Element Type="Section" Name="Calling Web Services Asynchronously">
            Calling Web Services Asynchronously
            <Element Type="Text">

              <p>
                Another
                I/O-related task commonly performed by ASP.NET Web pages is calling to a Web
                service. Since Web service calls can take a long time to return, pages that
                execute them are ideal candidates for asynchronous processing.
              </p>

              <p>
                Listing 2-22 shows one way to build an
                asynchronous page that calls a Web service. It uses the same <code>AddOnPreRenderCompleteAsync</code>
                mechanism featured in this section. The
                page’s <code>
                  Begin
                </code>
                method launches an asynchronous Web service call by calling the Web service
                proxy’s asynchronous <code>
                  Begin
                </code>
                method. The page’s <code>
                  End
                </code>
                method caches in a private field a
                reference to the <code>
                  DataSet
                </code>
                returned by the Web method, and the <code> PreRenderComplete</code>
                handler binds the <code> DataSet</code>
                to a <code>
                  GridView
                </code>
                . For reference, the Web method targeted
                by the call is shown in the following code:
              </p>

            </Element>
            <Element Type="Listing" Name="Calling a webservice from an ASP.NET page asynchronously">
              [WebMethod]
              public DataSet GetTitles ()
              {
                  string connect = WebConfigurationManager.ConnectionStrings
                      [&quot;PubsConnectionString&quot;].ConnectionString;
                  SqlDataAdapter adapter = new SqlDataAdapter
                      (&quot;SELECT title_id, title, price FROM titles&quot;, connect);
                  DataSet ds = new DataSet();
                  adapter.Fill(ds);
                  return ds;
              }
            </Element>
            <Element Type="Listing" Name="AsyncWSInvoke1.aspx.cs">
              using System;
              using System.Data;
              using System.Configuration;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;

              public partial class
              AsyncWSInvoke1 : System.Web.UI.Page
              {
                  private WS.PubsWebService _ws;
                  private DataSet _ds;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                      if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          //Register async methods
                          AddOnPreRenderCompleteAsync(
                              new BeginEventHandler(BeginAsyncOperation),
                              new EndEventHandler(EndAsyncOperation)
                          );
                      }
                  }

                  IAsyncResult BeginAsyncOperation (object sender, EventArgs e,
                      AsyncCallback cb, object state)
                  {
                      _ws = new WS.PubsWebService();
                      // Fix up URL for call to local VWD-hosted Web service
                      _ws.Url = new Uri(Request.Url, &quot;Pubs.asmx&quot;).ToString();
                      _ws.UseDefaultCredentials = true;
                      return _ws.BeginGetTitles (cb, state);
                  }
                  void EndAsyncOperation(IAsyncResult ar)
                  {
                      _ds = _ws.EndGetTitles(ar);
                                }
                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _ds;
                      Output.DataBind();
                  }
                  public override void Dispose()
                  {
                      if (_ws != null) _ws.Dispose();
                      base.Dispose();
                  }
              }

            </Element>
            <Element Type="Text">
              <p>
                This
                is one way to do it, but it’s not the only way. The Web service proxy supports
                two mechanisms for placing asynchronous calls to Web services. One is the
                per-method <code>Begin</code> and <code>End</code> The other is the new <code>MethodAsync</code>
                methods and <code> MethodCompleted</code>
                events. Even if the Begin/End pattern
                seems to be easy to read and adopt, because it is similar to the asynchronous
                pattern of the page’s handler, there are a few advantages to using the other
                pattern.
              </p>
              <p>
                If a Web service has a method named <code>Foo</code>, then in addition to having methods named <code> Foo</code> , <code>BeginFoo</code>, and <code>EndFoo</code>
                , a Web service proxy includes a method named <code>FooAsync</code> and an event named <code>FooCompleted</code>.
                You can call <code>Foo</code> synchronously by registering a handler for the <code>FooCompleted</code> event and calling
                <code>FooAsync</code>, like this:
              </p>
              <pre>
                proxy.FooCompleted += new FooCompletedEventHandler (OnFooCompleted);
                proxy.FooAsync (...);
                ...
                void OnFooCompleted (Object source, FooCompletedEventArgs e)
                {
                    // Called when Foo completes
                }
              </pre>
              <p>
                The asynchronous call begins when <code>FooAsync</code>
                completes, and a <code> FooCompleted</code>
                event fires then, causing your <code>FooCompleted</code>
                event handler to be called. Both the
                delegate wrapping the event handler (<code>FooCompletedEventHandler</code>
                ) and the second parameter passed to it (<code>FooCompletedEventArgs</code>
                ) are generated with the Web service
                proxy. You can access <code>Foo</code>’s return value through <code>FooCompletedEventArgs.Result</code>.
              </p>
              <p>
                Listing
                2-24 presents a code behind class that calls a Web service's GetTitles method
                asynchronously using the <code>MethodAsync</code>
                pattern. Functionally, this page is
                identical to the one shown in Listing 2-23. Internally, it’s quite different.
                AsyncWSInvoke2.aspx includes a <code>Page</code>
                directive with property <code> Async</code>
                set to true. But it doesn’t call <code> AddOnPreRenderCompleteAsync</code>
                ; it registers a handler for <code> GetTitlesCompleted</code>
                events and calls <code> GetTitlesAsync</code>
                on the Web service proxy. ASP.NET still
                delays rendering the page until <code>GetTitlesAsync</code>
                completes. Under the hood, it uses an
                instance of <code>System.Threading.SynchronizationContext</code>, a class that receives notifications when
                the asynchronous calls begin and when they complete.
              </p>
            </Element>
            <Element Type="Listing" Name="AsyncWSInvoke2.aspx.cs">
              using System;
              using System.Data;
              using System.Configuration;
              using System.Web;
              using System.Web.UI;
              using System.Web.UI.WebControls;

              public partial class AsyncWSInvoke2 : System.Web.UI.Page
              {
                  private WS.PubsWebService _ws;
                  private DataSet _ds;

                  protected void Page_Load(object sender, EventArgs e)
                  {
                      if (!IsPostBack)
                      {
                          // Hook PreRenderComplete event for data binding
                          this.PreRenderComplete +=
                              new EventHandler(Page_PreRenderComplete);

                          // Call the Web service asynchronously
                          _ws = new WS.PubsWebService();
                          _ws.GetTitlesCompleted += new
                              WS.GetTitlesCompletedEventHandler(GetTitlesCompleted);
                          _ws.Url = new Uri(Request.Url, &quot;Pubs.asmx&quot;).ToString();
                          _ws.UseDefaultCredentials = true;
                          _ws.GetTitlesAsync();
                      }
                  }

                  void GetTitlesCompleted(Object source,
                      WS.GetTitlesCompletedEventArgs e)
                  {
                  }
                      _ds = e.Result;

                  protected void Page_PreRenderComplete(object sender, EventArgs e)
                  {
                      Output.DataSource = _ds;
                      Output.DataBind();
                  }

                  public override void Dispose()
                  {
                      if (_ws != null) _ws.Dispose();
                      base.Dispose();
                  }
              }
            </Element>
            <Element Type="Text">
              <p>
                There are two
                advantages to using <code>
                  MethodAsync
                </code>
                rather than <code> AddOnPreRenderCompleteAsync</code>
                to implement asynchronous pages. Firstly,
                <code>
                  MethodAsync
                </code> style='background:
                yellow'> supports forwarding impersonation, culture, and <code> HttpContext.Current</code>
                to the <code>
                  MethodCompleted
                </code>
                event handler. Secondly, if the page
                makes multiple asynchronous calls and must delay rendering until all calls have
                been completed, using <code>
                  AddOnPreRenderCompleteAsync
                </code>
                requires you to compose an <code> IAsyncResult</code>
                that remains unsignaled until all the
                calls are finished. This is not necessary in <code>
                  MethodAsync
                </code>
                ; simply place the calls, as many of them
                as you like, and the ASP.NET engine will delay the rendering phase until the
                final call returns.
              </p>
            </Element>
            <Element Type="Section" Name="Asynchronous Tasks">
              Asynchronous Tasks
              <Element Type="Text">
                <p>
                  <code>
                    10.0pt;MethodAsync
                  </code>
                  is a convenient way to make multiple asynchronous
                  Web service calls from an asynchronous page and delay the rendering phase until
                  all the calls complete. Calling a Web service is not the only task that
                  requires asynchronous programming. I/O-operations can be slow, too, especially
                  when the server comes under pressure.
                </p>

              </Element>
              <Element Type="Section" Name="Register Asynchronous Tasks">
                Register Asynchronous Tasks
                <Element Type="Text">

                  <p>
                    The <code> Page</code>
                    class introduces another method of
                    facilitating asynchronous operations: <code>
                      RegisterAsyncTask
                    </code>
                    . <code>
                      RegisterAsyncTask
                    </code>
                    has several advantages. In addition to <code> Begin</code>
                    and <code>
                      End
                    </code>
                    methods, <code>
                      RegisterAsyncTask
                    </code>
                    lets you register a timeout method that’s
                    called if an asynchronous operation takes too long to complete. You can set the
                    timeout declaratively by including an <code>
                      AsyncTimeout
                    </code>
                    attribute in the page’s <code> Page</code>
                    directive. For example, to set the
                    timeout to ten seconds:
                  </p>
                  <pre>
                    AsyncTimeout=&quot;10&quot;
                  </pre>
                  <p>
                    The
                    second advantage is that you can call <code>
                      RegisterAsyncTask
                    </code>
                    several times in one request to register
                    several asynchronous operations. As with <code>
                      MethodAsync
                    </code>
                    and all other solutions, ASP.NET delays
                    rendering the page until all operations have been completed. Thirdly, you can
                    use the fourth parameter of <code>
                      RegisterAsyncTask
                    </code>
                    to pass the state to your <code> Begin</code>
                    methods. Finally, <code> RegisterAsyncTask</code>
                    forwards impersonation, culture, and <code> HttpContext.Current</code>
                    to the <code>
                      End
                    </code>
                    and <code>
                      Timeout
                    </code>
                    methods for easy and transparent access.
                    As mentioned earlier, the same is not true of an <code>
                      End
                    </code>
                    method registered with <code> AddOnPreRenderCompleteAsync</code>
                    .
                  </p>

                  <p>
                    In
                    other respects, an asynchronous page that relies on <code> RegisterAsyncTask</code>
                    is similar to one that relies on <code> AddOnPreRenderCompleteAsync</code>
                    . The attribute in the page directive <code> Async=&quot;true&quot;</code>
                    is still required, and it still executes
                    as normal through the <code>
                      PreRender
                    </code>
                    event. Listing 2-25 demonstrates <code> RegisterAsyncTask</code>
                    in a short example.
                  </p>

                </Element>
                <Element Type="Listing" Name="AsyncPageTask.aspx.cs">

                  using System;
                  using System.Web;
                  using System.Web.UI;
                  using System.Web.UI.WebControls;
                  using System.Net;
                  using System.IO;
                  using System.Text;
                  using System.Text.RegularExpressions;

                  public partial class AsyncPageTask : System.Web.UI.Page
                  {

                      private WebRequest _request;
                      protected void Page_Load(object sender, EventArgs e)
                      {
                          PageAsyncTask
                  task = new PageAsyncTask(
                              new
                  BeginEventHandler(BeginAsyncOperation),
                              new
                  EndEventHandler(EndAsyncOperation),
                              new
                  EndEventHandler(TimeoutAsyncOperation),
                              null
                          );
                          RegisterAsyncTask(task);
                      }

                      IAsyncResult
                  BeginAsyncOperation(object sender, EventArgs e,
                          AsyncCallback
                  cb, object state)
                      {
                          _request =
                  WebRequest.Create(&quot;http://msdn.microsoft.com&quot;);
                          return
                  _request.BeginGetResponse(cb, state);
                      }
                      void
                  EndAsyncOperation(IAsyncResult ar)
                      {
                          string text;
                          using
                  (WebResponse response = _request.EndGetResponse(ar))
                          {
                              using
                  (StreamReader reader =
                                  new
                  StreamReader(response.GetResponseStream()))
                              {
                                  text =
                  reader.ReadToEnd();
                              }
                          }
                          Regex regex =
                  new Regex(&quot;href\\s*=\\s*\&quot;([^\&quot;]*)\&quot;&quot;,
                  RegexOptions.IgnoreCase);
                  MatchCollection matches = regex.Matches(text);
                          StringBuilder builder = new StringBuilder(1024);
                          foreach (Match
                  match in matches)
                          {
                  builder.Append(match.Groups[1]);
                  builder.Append(&quot;&lt;br/&gt;&quot;);
                          }
                          Output.Text =
                  builder.ToString();
                      }
                      void
                  TimeoutAsyncOperation(IAsyncResult ar)
                      {
                          Output.Text =
                  &quot;Data temporarily unavailable&quot;;
                      }
                  }

                </Element>
                <Element Type="Text">

                  <p>
                    The primary
                    advantage of <code>
                      10.0pt;RegisterAsyncTask
                    </code>
                    is that it allows asynchronous pages to fire off
                    multiple asynchronous calls and delays rendering until all the calls have been
                    completed. It works equally well for one asynchronous call, and it offers a
                    timeout option that <code>
                      AddOnPreRenderCompleteAsync
                    </code>
                    does not provide. If you build an
                    asynchronous page which makes just one asynchronous call, you can use <code> AddOnPreRenderCompleteAsync</code>
                    or <code>
                      RegisterAsyncTask
                    </code>
                    . But for asynchronous pages that place
                    two or more such calls, <code>
                      RegisterAsyncTask
                    </code>
                    simplifies your life considerably.
                  </p>

                </Element>
                <Element Type="Section" Name="Setting Properties">
                  Setting Properties
                  <Element Type="Text">

                    <p>
                      There are a
                      number of relevant properties that can be set programmatically. (It was not
                      possible to demonstrate all aspects in the sample code.) Please refer to the
                      documentation to see what else is possible and how to modify its behavior. The
                      intention of this chapter is to show ways to improve the overall performance of
                      a web server through understanding the basics of thread pooling and request
                      handling.
                    </p>

                  </Element>
                </Element>
              </Element>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Testing and Debugging Modules and Handlers">
        Testing and Debugging Modules and Handlers
        <Element Type="Text">
          <p>
            Having deployed and configured the module
            or handler, debugging may be required. In Visual Studio, the normal Debug mode works
            well for debugging handlers. You’re probably already familiar with the
            debugging capabilities in Visual Studio. Setting breakpoints and viewing
            variable’s values is just as simple for handlers as for any other type of .NET solution.
          </p>

        </Element>
        <Element Type="Section" Name="Debug using IIS">
          Debug using IIS
          <Element Type="Text">

            <p>
              You may occasionally experience trouble
              with your application when running on IIS. There are no breakpoints, and adding
              logging and tracing capabilities can be tedious. In large projects there are
              often coding guidelines that require you to add tracing code and to log pertinent
              messages (such as exceptions). In smaller projects, it might not be appropriate
              to write more code for logging and tracing. Setting a simple breakpoint and
              examining a value or condition during a request would be nice.
            </p>

            <p>
              It can be done. To do so, you can attach
              a debugger to a running application. In the case of an ASP.NET application
              running on IIS7, this is the worker process—w3wp.exe. Let’s consider the case
              where you have not published your project, but simply compiled on the fly, and
              your sources—the .cs files—are still available beside the .aspx files. (I’ll discuss
              techniques for attaching to a precompiled project later.) Here, the Visual
              Studio debugger attaches automatically to the current process when you hit F5,
              and start a debug session. This current process is the internal Web server
              included in Visual Studio. You can achieve the same thing simply by attaching
              the debugger to the worker process. If the worker process is not running, force
              it by requesting the first page and invoking the modules or handlers configured
              for your application. It doesn’t matter whether it is running properly or not.
            </p>

            <p>
              Here is a brief summary of the
              pre-conditions so far:
            </p>
            <ul>
              <li>IIS is configured to run the Web directly from project files</li>
              <li>Visual Studio is running and has the project loaded (however, there is no debug session so far)</li>
              <li>The Worker process is up and running</li>
            </ul>

          </Element>
          <Element Type="SideBar" SidebarType="Tip">
            <header>Tip</header>
            <aside>
              You can force the worker
              process to start by invoking a first request to the application. To check
              whether it is available, open Task Manager, switch to the Processes tab, check
              the box (Windows Server 2008) or click the button (Windows Vista) “Show
              processes from all users", and search for w3wp.exe in the list.
            </aside>
          </Element>
          <Element Type="Image" Name="Use the Task Manager to check for the worker process">
            images/19835f0310.png
          </Element>
          <Element Type="Text">

            <p>
              Now open Visual Studio and attach the
              debugger to the worker process:
            </p>

            <p class="NumListFirst">
              1. Open <i>Debug &gt; Attach to Process…</i>
            </p>

            <p class="NumList">
              2. In the subsequent dialog, check these
              settings:
            </p>

            <p class="NumSubList">
              a)  <i>Transport</i>: default
            </p>

            <p class="NumSubList">
              b)  <i>Qualifier</i>: The
              name of the server or workstation
            </p>

            <p class="NumSubList">
              c)  In the <i>Attached to</i>
              section, you should at least have the option Managed Code selected. Use the
              Select button to change settings.
            </p>

            <p class="NumList">
              3. In the list of Available Processes, look
              for the worker process. If it’s not there, tick the checkbox <i>
                Show processes
                from all users
              </i>. This is same option as in the Task Manager.
            </p>

            <p class="NumList">
              4. Use the Refresh button to reload the list
              of processes during the session without closing the dialog
            </p>

            <p class="NumList">
              5. Mark available worker processes and click <i>Attach</i>.
            </p>

          </Element>

          <Element Type="Image" Name="Attaching the debugger to the worker process">
            images/19835f0311.png
          </Element>
          <Element Type="Text">

            <p>
              Depending on your server
              conditions, you may find that several worker processes appear in the list. If you’re
              not sure which process is the one handling the current request, you can attach to
              all of them. Alternatively, use Task Manager to kill all the worker processes,
              issue a new request to your application, and refresh the list. If no one else
              is using the server, one worker process will appear. Of course, the usage of
              worker processes—as explained in chapter 2—depends on the threads required.
              Under rare circumstances, the application needs more power and splits the
              requests into multiple worker processes. However, attaching several instances
              of the worker process to the same debugger session is quite easy.
            </p>

            <p>
              With Visual Studio running in
              debug mode, as it is when you hit the F5 key, you can set breakpoints within
              the module or handler code and invoke a request to hit the breakpoint. You can
              even watch the debug and trace information in the output window.
            </p>

            <Element Type="Section">
              <h4>Problems Debugging the Worker Process</h4>
              <p>
                Sometimes the behavior of the debugger
                does not match your expectations. Quite frequently the breakpoints appear inactive,
                or they can’t be ‘hit’, as Visual Studio calls it.
              </p>

            </Element>
            <Element Type="Image" Name="The breakpoint will not currently be hit">
              images/19835f0312.png
            </Element>
            <Element Type="Text">

              <p>
                Usually this is because the page has not
                yet been loaded. Because we decided to let ASP.NET compile pages on the fly,
                the current page might not be available yet and therefore the symbols are not
                built. To check this, use the <i>Modules</i> dialog in Visual Studio.
              </p>

            </Element>

            <Element Type="Image" Name="Use the Modules window to retrieve information about loaded symbols">
              images/19835f0314.png
            </Element>
            <Element Type="Text">

              <p>
                In the Modules window, look for the
                assembly you built for your module or handler. In the context menu of each
                entry, use the <i>Symbol load information</i> item to retrieve more
                information. Either you’ll obtain the full path, or the symbol file (.pdb) is
                loaded from the list of paths Visual Studio has tried so far.
              </p>

            </Element>
            <Element Type="SideBar" SidebarType="Tip">
              <header>Tip</header>
              <aside>
                To debug parts of the
                operating system or .NET framework, use the Modules dialog to attach foreign
                pdb files. Additionally, it can be a good idea to set up a symbol server in
                your company in order to have common symbol files ready, or, alternatively,
                attach to Microsoft’s public symbol server.
              </aside>
            </Element>
            <Element Type="Image" Name="Use the symbols settings in Visual Studio to optimize access to public PDBs">
              images/19835f0315.png
            </Element>
            <Element Type="Text">

              <p>
                Once everything is functioning normally and
                the attached symbols are available, the breakpoints should function as expected
                and be “hit" when the code execution reaches them.
              </p>
            </Element>
            <Element Type="Image" Name="Everything is ready to go if the breakpoint is active">
              images/19835f0313.png
            </Element>
          </Element>
          <Element Type="Section" Name="Set up Tracing for Handlers">
            Set up Tracing for Handlers
            <Element Type="Text">

              <p>
                Aspx pages have a powerful and popular
                tracing feature. When you set the following page directive, the page’s content
                will be replaced by a complete analysis of the request:
              </p>
              <pre>
                &lt;%@ Page Trace=&quot;true&quot; …
              </pre>
              <p>
                However, the <code>@WebHandler</code> directive does not support this. If you write your module or
                handler in a separate assembly, using plain code, there is no directive at all.
              </p>
              <p>
                An example of a handler invoked
                by file extension is the <i>Trace.axd</i> file used for debugging. In order to
                invoke the <i>Trace.axd</i> handler, configure the website for tracing by
                adding a trace section to <i>web.config</i> as this:
              </p>
              <pre>
                &lt;configuration&gt;
                    &lt;system.web&gt;
                        &lt;trace enabled=&quot;true&quot;/&gt;
                    &lt;/system.web&gt;
                &lt;/configuration&gt;
              </pre>
              <p>
                Call the <i>trace.axd</i> file from the root of the website: for example,  <i>http://localhost/trace.axd</i>.
              </p>

            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name="Summary">
        Summary
        <Element Type="Text">
          <p>
            In this chapter, you learned how to
            extend the pipeline by creating your own modules and handlers. A module
            provides low level processing and is invoked twice: when the request bubbles up
            the pipeline and again after all internal processing by the designated handler
            is complete. Using a handler, you can add your own processing code either
            assigned to your own file extension or using the generic .ashx extension.
            Handlers process requests and create the output sent to the client.
          </p>
          <p>
            Asynchronous handlers help to process long-running
            requests—such as database queries or Web services—without filling the thread
            pool with threads. This technique improves the overall performance of a Web
            application and leads to a consistently smooth user experience.
          </p>
        </Element>

      </Element>
    </Element>
    <Element Type="Section" Name = "Providers and Configuration" >
      Providers and Configuration
      <Element Type="Text">
        <p>
          In the previous chapters, you learned
          how to extend ASP.NET at a low level. For daily tasks, however, you typically work
          at a higher level. A core concept of the ASP.NET extensibility paradigm is the
          provider model: a software module that provides a uniform interface to a
          service. ASP.NET incorporates several common providers that allow developers to
          replace functionality with their own modules, without breaking compatibility with
          existing modules.
        </p>
        <p>In this chapter, you’ll learn:</p>
        <ul>
          <li>The provider model concept</li>
          <li>
            How providers work internally and how
            to configure them properly
          </li>
          <li>What are the built-in providers?</li>
          <li>
            How to develop your own custom
            provider model to allow others to extend your application
          </li>
          <li>How to extend the configuration model</li>
          <li>
            How to use expression syntax and
            expression generators to access configuration from markup
          </li>
        </ul>
        <p>
          At the end of this chapter, you’ll be
          able to create and extend your own providers. You’ll also know how to integrate
          them with existing ASP.NET applications so that other developers can extend
          your application. The extensibility of built-in providers is covered in more
          detail in the remaining chapters.
        </p>

      </Element>
      <Element Type="Section" Name = "The Provider Model" >
        The Provider Model
        <Element Type="Text">

          <p>
            Providers are software modules build on
            top of interfaces or abstract classes that define the façade for the
            application. The interfaces constitute a “seam" in the architecture, which
            allows you to replace providers without affecting other modules. For instance,
            the data access provider enables access to any kind of storage for data:
            including databases from different vendors. Hence, the provider model encapsulates
            the functionality and isolates it from the rest of the application.
          </p>

          <p>
            Because almost all the major parts of
            ASP.NET are built on top of providers, there are multiple ways of modifying the
            internal behavior. Providers are responsible for the extensibility of ASP.NET. Creating
            your own providers gives you the ability to construct a sophisticated
            architecture that others might use—and to alter its behavior without disturbing
            internal processing. Consider an application such as Microsoft Office SharePoint
            Server 2007 (MOSS), which is an ASP.NET application and a framework that others
            use as a foundation for their applications. A similar extensibility concept is supplied
            on this level. Providers build the core technology that all of this is based
            on.
          </p>

        </Element>
        <Element Type="Section" Name = "Goals of the Provider Model" >
          <Element Type="Text">

            <p>
              When you work with providers for the
              first time, you may find that writing or extending a provider can be a
              complicated task. Due to the constraints of compatibility and transparency towards
              other modules, there is often no other option but extending internal interfaces.
              You may still need to decide whether or not to write your own provider model.
              This chapter gives you the information you need for making that decision.
            </p>

            <p>
              Recall what the provider model was
              designed for:
            </p>
            <ul>
              <li>
                It makes ASP.NET both flexible
                and extensible
              </li>
              <li>It’s robust and well documented</li>
              <li>
                It provides a common and modern
                architecture for your application
              </li>
              <li>
                It’s part of a multi-tier
                architecture
              </li>
            </ul>
            <p>
              The provider model does not consist only
              of simple provider modules. At the top level of the model are services. “Services"
              in ASP.NET is a generic term for separate modules, such as Membership, Site
              Maps, or Profiles. These all are high-level components, which make your life as
              a developer easier. Almost all of these services need some kind of data storage
              or at least a communication channel. From the perspective of a multi-tier
              application, the service should be independent of the particulars of data persistence.
            </p>

          </Element>
          <Element Type="Image" Name="Provider as part of a multi-tier architecture">
            images/ASPEXTf0410.tif
          </Element>
          <Element Type="Text">

            <p>
              The Provider sits between these
              two layers: the Service and the Data Store (Figure 4.1). Modifying the Provider
              allows the Service to use a different Data Store or communication channel
              without changing the Service functionality. From the perspective of the user,
              this architecture is transparent.
            </p>

            <p>
              Additionally, the Provider is a readily
              configurable module. You can usually change the Provider by editing the <i>web.config</i>
              file or by setting properties in base classes.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Default Provider" >
          <Element Type="Text">

            <p>
              ASP.NET comes with several built-in providers.
              As long as they perform their function for you, they need no modification.
              However, circumstances change, and at some point you might find it necessary to
              create your own provider. Before commencing, though, it’s illuminating to learn
              about the existing providers and how they enhance their associated services.
            </p>

          </Element>
          <Element Type="SideBar" SidebarType="Note">

            In this book, I do not supply
            a full description of all the built-in providers. Please refer to the
            documentation on MSDN to learn more about usage and configuration scenarios.
          </Element>

        </Element>
        <Element Type="Text">

          <p>
            Before looking into the provider model, let’s
            differentiate between the two levels, services and providers, as mentioned
            before. Table 4.1 shows all the services in ASP.NET and the provider associated
            with each service.
          </p>

        </Element>
        <Element Type="Table" Name="ASP.NET services using providers">
          <table>
            <tr>
              <th>Service</th>
              <th>Default Provider</th>
            </tr>
            <tr>
              <td>Membership       </td>
              <td>System.Web.Security.SqlMembershipProvider</td>
            </tr>
            <tr>
              <td>Roles    </td>
              <td>System.Web.Security.SqlRoleProvide</td>
            </tr>
            <tr>
              <td>Site Map</td>
              <td>System.Web.XmlSitemapProvider</td>
            </tr>
            <tr>
              <td>Profile</td>
              <td>System.Web.Profile.SqlProfileProvider</td>
            </tr>
            <tr>
              <td>Session State</td>
              <td>System.Web.SessionState.InProcSessionStateStore</td>
            </tr>
            <tr>
              <td>Web Parts</td>
              <td>
                System.Web.UI.WebControls.Webparts.SqlPersonalizationProvider
              </td>
            </tr>
          </table>
        </Element>
        <Element Type="Text">

          <p>
            You can deduce the storage
            location from the naming scheme. Membership, Role Management, Profile, and Web
            Parts services use SQL Server by default, while the Site Map service defaults
            to a XML file, the <i>web.sitemap</i> file. Session variables are held in
            memory within the IIS process.
          </p>

          <p>
            Two services do not include
            preconfigured built-in providers. In fact, these services do have default
            providers, but you need to configure them explicitly before you can use them.
            See Table 4.2 for more information:
          </p>

        </Element>
        <Element Type="Table" Name="ASP.NET services with unconfigured default providers">
          <table>
            <tr>
              <th>Service</th>
              <th>Recommended Provider (Not assigned by default)</th>
            </tr>
            <tr>
              <td>Web Events</td>
              <td>System.Web.Management.EventLogWebEventProvider</td>
            </tr>
            <tr>
              <td>Protected Configuration</td>
              <td>System.Configuration.RsaProtectedConfigurationProvider</td>
            </tr>
          </table>
        </Element>
        <Element Type="Text">

          <p>
            Web events are events that
            monitor ASP.NET. They are normally off and must be configured in the <code>&lt;healthMonitoring&gt;</code> section of <i>web.config</i>.
          </p>

          <p>
            By default, configuration data
            is saved in plain text. The <code>
              RsaProtectedConfigurationProvider
            </code> enables encryption of sensitive configuration data—particularly
            useful if your application is hosted on external servers where unvetted administrators
            could read the files.
          </p>

          <p>
            The providers shown in the preceding
            tables are merely recommendations—there are alternatives. Table 4.3 gives the
            full list of providers included with ASP.NET.
          </p>
        </Element>
        <Element Type="Section" Name = "Built-In Providers" >
          Built-In Providers
          <Element Type="Text">
            <p>
              Some of the built-in ASP.NET services have
              multiple provider options:
            </p>
          </Element>
          <Element Type="Table" Name="Built-in providers—the complete list">
            <table>
              <tr>
                <th>Service </th>
                <th>Available Providers</th>
              </tr>
              <tr>
                <td>Membership </td>
                <td>System.Web.Security.SqlMembershipProvider</td>
              </tr>
              <tr>
                <td>
                </td>
                <td>
                  System.Web.Security.ActiveDirectoryMembershipProvider
                </td>
              </tr>
              <tr>
                <td>Roles</td>
                <td>System.Web.Security.SqlRoleProvider</td>
              </tr>
              <tr>
                <td></td>
                <td>System.Web.Security.AuthorizationStoreRoleProvider</td>
              </tr>
              <tr>
                <td></td>
                <td>System.Web.Security.WindowsTokenRoleProvider </td>
              </tr>
              <tr>
                <td>Site Map</td>
                <td>System.Web.XmlSitemapProvider</td>
              </tr>
              <tr>
                <td>Profile</td>
                <td>System.Web.Profile.SqlProfileProvider</td>
              </tr>
              <tr>
                <td>Session State</td>
                <td>System.Web.SessionState.InProcSessionStateStore</td>
              </tr>
              <tr>
                <td></td>
                <td>System.Web.SessionState.OutOfProcSessionStateStore</td>
              </tr>
              <tr>
                <td></td>
                <td>System.Web.SessionState.SqlSessionStateStore</td>
              </tr>
              <tr>
                <td>Web Parts</td>
                <td>System.Web.UI.WebControls.Webparts.SqlPersonalizationProvider</td>
              </tr>
              <tr>
                <td>Protected Configuration</td>
                <td>System.Configuration.RSAProtectedConfigurationProvider</td>
              </tr>
              <tr>
                <td></td>
                <td>
                  System.Configuration.DPAPIProtectedConfigurationProvider
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              If none of the providers available for a
              specific service fit your needs, you might consider writing your own provider. There
              are two ways to accomplish this:
            </p>
            <ul>
              <li>
                Extend an existing provider in
                order to change its behavior slightly
              </li>
              <li>
                Write your own provider on top of
                the provider’s base class
              </li>
            </ul>
            <p>
              As you can imagine, extending an
              existing provider is the easier option. Whenever you keep the existing data
              store but wish to change the behavior it’s better to extend an existing
              provider. If you want to use a different data store, it is preferable to write
              your own provider. The next sections of this chapter will provide the necessary
              information.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Extending Built-In Providers" >
          <Element Type="Text">

            <p>
              Extending the built-in providers is an
              important feature. Several sections of this book describe extensibility methods
              based on extending providers. Please refer to related parts in:
            </p>
            <ul>
              <li>
                Chapter 5: extending page
                persistence through session state providers
              </li>
              <li>
                Chapter 6: extending resource
                management through resource providers
              </li>
              <li>
                Chapter 7: extending the membership
                and role providers
              </li>
              <li>
                Chapter 7: profile provider
                extensibility features
              </li>
              <li>
                Chapter 8: extending the sitemap
                provider
              </li>
            </ul>
            <p>
              Extensibility for all the providers is supplied
              by the same base class, as explained in the next section, while the section
              “Creating a Custom Provider" later in this chapter shows the basic techniques
              for custom provider implementation. Read these first before proceeding with one
              of the chapters mentioned above. 
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "The Anatomy of a Provider" >
        The Anatomy of a Provider
        <Element Type="Text">

          <p>
            Both custom and built-in providers
            inherit from the <code>ProviderBase</code> base class. The full definition looks like this:
          </p>

        </Element>
        <Element Type="Listing">

          using System;

          using
          System.Collections.Specialized;

          namespace
          System.Configuration.Provider          {

              public abstract class ProviderBase              {

                  protected ProviderBase();

                  public virtual string Description { get; }

                  public virtual string Name { get; }

                  public virtual void Initialize(string name, NameValueCollection config);

              }

          }

        </Element>
        <Element Type="Text">

          <p>
            There is nothing specific to providers
            here so far. The properties <code>
              Name
            </code>
            and <code>
              >Description
            </code> are for
            descriptive purposes only. <code>
              Name
            </code>
            is the internal name used in configuration settings and <code>Description</code> supports graphical tools. If the description is not set, the
            property returns the name instead. The name is mandatory within the
            configuration collection. The only method to put the provider in operation is <code>Initialize</code>. The <code>
              config
            </code>
            parameter passes the configuration settings. The <code>
              name
            </code> parameter is required because you can name the provider in the
            configuration file, while the call to <code>
              Initialize
            </code> transfers this name for further reference.
          </p>

          <p>
            As you can see from this code
            snippet, the base class does not do anything useful. This is what makes it hard
            to develop your own provider from scratch. If you want to modify the behavior,
            it’s much easier to develop one of the existing classes and override the
            properties or methods that don’t fit your needs. However, in this chapter I’ll
            explain how to write a custom provider from scratch. Modifying built-in
            providers will be covered in subsequent chapters.
          </p>

        </Element>
        <Element Type="Section" Name = "Making the Provider Available" >
          <Element Type="Text">

            <p>
              To make the provider available, you’ll
              need a service that uses the provider. However, there are no one-to-one
              relationships between services and their providers. The provider model exists
              to enable the substitution of one provider with another. To create a custom
              provider, you’ll need a custom service and one or more custom providers.
            </p>

            <p>
              The service itself does not have a base
              class, but it does hold several references to other types discussed in this
              section:
            </p>
            <ul>
              <li>The collection of configured providers</li>
              <li>
                The particular provider currently
                associated with the service
              </li>
              <li>
                The configuration parameters assigned
                to the current provider
              </li>
              <li>
                The code to instantiate and
                initialize the provider
              </li>
            </ul>
            <p>
              Somewhere in your application, there
              will be a consumer of this service. Consider the service from the perspective of
              this consumer. The consumer code needs the service in order to obtain data or
              do something useful. The consumer is not concerned with how the service is
              configured or how it stores or retrieves data. Even the service itself does not
              care about this, but handles it using a custom definition of the provider. With
              both of these abstraction tiers, it’s possible to replace the provider without altering
              anything within either the service or its consumers.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Configuring the Provider" >
          <Element Type="Text">

            <p>
              A provider serves as a layer between an
              upper level tier and a data tier. It can be simple or complex, but there’s
              nothing specific to providers except for the <code>Initialize
              </code>
              method. The uniqueness of providers is in the special way you can configure and
              attach them using the <i>web.config</i> file. This makes a provider accessible
              to those who configure and maintain a Web server. (Incidentally, the namespace for
              the provider’s base class indicates that providers are all about configuration.)
            </p>

            <p>
              All provider configurations follow the
              following pattern:
            </p>

          </Element>
          <Element Type="Listing">

            &lt;configuration&gt;
              &lt;system.web&gt;
                &lt;serviceName&gt;
                   &lt;providers&gt;
                     &lt;clear/&gt;
                     &lt;add Name=&quot;myProvider&quot;/&gt;
                   &lt;/providers&gt;
                &lt;/serviceName&gt;
              &lt;/system.web&gt;
            &lt;/configuration&gt;

          </Element>
          <Element Type="Text">

            <p>
              Notice is that there is not one
              provider but a collection of them. Usually there will be only one, but the
              configuration schema allows you to configure several. The configuration
              classes, as explained later, manage the typical pattern in the xml file based
              on the instructions <code>
                &lt;clear/&gt;
              </code>, <code>
                &lt;remove&gt;
              </code>, and <code>&lt;add&gt;</code>. This is necessary because the <i>web.config</i> files form a
              hierarchy from machine level down to the specific subfolder in the application.
              As long as you have permission, you can override the inherited settings, remove
              one or all entries, and add your own.
            </p>

            <p>
              Because you have to handle a
              collection of providers even if only one is needed, a collection class is
              required. As for the provider’s base class, there is a base class for
              collections, too.
            </p>

          </Element>
          <Element Type="Listing">

            namespace System.Configuration.Provider
            {
                public class ProviderCollection : ICollection, IEnumerable
                {
                    public ProviderCollection();
                    public bool IsSynchronized { get; }
                    public object SyncRoot { get; }
                    public ProviderBase this[string name] { get; }
                    public virtual void Add(ProviderBase provider);
                    public void CopyTo(ProviderBase[] array, int index);
                    public IEnumerator GetEnumerator();
                    public void Remove(string name);
                    public void SetReadOnly();
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              Using the <code>ProviderBase</code> type, it’s easy to handle the custom provider as well as any of the
              default built-in ones using this collection. You can also specify one of the
              providers to be the default provider. This links the service to a provider in
              the absence of any other selection criteria.
            </p>

            <p>
              So far, we have a service supplying
              the consumers, a provider as a late-bound component that hides the details of the
              data or communication tier, and finally a storage location for a collection of
              provider definitions. However, the format of the configuration also requires a
              section definition.
            </p>

            <p>
              Configuration sections are
              defined at the beginning of the <i>web.config</i> file and extend the
              configuration by specifying where the actual definitions are stored. Initially,
              I assumed that provider configurations are stored in the <code>&lt;configuration&gt;&lt;system.web&gt;</code> hive. This is the default setting for built-in providers but not compulsory
              for custom providers. In fact, you can use any path within the <code>&lt;configuration&gt;</code> top-level element. It’s good practice to stay with this model and
              place custom providers there, too. The configuration sections are defined
              within the <code>
                &lt;configSections&gt;
              </code>
              element. Beneath this element, you’ll find a hierarchy of <code>&lt;sectionGroup&gt;</code> and <code>
                &lt;section&gt;
              </code> elements in no particular order. The hierarchy is the exact
              representation of the sections used below this part in the <i>web.config</i>.
              However, the default <i>web.config</i> has more sections than the <code>&lt;configSection&gt;</code> section does. The reason is that your current <i>web.config</i>
              inherits from the global, machine wide definition. You can find the
              configuration file that contains all possible section definitions within the
              following path:
            </p>

            <p class="Query"> style='>%system%\Microsoft.NET\Framework\v2.0.50727\CONFIG\machine.config</p>

            <p>
              To add your own configuration section to
              support a specific location for your custom provider definition, you’ll need to
              add a section definition. Firstly, a custom section definition class has to be
              implemented. The following base class is the final step in obtaining a complete
              definition for custom providers:
            </p>

          </Element>
          <Element Type="Listing">

            namespace System.Configuration
            {
                public abstract class ConfigurationSection : ConfigurationElement
                {
                    protected ConfigurationSection();
                    public SectionInformation SectionInformation { get; }
                    protected internal virtual void DeserializeSection(XmlReader reader);
                    protected internal virtual object GetRuntimeObject();
                    protected internal override bool IsModified();
                    protected internal override void ResetModified();
                    protected internal virtual string SerializeSection(ConfigurationElement parentElement,  string name, ConfigurationSaveMode saveMode);
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              From this declaration, you can see that <code>ConfigurationSection</code> in turn inherits from the <code>
                ConfigurationElement
              </code> class. This is the reason why you can mix <code>&lt;sectionGroup&gt;</code> and <code>
                &lt;section&gt;
              </code> elements easily. The class contains several implemented methods and
              others that you must override to obtain the required behavior. The <code>SerializationSection</code> and <code>
                DeserializationSection
              </code> methods convert the settings to and from XML.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "General Considerations" >
        General Considerations
        <Element Type="Text">
          <p>
            All providers have certain
            characteristics in common. The base class, as already explained, forces few
            typical usage scenarios only. You should know some of the best practices for
            creating providers that fit well into the framework under all circumstances.
          </p>

        </Element>
        <Element Type="Section" Name = "Initialization Procedure of a Provider" >
          <Element Type="Text">

            <p>
              All providers derive from <code>ProviderBase</code>. Therefore, they inherit the <code>
                Initialize
              </code> method, which is declared <code>
                virtual
              </code>. In C#, this indicates a method that you need to override. Doing so
              transfers a few critical tasks over to you.
            </p>

            <p>
              Most providers need specific
              permissions to run. This is required either by access to a SQL database or
              local file system. The best way to implement permission checks is to add the appropriate
              attributes from the <code>
                System.Security.Permissions
              </code> namespace. Imagine that a provider is a pluggable module that
              others may re-use, even if it does not operate well. Instead of eventually failing
              in custom code, the initialization procedure should immediately report an
              exception indicating what went wrong. This is precisely the purpose of such
              permission attributes.
            </p>

            <p>
              Next, the <code>config</code> parameter passed to the <code>
                Initialize
              </code> method is important. If it is null, it means that something went
              wrong within the configuration. In that case, throw an <code>ArgumentNullException</code>, even if there are no configuration parameters required. The error
              indicates an unexpected condition and must be reported to the calling method.
            </p>

            <p>
              The base class’s <code>Initialize</code> method is not abstract. It contains code and must be called to
              ensure that basic requirements are met. As shown in the last section, the code validates
              the name and description settings. Even if you intend to change this, and you
              replace the name and description values in your code, call the base method. If a
              future version of the .NET framework adds code here to ensure required
              functionality, then failing to call the base class could break your provider.
            </p>

            <p>
              Reading the configuration is
              an important part. However, textual definitions, even if made in XML, can be
              error-prone. Use the <code>
                NameValueCollection
              </code> class and its indexer to access the configuration values. If a
              required parameter is missing, throw a <code>
                ProviderException
              </code>. Make sure you call <code>
                Remove
              </code>
              each time you read a parameter. That clears the <code>
                config
              </code> objects one by one. After all required parameters are processed
              nothing should be left in the <code>
                config
              </code>
              object. If <code>
                config.Count &gt; 0
              </code> is
              still <code>
                >true
              </code> throw a <code>ProviderException</code>. This ensures that you have all the required parameters and that
              the user has no other elements in the configuration that can’t be processed.
              You might wonder why you can’t just ignore these values. This is because the user’s
              intention was probably not to add private values to store additional
              information there. He or she has probably mistyped an attribute. The exception
              helps to recognize these typos instead of searching for the error in event
              logs.
            </p>

            <p>
              There are also best practices
              regarding provider code. Firstly, the service and the provider are two
              different things. Even if you develop them together in one project, with
              nothing else in mind, they should stay independent. Secondly, never call a
              method of the service from the provider. This could lead to infinite, recursive
              loops, or a break in modularity. Exchanging the provider would be impossible
              because it is tightly-bound to the service.      
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Lifetime" >
          <Element Type="Text">

            <p>
              Providers are loaded dynamically the
              first time the service requires them. This ensures that providers are not held
              in memory when they are not needed. However, loading a complex provider could
              be a time consuming task—clearly not desirable when you’re trying to improve the
              responsiveness of a site. You can force the provider to load by calling certain
              methods of the services in the <code>
                Application_Start
              </code> event.
            </p>

            <p>
              This assumes that the provider has a
              lifetime equaling the lifetime of the application and that the provider has a
              global state. A provider should not depend on the current session or the
              context. However, <code>
                HttpContext
              </code> and all subsequent classes can be used at any point to retrieve
              data. This makes it safe to use private fields to store values. It saves memory
              and speeds up the provider. However, you must remember to write thread-safe
              code.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Thread  Safety" >
          <Element Type="Text">

            <p>
              Threads in ASP.NET are explained in
              depth in Chapter 2. Web applications are multi-user applications—as with
              mainframe computer software, you can consider web applications as massively
              parallel applications. Consequently, when dealing with providers, you must
              handle threads with care. Providers are instantiated only once and shared across
              all requests. This speeds them up and causes them to consume less memory, which
              is necessary for basic tasks. Because threads run in parallel—that’s what
              threads are for—one provider might be called at the same time by multiple
              threads. This means that you must always code a provider to be thread-safe. Otherwise
              you risk throwing exceptions or creating garbage on any request. There are
              subtle differences that might appear under heavy workload only.
            </p>

            <p>
              The only exception is the <code>Initialize</code> method. Because it’s only called once, thread safety isn’t an issue.
              As long as the service initializes in <code>
                Application_Start,
              </code> this is always true. If you cannot be sure of this, the code that
              calls the method in the service has to be locked, as shown in the following
              code snippet:
            </p>

          </Element>
          <Element Type="Listing">

            if (_provider == null)
            {
               lock (_lock)
               {
                  if (_provider == null)
                  {

          </Element>
          <Element Type="Text">

            <p>
              This ensures that the provider
              is not loaded twice. The <code>
                lock
              </code> statement
              blocks other threads. However, another thread might have passed the lock and already
              be running inside the method. That’s why you must check the existence of the
              provider again after getting the lock.
            </p>

            <p>
              For property access, a similar
              technique is appropriate. Usually, you write your properties like this:
            </p>

          </Element>
          <Element Type="Listing">

            private Unit _size;
            public Unit Size
            {
               get { return _size; }
               set { _size = value; }
            }

          </Element>
          <Element Type="Text">

            <p>
              Imagine that two threads access this
              method. There is only one instance of this class in the memory and hence only one
              storage (memory place) for the value. If one thread writes the value and the
              other reads the value at the same time, you’ll receive an incorrect value back.
              The <code>
                >lock
              </code> statement is again the
              solution. It’s a shortcut to the <code>
                System.Threading.Monitor
              </code> class of the framework the compiler creates for us. The code should
              look like the following snippet:
            </p>

          </Element>
          <Element Type="Listing">

            private Unit _size;
            private object _synch
            public Unit Size
            {
               get { lock(_synch) { return _size;  } }
               set { lock(_synch) { _size = value; } }
            }

          </Element>
          <Element Type="Text">

            <p>
              The <code>Monitor</code> method is a very basic lock. It blocks all threads, even if they are
              being accessed for reading only. This could slow down an application under
              heavy load.
            </p>

            <p>
              There are several other ways
              to optimize the behavior. The <code>
                ReaderWriterLock
              </code> class improves behavior by allowing shared reads but preventing
              overlapping write and read access to the property. This improves performance if
              the values are mostly read rather than written.
            </p>

            <p>
              Another method uses the <code>System.Runtime.CompilerServices.MethodImplAttribute</code>. See the following code for a usage scenario:
            </p>
          </Element>
          <Element Type="Listing">
            private Unit _size;
            [MethodImpl(MethodImplOptions.Synchronized)]
            public Unit GetSize()
            {
               return _size;
            }

            [MethodImpl(MethodImplOptions.Synchronized)]
            public void SetSize(Unit size)
            {
               _size = size;
            }

          </Element>
          <Element Type="Text">

            <p>
              However, this replaces
              properties with methods, which isn’t the best coding style. The locking experience
              isn’t any better. The compiler also uses the <code>
                Monitor
              </code> method. As you can see from the code snippet, there is no object
              for storing the locking state. The compiler selects an object at the best
              level, like <code>
                lock(this)
              </code>. This could
              be an object on either the type or application level, which is a higher level
              than within the method. Usually this means that the locking phase is longer, and
              this causes the threads to last longer. Unless locking on type level is
              required, this attribute is not appropriate for providers.
            </p>

            <p>
              Which method is best will
              depend on the specific conditions. Generally, you have to ensure thread-safe
              access to all instance data, including private fields. However, when you write
              configuration data in the <code>
                Initialize
              </code> method (thread-safe because it’s only called once) and provide read-only
              access, no action is required to ensure thread safety. The <code>get</code> statement of the property shown in the last code snippets might
              omit the lock statement, then.
            </p>

            <p>
              Calls to access all stack-based
              data and local variables within a property or method should not be locked. 
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Creating a Custom Provider-Based Service" >
        Creating a Custom Provider-Based Service
        <Element Type="Text">

          <p>
            Images are an essential part of almost
            all web applications. Powerful image management makes your life and your users’
            lives easier. Imagine that your final storage solution isn’t clearly defined
            and so you want to create a flexible and extensible image management solution.
            Other developers in your organization should be able to adopt your code and
            replace parts of it to suit their needs without knowing the internal details of
            the image creation and delivery process. In such a situation, you could
            consider a custom provider-based service. Again, the multi-tier model points to
            a solution:
          </p>
          <ol>
            <li>You need to create a service that is able to retrieve and send image data</li>
            <li>You need a provider interface that makes data storage access replaceable</li>
            <li>You need a specific provider to put it into operation</li>
            <li>
              You need a configuration definition to handle the configuration in <i>web.config</i>
            </li>
          </ol>
          <p>
            Following the model of the provider as
            described in the previous sections, you should create these classes:
          </p>
          <ul>
            <li>
              An implementation of a
              configuration section definition class
            </li>
            <li>
              An abstract base class that describes
              the provider
            </li>
            <li>
              An implementation of this base class
              that creates the provider that serves as a concrete implementation against data
              storage
            </li>
            <li>
              A class that implements the service
              to do anything useful using the provider
            </li>
            <li>
              A provider collection class that
              stores multiple providers
            </li>
          </ul>
          <p>
            Additionally, data storage must
            be provided. Because it’s common to use SQL Server, I’ll create the image
            service’s default provider using a SQL Server database.
          </p>

          <p>
            You can build such a solution from
            the bottom up, beginning with the configuration, followed by the provider and
            finally the service. This is fine if you have a design and planning phase in
            your project and clearly defined requirements. However, for learning purposes, you’ll
            create a provider from the top down and start with the last step—the service.
            This clarifies the purpose of the provider and makes the next steps easier to
            understand.
          </p>

        </Element>
        <Element Type="Section" Name = "Limitations of the Code Samples" >
          <Element Type="Text">

            <p>
              Depending on real-life requirements, creating
              a provider-based solution might require a little more effort. Remember that, for
              the sake of clarity, all the code snippets here lack error handling, unit testing
              and logging features. In addition, no code snippets here feature localization. The
              best practice is to store resources in resource files and to localize if the
              application is used in multiple countries. See Chapter 5 for more information
              about resources.
            </p>

            <p>
              Certain samples in this chapter
              access databases. If you are writing more sophisticated providers, you may have
              multiple database operations for one action. When the database supports
              transactions use transactions to ensure the atomicity of updates. Transactions ensure
              a rollback if one of the database operations fails. If the database does not
              inherently support transactions, you must ensure the atomicity within your own
              code. Add <code>try</code>/<code>catch</code> blocks and check conditions to the code shown here.
            </p>

            <p>
              Some sample code regarding
              providers in this and the next few chapters shows only one part of the provider
              to explain specific techniques. Any methods or properties that are not
              implemented have been omitted for the sake of clarity and simplicity. However,
              for production code you should add a <code>
                NotImplementedException
              </code> to redundant methods. This verifies that users of the provider only
              implement the features you intended. If completeness is not required, don’t
              forget to explain this in the documentation as well.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Creating a Service" >
          <Element Type="Text">

            <p>
              The purpose of the sample service is to
              retrieve an image via the <code>
                RetrieveImage
              </code> method. All the other service properties and methods are required
              to set up the provider. The provider allows other developers using the service to
              replace the default provider with their own version. For instance, you could
              choose to use the file system on a file server to store images instead of the
              database. No change would be required in the application or the service
              implementation.
            </p>

            <p>Let’s take a look at the class itself.</p>

          </Element>
          <Element Type="Listing" Name="The service itself is able to retrieve an image">

            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using System.Web.Configuration;
            using System.Configuration.Provider;
            using System.Drawing;

            namespace Apress.Extensibility.CustomProvider
            {
              public class ImageService
              {
                private static ImageProvider _provider = null;
                private static ImageProviderCollection _providers = null;
                private static object _lock = new object();

                public ImageProvider Provider
                {
                  get { return _provider; }
                }

                public ImageProviderCollection Providers
                {
                  get { return _providers; }
                }

                public static Image RetrieveImage(int imageID)
                {

                  LoadProviders();
                  return _provider.RetrieveImage(imageID);
                }

                private static void LoadProviders()
                {

                  if (_provider == null)
                  {
                    lock (_lock)
                    {
                      if (_provider == null)
                      {

                        object[] attributes = typeof(ImageProviderSection).GetCustomAttributes(typeof(SectionAttribute), false);
                        if (attributes.Length != 1)
                             throw new ConfigurationException(&quot;SectionAttribute not set&quot;);
                        SectionAttribute sa = (SectionAttribute)attributes[0];
                        ImageProviderSection section = (ImageProviderSection) WebConfigurationManager.GetSection(sa.SectionName);
                        _providers = new ImageProviderCollection();
                      ProvidersHelper.InstantiateProviders(section.Providers, _providers, typeof(ImageProvider));
                        _provider =_providers[section.DefaultProvider];
                        if (_provider == null)
                          throw new ProviderException(&quot;Unable to load default ImageProvider&quot;);
                      }
                    }
                  }
                }
              }
            }

          </Element>
          <Element Type="Text">

            <p>
              The <code>RetrieveImage</code> method is static, because we don’t need to handle multiple
              instances of the service. Although the configuration allows multiple providers,
              only one can act as the current provider. The other parts of the code interact
              with this current provider. In this application, the service class is created
              once and starts working when the <code>
                LoadProviders
              </code> method is called.
            </p>

            <p>
              Each method launches with a
              call to the <code>
                LoadProviders
              </code> method to
              ensure that a provider is present when retrieving data. Loading the provider is
              a one-time operation. To avoid claiming the lock if providers are already
              loaded, the first action is checking the <i>_provider</i> variable. After
              claiming the lock, this test is made again to ensure the provider is still not
              loaded. This is required as parallel running requests might invoke the service
              and start a duplicate procedure.
            </p>

            <p>
              In the next step, the name of the section is retrieved by reading a private attribute.
              There are several ways to do this. Using an attribute allows a single location
              definition. The section configuration, which provides the necessary information,
              is the only class where the definition is used. Using data from the <code>SectionAttribute</code> attribute, it’s possible to get a reference to the <code>&lt;imageService&gt;</code> section we use to define the current provider. Then the code loads all the registered providers and points <i>_provider</i> to the default provider to make it the
              current one. <code>
                ProviderHelper
              </code> is a
              static class in the <code>
                System.Web.Configuration
              </code> namespace that simplifies the process.
            </p>

            <p>
              If anything goes wrong, an
              exception is raised to inform the calling code. If everything is fine, the <code>
                ImageService
              </code> class will
              be ready to serve images.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Creating the Provider" >
          <Element Type="Text">
            <p>
              The provider consists of two classes. One
              is an abstract base class that extends the <code>
                ProviderBase
              </code> class with the required additional methods. The other is the
              implementation of that class. Again, this provider is just one implementation
              to bring the whole solution into operation. Other developers could replace this
              provider with their own creation and extend the behavior of the service at
              will.
            </p>
          </Element>
          <Element Type="Listing" Name="The base class for the provider">
            using System.Configuration.Provider;
            using System.Drawing;

            namespace Apress.Extensibility.CustomProvider
            {

                public abstract class ImageProvider : ProviderBase
                {

                    public abstract string ApplicationName { get; set; }
                    public abstract Image RetrieveImage(int id);
                }
            }
          </Element>
          <Element Type="Text">

            <p>
              This class has two
              characteristics. It must inherit the <code>
                ProviderBase
              </code> in order to be recognized as a provider in other parts of the
              application. It must also define the methods that serve the service. In this
              case, <code>
                >RetrieveImage
              </code> is such a
              method. The service knows that it can call this method to get an image, and the provider completes the process.
            </p>

            <p>
              Now the implementation is
              required. Because we want to pull the images from a database, some preparation
              are needed. Assuming you have local database, <i>aspnetdb</i>, with integrated
              security, add the following table there:
            </p>

          </Element>
          <Element Type="Image" Name="The table that stores the images (See Listing 4.4 for corresponding T-SQL script)">
            images/ASPEXTf0401.tif
          </Element>
          <Element Type="Text">

            <p>
              Internally, we use LINQ to SQL to
              retrieve the image information from the specified table. The table does not
              actually contain the images. It contains paths to the image folders and allows
              further management of the relationship between resources requesting the images.
              The data storage method leads to the first requirement of the provider: it must
              store a connection string. It’s a good idea to use the predefined <code>&lt;connectionString&gt;</code> section in <i>web.config</i> and only handle the name that
              references it.
            </p>

            <p>
              Next, look into the provider
              code.
            </p>

          </Element>
          <Element Type="Listing" Name="The implementation of the provider">

            using System;
            using System.Collections.Specialized;
            using System.Configuration.Provider;
            using System.Data.SqlClient;
            using System.Drawing;
            using System.Linq;
            using System.Security.Permissions;
            using System.Web;
            using System.Web.Configuration;

            namespace Apress.Extensibility.CustomProvider
            {

                [SqlClientPermission(SecurityAction.Demand, Unrestricted = true)]

                public class SqlImageProvider : ImageProvider
                {

                    public override string ApplicationName
                    {
                        get;
                        set;
                    }

                    public string ConnectionString
                    {
                        get;
                        set;
                    }

                    public override void Initialize(string name, NameValueCollection config)
                    {

                        if (config == null)
                            throw new ArgumentNullException(&quot;config&quot;);
                        if (String.IsNullOrEmpty(name))
                            name = &quot;SqlImageProvider&quot;;

                        if (string.IsNullOrEmpty(config[&quot;description&quot;]))
                        {              
            config.Remove(&quot;description&quot;);
            config.Add(&quot;description&quot;, &quot;SQL image provider&quot;);
                        }
                        base.Initialize(name, config);

                        ApplicationName = config[&quot;applicationName&quot;];
                        if (string.IsNullOrEmpty(ApplicationName))
                            ApplicationName = &quot;/&quot;;          
            config.Remove(&quot;applicationName&quot;);

                        string connect = config[&quot;connectionStringName&quot;];

                        if (String.IsNullOrEmpty(connect))
                            throw new ProviderException(&quot;Empty or missing connectionStringName&quot;);
                      
            config.Remove(&quot;connectionStringName&quot;);

                        if
            (WebConfigurationManager.ConnectionStrings[connect] == null)

                            throw new
            ProviderException(&quot;Missing connectionStringName&quot;);

                        ConnectionString =
            WebConfigurationManager.

                                              
            ConnectionStrings[connect].ConnectionString;

                        if
            (String.IsNullOrEmpty(ConnectionString))

                            throw new ProviderException(&quot;Empty
            connection string&quot;);

                        if (config.Count &gt; 0)

                        {
                            string attr = config.GetKey(0);

                            if (!String.IsNullOrEmpty(attr))

                                throw new ProviderException                                (&quot;Unrecognized
            attribute: &quot; + attr);

                        }
                    }

                    public override Image RetrieveImage(int id)
                    {
                        ImageDataDataContext ctx = new ImageDataDataContext(ConnectionString);
                        var qr = from i in ctx.aspnet_Configurations
                                   where i.cfg_category == &quot;ImageProvider&quot;

                                      &amp;&amp; i.cfg_id == &amp;&amp; i.cfg_type == &quot;image&quot;
                                   select i.cfg_content;

                       string data = qr.FirstOrDefault&lt;string&gt;();
                       Image img = Image.FromFile(HttpContext.Current.Server.MapPath(data));
                       return img;
                    }
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              The life of a provider begins
              with the call to its <code>
                Initialize
              </code> method. The first step is to verify that <code>config</code> is not <code>
                null
              </code>.
              If so, an exception is thrown. Remember that configuration is essential for the
              provider model. As other parts of the configuration might reference the
              provider, it needs a name. Assign the provider a default name if it doesn’t
              have one. In the example, it’s called “SqlImageProvider". It’s the same for the
              description. Even if the description is optional, it should be set properly.
              Several graphical tools might refer to the description. If the attribute
              “description" doesn’t exist, the code creates one.
            </p>

            <p>
              Secondly, the base class’s <code>Initialize</code> method is called. The provider retrieves the <code>applicationName</code> and <code>
                connectionStringName
              </code>attributes from the configuration file. If the applicationName
              doesn’t exists we assume it is the root application “/". The connection string
              is mandatory and the lack of it throws an exception. Now, the provider instance
              should have all the information required to operate. The code checks for the remaining
              configuration attributes. As explained in the best practice sections, the check— <code>
                if (config.Count &gt; 0)
              </code>—ensures that unrecognized attributes are reported to the user in
              order to avoid typos.
            </p>

            <p>
              Next, the <code>RetrieveImage</code> method must be implemented. The <code>
                ImageDataDataContext
              </code> is a class created with the LINQ to SQL wizard. To create this
              class, follow these steps:
            </p>
            <ol>
              <li>
                In Visual Studio choose <i>Add &gt; New Item</i> in the context menu of the solution
              </li>
              <li>
                In section <i>Data</i> of the <i>Add New Item</i> dialog choose <i>LINQ to SQL Classes</i> item
              </li>
              <li>
                Give the item a common name, such as <i>ImageData.dbml</i>
              </li>
            </ol>
          </Element>
          <Element Type="Image" Name="Add a LINQ to SQL item to the provider project">
            images/ASPEXTf0402.tif
          </Element>
          <Element Type="Text">

            <p>
              Close the dialog and an empty designer
              surface will appear. Open the Server Explorer (View &gt; Server Explorer, or
              press Ctrl+Alt+S instead) and add a connection to your database. Either it will
              already be present or you’ll have to add the database and the appropriate
              tables. The full script for the table is shown in Listing 4.4.
            </p>

          </Element>
          <Element Type="Listing" Name="SQL table definition for the provider project">

            CREATE TABLE [dbo].[aspnet_Configuration](
                            [cfg_id] [int] IDENTITY(1,1) NOT NULL,
                            [cfg_key] [varchar](50) NOT NULL,
                            [cfg_category] [varchar](50) NOT NULL,
                            [cfg_type] [varchar](10) NOT NULL,
                            [cfg_content]
            [varchar](max) NULL,

            CONSTRAINT [PK_aspnet_Configuration] PRIMARY KEY CLUSTERED
            (
                            [cfg_id] ASC
            )WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE 
            = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON
            [PRIMARY]

            ) ON [PRIMARY]

          </Element>
          <Element Type="Text">

            <p>
              This is just a simple example of a
              storage method. Real life projects tend to be more sophisticated. Once the
              table exists, and the Server Explorer shows the server, you can add a
              connection. Choose the icon <i>Data Connections</i> and <i>Add Connection</i>
              from the context menu, then, in the following dialog, choose the server. If you
              use a local SQL Express Edition, the name might look like ./SQLEXPRESS. Select
              the database where you have created the table. Test the connection and close
              the dialog to add the connection.
            </p>

          </Element>
          <Element Type="Image" Name="Adding a connection to the current project">
            images/ASPEXTf0403.tif
          </Element>
          <Element Type="Text">

            <p>
              You can now drag and drop the
              table onto the designer surface of the LINQ to SQL class. The result should look
              like the image already shown in Figure 4.2. Based on the class’s name, the
              designer will create a context file. If the name is <i>ImageData,</i> the data
              context is called <i>ImageDataDataContext</i> (DataContext is the suffix). The
              context contains a property called <code>
                aspnet_Configurations
              </code>, which represents the table. If you have named the table
              differently, the property will have that name. Using the context, you can use
              simple LINQ statements to query the database, as shown in the <code>RetrieveImage</code> method.
            </p>

            <p>
              In the example, the image is
              retrieved based on its Id, the category “ImageProvider", and the type “image".
              This is only a suggestion. Based on the retrieved name, the <code>Server.MapPath</code> method is used to obtain the full path to the image. The <code>Image.FromFile</code> creates the image in memory for further processing.
            </p>

            <p>
              Imagine another provider that
              simply takes the image and creates a thumbnail of it. In a derived class, you
              could override the <code>
                RetrieveImage
              </code> method, call the base class, get the image, and manipulate it to
              create a thumbnail. The configuration is already able to change the provider.
              This shows once more the power of the provider architecture.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Configuring Providers" >
          <Element Type="Text">

            <p>
              The next step is to implement the
              configuration support. Because many providers can serve a single service, a
              collection is appropriate. The next code listing shows a simple implementation
              based on the abstract base class, <code>
                ProviderCollection
              </code>.
            </p>

          </Element>
          <Element Type="Listing" Name="The provider collections represents all configured providers">

            using System;
            using System.Configuration.Provider;

            namespace Apress.Extensibility.CustomProvider
            {
                public class ImageProviderCollection : ProviderCollection
                {

                    public ImageProvider this[string name]
                    {
                        get
                        {
                            return base[name] as ImageProvider;
                        }
                    }

            public override void Add(ProviderBase provider)
                    {

                        if (provider == null)
                            throw new ArgumentNullException(&quot;provider&quot;);
                        if (!(provider is ImageProvider))
                            throw new ArgumentException
                            (&quot;Invalid provider type&quot;, &quot;provider&quot;);
                        base.Add(provider);
                    }
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              There are only two features.
              You can add providers of the <code>
                ImageProvider
              </code> type and retrieve them using an indexer. The base class handles all
              the other features. The method and property shown above ensure the integrity of
              the base class type. This means that you won’t be able to add a provider to the
              configuration section which does not serve the service.
            </p>

            <p>
              The last step required in order to
              operate the service is to define the configuration section.
            </p>

          </Element>
          <Element Type="Listing" Name="The configuration section and the supporting custom attribute">

            using System;
            using System.Configuration;

            namespace Apress.Extensibility.CustomProvider
            {

                [AttributeUsage(AttributeTargets.Class)]
                public class SectionAttribute : Attribute
                {

                    public SectionAttribute(string sectionName)
                        : base()
                    {
                        SectionName = sectionName;
                    }

                    public string SectionName
                    {
                        get;
                        set;
                    }
                }
               
            [Section(&quot;system.web/imageService&quot;)]

                public class ImageProviderSection : ConfigurationSection
                {

                   
            [ConfigurationProperty(&quot;providers&quot;)]

                    public ProviderSettingsCollection Providers
                    {
                        get { return (ProviderSettingsCollection)base[&quot;providers&quot;]; }
                    }
                   [StringValidator(MinLength = 1)]
                    [ConfigurationProperty(&quot;defaultProvider&quot;,  = &quot;SqlImageProvider&quot;)]
                    public string DefaultProvider
                    {
                        get { return (string)base[&quot;defaultProvider&quot;]; }
                        set { base[&quot;defaultProvider&quot;] = value; }
                    }
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              As suggested before, a custom
              attribute helps to get a single location definition of the configuration path—like
              “system.web/imageService" in this example. The custom <code>SectionAttribute</code> attribute does not involve anything special. It is used to decorate
              the <code>
                >ImageProviderSection
              </code> class,
              which contains two properties, a collection of providers, and the name of the
              default provider.
            </p>

            <p>
              This results in configuration
              code which could look like this:
            </p>
          </Element>

          <Element Type="Listing" Name="">

            &lt;system.web&gt;

              &lt;imageService
            defaultProvider=&quot;&quot;&gt;

               &lt;providers&gt;

                 &lt;clear/&gt;

                 &lt;add … /&gt;
               &lt;/providers
              &lt;/imageservice&gt;
            &lt;/system.web&gt;

          </Element>
          <Element Type="Text">
            <p>
              The <code>ConfigurationProperty</code> attribute declares the elements in the <i>web.config</i> file. Although
              it follows the pattern of all provider-based definitions in the configuration,
              you’re free to choose different definitions. However, the best practice is to
              follow this pattern.
            </p>

            <p>
              This is all you need to know in
              order to write your own provider configuration sections.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Using the Service" >
          <Element Type="Text">

            <p>
              This service can be used by any code in
              the application. In chapter 3, you saw how to use handlers to manage images.
              Let’s create a handler which uses our <i>ImageService</i>. Start with a simple <i>.aspx</i>
              page which uses a handler, as shown in the next code listing.
            </p>

          </Element>

          <Element Type="Listing" Name="Listing 4.7 A simple page that calls the handler">

            &lt;%@ Page Language=&quot;C#&quot;
            AutoEventWireup=&quot;true&quot;

                     CodeFile=&quot;Default.aspx.cs&quot;
            Inherits=&quot;_Default&quot; %&gt;

            &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML
            1.0 Transitional//EN&quot;

                                 
            &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;

            &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;

            &lt;head runat=&quot;server&quot;&gt;

                &lt;title&gt;&lt;/title&gt;

            &lt;/head&gt;

            &lt;body&gt;
                &lt;form id=&quot;form1&quot;
            runat=&quot;server&quot;&gt;

                &lt;div&gt;

                    &lt;asp:Image runat=&quot;server&quot;
            ID=&quot;Image2&quot; ImageUrl=&quot;~/ImageHandler.ashx?id=4&quot; /&gt;
                    &lt;br /&gt;

                    &lt;asp:Image runat=&quot;server&quot;
            ID=&quot;Image1&quot; ImageUrl=&quot;~/ImageHandler.ashx?id=9&quot; /&gt;

                &lt;/div&gt;

                &lt;/form&gt;

            &lt;/body&gt;

            &lt;/html&gt;
          </Element>
          <Element Type="Text">

            <p>
              The <i>ImageHandler.ashx</i> file is a
              generic handler that doesn’t need to be assigned in IIS. The parameter id
              corresponds to the Id column in the image resource table. This is a simplified
              scenario. In real-life applications, it would be better to use readable strings
              to define the resources. However, for learning purposes, these code snippets are
              as short and easy as possible.
            </p>

            <p>
              The handler calls the service’s static
              method to retrieve the image and adds the <code>
                Image
              </code> object to the output stream.
            </p>

          </Element>

          <Element Type="Listing" Name="The image handler that uses the configurable service">

            &lt;%@ WebHandler Language=&quot;C#&quot;
            Class=&quot;ImageHandler&quot; %&gt;

            using System;

            using System.Web;

            using System.Drawing;

            using System.Drawing.Imaging;

            using Apress.Extensibility.CustomProvider;

            public class ImageHandler : IHttpHandler
            {

                public void ProcessRequest(HttpContext
            context)
                {

                    int id;

                    if (context.Request.QueryString[&quot;id&quot;]
            != null)

                    {

                        if
            (Int32.TryParse(context.Request.QueryString[&quot;id&quot;], out id))

                        {

                            Image img =
            ImageService.RetrieveImage(id);

                            context.Response.ContentType =
            &quot;image/jpg&quot;;

                           
            img.Save(context.Response.OutputStream, ImageFormat.Jpeg);

                        }

                    }

                }

                public bool IsReusable                {

                    get
                    {

                        return true;

                    }
                }

            }

          </Element>
          <Element Type="Text">

            <p>
              Within the <code>ProcessRequest</code> method, the handler attempts to retrieve the id from the <code>QueryString</code> property. If the id is present and is a number, the service class <code>ImageService</code> retrieves the image using the <code>
                RetrieveImage
              </code> method. Finally, the right content type is set and the image is
              streamed into the <code>
                OutputStream
              </code> property using the <code>
                Save
              </code>
              method.
            </p>
            <p>
              The last step—the handler—is our
              target usage scenario. This is why we’ve written the configuration, the service
              and the provider.
            </p>

            <p>
              Any developer can use the
              handler to retrieve images. They only need to know how to use one specific
              parameter (the image id). They don’t need to know how the image is created.
              This is part of the service. Moreover, they don’t need to know how the image is
              stored. This is the role of the provider. These three parts form a multi-tier
              model:
            </p>
            <ul>
              <li>
                Tier one—the user interface
                support layer—is created by the handler
              </li>
              <li>
                Tier two—the business logic—is contained
                in the service
              </li>
              <li>
                Tier three—the data storage—is
                handled by the provider
              </li>
            </ul>
            <p>
              The provider model is a distinct way of
              creating a multi-tier architecture within your application. It makes the
              application flexible and extensible, and it simplifies the writing of unit
              tests, logging, and supervision by splitting a monolithic block of code into
              smaller chunks.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Extending the Configuration" >
        Extending the Configuration
        <Element Type="Text">
          <p>
            In the previous sections, you learned how
            to extend the provider model and configure the provider using the <i>web.config</i>
            file. The extensibility of parts of the <i>web.config</i> is not limited to
            configuring providers. Using the base classes within the <code>System.Configuration</code> namespace, you can create custom sections and handle them directly.
            If the settings defined in <code>
              &lt;AppSettings&gt;
            </code> are too limited for your application’s needs, you can extend them.
          </p>
        </Element>
        <Element Type="Section" Name = "How to Scaffold a Configuration Section" >
          How to Scaffold a Configuration Section
          <Element Type="Text">
            <p>
              The first step is to add a reference to
              the <i>System.Configuration.dll</i> assembly and the <code>System.Configuration</code> namespace. Creating a new project of type class library for the new
              configuration definition is not required, but recommended. This makes the code
              reusable and easier to test and deploy. Before you start creating a section like
              this, it’s worth examining the anatomy of a configuration section.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Anatomy of a configuration section" >
          Anatomy of a configuration section
          <Element Type="Text">
            <p>
              The configuration section is based on
              the implementation of two abstract classes, <code>
                ConfigurationSection
              </code> and <code>
                ConfigurationElement
              </code>. <code>
                ConfigurationSection
              </code> is
              a successor of <code>
                ConfigurationElement
              </code>
              that makes it easy to create hierarchies of sections that contain elements on
              each level. The concrete <code>
                ConfigurationSection
              </code> is defined at the top of the <i>web.config</i> file, as shown in Listing
              4.9:
            </p>
          </Element>
          <Element Type="Listing" Name="Definition of private configuration sections">
            &lt;configSections&gt;
              &lt;sectionGroup Name=&quot;system.web.extensions&quot; type=&quot;…&quot;&gt;
                &lt;sectionGroup Name=&quot;scripting&quot; type=&quot;…&quot;&gt;
                  &lt;section Name=&quot;scriptResourceHandler&quot; type=&quot;…&quot;
            requirePermission=&quot;false&quot;
            allowDefinition=&quot;MachineToApplication&quot;/&gt;
                  &lt;sectionGroup
            Name=&quot;webServices&quot; type=&quot;…&quot;&gt;

                    &lt;section
            Name=&quot;jsonSerialization&quot; type=&quot;…&quot;
            requirePermission=&quot;false&quot;

                            
            allowDefinition=&quot;Everywhere&quot; /&gt;

                    &lt;section
            Name=&quot;profileService&quot; type=&quot;…&quot;
            requirePermission=&quot;false&quot;

                            
            allowDefinition=&quot;MachineToApplication&quot; /&gt;

                    &lt;section Name=&quot;…&quot;
            requirePermission=&quot;false&quot;

                             allowDefinition=&quot;MachineToApplication&quot;
            /&gt;

                    &lt;section Name=&quot;roleService&quot;
            type=&quot;…&quot; requirePermission=&quot;false&quot;

                            
            allowDefinition=&quot;MachineToApplication&quot; /&gt;
                  &lt;/sectionGroup&gt;
                &lt;/sectionGroup&gt;
              &lt;/sectionGroup&gt;
            &lt;/configSections&gt; 
          </Element>
          <Element Type="Text">
            <p>
              The <code>
                type
              </code> attributes are empty for the sake of clarity. They contain the fully
              qualified assembly names of the type that holds the configuration definition.
              The top-level element, <code>
                &lt;sectionGroup&gt;
              </code>, defines in which group the new element appears:
            </p>
            <pre>
              &lt;sectionGroup Name=&quot;system.web.extensions&quot;&gt;
            </pre>
            <p>
              The section <code>&lt;system.web.extensions&gt;</code> is thus defined as the location for all subsequent groups,
              elements, or any combinations of groups and elements. You can define exactly what
              appears there simply by implementing the base classes mentioned above.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "The Class Model" >
          The Class Model
          <Element Type="Text">
            <p>
              Figure 4.5 shows the complete class
              model behind the configuration classes. To create a private configuration
              section, you’ll need to implement these abstract classes.
            </p>
          </Element>
          <Element Type="Image" Name="Base classes for a custom configuration">
            images/ASPEXTf0404.tif
          </Element>
          <Element Type="Text">

            <p>
              The <code>ConfigurationSection</code> and <code>
                ConfigurationElement
              </code> classes are the most important. Many elements will allow
              collections. Collections define tags such as <code>
                &lt;add&gt;
              </code>, <code>
                &lt;remove&gt;
              </code>, and <code>&lt;clear&gt;</code> to handle multiple elements in XML. The corresponding definition in
              this code is based on the <code>
                ConfigurationElementCollection
              </code> class.
            </p>

            <p>
              These classes form the structure
              of the configuration elements. You can refine their behavior by adding
              attributes. Attributes not only decorate the properties that define elements,
              but also add features in order to:
            </p>
            <ul>
              <li>Validate scalar data</li>
              <li>Define custom validation methods</li>
              <li>Set a default if the value is not set</li>
              <li>
                Define a subclass’s type to
                refine the elements hierarchy
              </li>
            </ul>

          </Element>
        </Element>
        <Element Type="Section" Name = "Attributes to Control Elements’ Behaviors" >
          Attributes to Control Elements’ Behaviors
          <Element Type="Text">

            <p>
              The following table shows all the attributes
              available to define the behavior of properties.
            </p>

          </Element>
          <Element Type="Table" Name="Validator attributes that control the validation">
            <table>
              <tr>
                <th>Validator</th>
                <th>Purpose of this Attribute</th>
              </tr>
              <tr>
                <td>
                  <code>IntegerValidator</code>
                </td>
                <td>
                  Checks whether the element’s value is of type <code>Int32</code>.
                </td>
              </tr>
              <tr>
                <td>
                  <code>LongValidator</code>
                </td>
                <td>
                  Checks
                  whether the element’s value is of type <code>Int64</code>.
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    StringValidator
                  </code>
                </td>
                <td>
                  Checks
                  specific string conditions such as minimum and maximum <code>Length</code>. It’s even possible to define forbidden character (for paths, for
                  instance).
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    RegexStringValidator
                  </code>
                </td>
                <td>
                  Defines
                  a regular expression the element’s value must match.
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    CallbackValidator
                  </code>
                </td>
                <td>
                  Defines
                  a callback method that is responsible for checking the value.
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    TimespanValidator
                  </code>
                </td>
                <td>
                  Checks
                  time conditions, declares usually a valid range.
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    PositiveTimespanValidator
                  </code>
                </td>
                <td>Checks time conditions, usually a positive range (ahead in time).</td>
              </tr>

              <tr>
                <td>
                  <code>SubclassTypeValidator</code>    
                </td>
                <td>Defines the Type of a class this element must derive from.</td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              The following attributes refine the
              configuration element properties at a Meta level. They can be used together and
              with the <code>
                >Validator
              </code> attributes in any
              combination.
            </p>

          </Element>
          <Element Type="Table" Name="Attributes to refine the configuration elements’ behavior">
            <table>
              <tr>
                <th>Attribute</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>
                    DefaultValue
                  </code>
                </td>
                <td>
                  The
                  default value. If defined, this value is used if no other value is assigned.
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    IsDefaultCollection
                  </code>
                </td>
                <td>
                  True,
                  if this element represents a collection.
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    IsRequired
                  </code>
                </td>
                <td>
                  True,
                  if the element is mandatory.
                </td>
              </tr>
              <tr>
                <td>
                  <code>
                    IsKey
                  </code>
                </td>
                <td>
                  True, if this
                  is the key element of a collection. Applies only if it is a collection.
                </td>
              </tr>
              <tr>
                <td>
                  <code>Options=''</code>  A combination of the <code>IsKey=''</code>, <code>IsRequired</code>, and <code>IsDefaultCollection</code>
                </td>
                <td>
                  elements as a flagged enum.
                </td>
              </tr>
            </table>
          </Element>
        </Element>
        <Element Type="Section" Name = "Definition of a Simple Configuration Section" >
          <Element Type="Text">
            <p>
              Now that we have all the parts of the puzzle
              handy, we can start creating a real-life example which defines a customized
              configuration section. First, let’s take a look at the section definition. The
              following code defines a section with two new elements.
            </p>

          </Element>
          <Element Type="Listing" Name="A section with two elements">

            using System;
            using System.Collections;
            using System.Text;
            using System.Configuration;
            using System.Xml;

            namespace Apress.Extensibility.Configuration
            {
                public class PageAppearanceSection : ConfigurationSection
                {

                    [ConfigurationProperty(&quot;remoteOnly&quot;, DefaultValue = &quot;false&quot;, IsRequired = false)]
                    public Boolean RemoteOnly
                    {
                        get
                        {
                            return (Boolean)this[&quot;remoteOnly&quot;];
                        }
                        set
                        {
                            this[&quot;remoteOnly&quot;] = value;
                        }
                    }

            [ConfigurationProperty(&quot;font&quot;)]
                    public FontElement Font
                    {

                        get
                        {
                            return (FontElement)this[&quot;font&quot;];
                        }

                        set
                        { this[&quot;font&quot;] = value; }

                    }

            [ConfigurationProperty(&quot;color&quot;)]
                    public ColorElement Color
                    {
                        get
                        {
                            return (ColorElement)this[&quot;color&quot;];
                        }
                        set
                        { this[&quot;color&quot;] = value; }

                    }
                }

          </Element>
          <Element Type="Text">

            <p>
              This class defines three
              allowed properties. The property <code>

                RemoteOnly=""
              </code> is of type Boolean and doesn’t need any additional definition, beyond
              declaring it as a <code>
                ConfigurationProperty
              </code>.
            </p>

            <p>
              If you have a more complex
              class and wish to distinguish between private properties and those exposed to
              the configuration manager, this requires an additional attribute. The two named
              properties set in the attribute’s constructor (<code>

                DefaultValue=""
              </code> and <code>
                IsRequired
              </code>) are explained in Table 4.5. For the other elements (<code>Font</code> and <code>
                Color
              </code>),
              you’ll need to create our own structures. This means that an element of type <code>&lt;font&gt;</code> should contain specific attributes, just as for <code>&lt;color&gt;</code>.
            </p>

            <p>
              The definition of the <code>FontElement</code> class demonstrates this.
            </p>
          </Element>
          <Element Type="Listing" Name="The FontElement class defines a single element that represents a font">

            public class FontElement :
            ConfigurationElement            {

                [ConfigurationProperty(&quot;name&quot;,
            DefaultValue = &quot;Arial&quot;, IsRequired = true)]

                [StringValidator(InvalidCharacters =
            &quot;~!@#$%^&amp;*()[]{}/;'\&quot;|\\&quot;, 

                                  MinLength = 1, MaxLength =
            60)]

                public String Name                {

                    get
                    {

                        return
            (String)this[&quot;name&quot;];

                    }

                    set                    {

                        this[&quot;name&quot;] = value;

                    }

                }
                [ConfigurationProperty(&quot;size&quot;,
            DefaultValue = &quot;12&quot;, IsRequired = false)]

                [IntegerValidator(ExcludeRange = false,
            MaxValue = 24, MinValue = 6)]

                public int Size                {

                    get                    { return (int)this[&quot;size&quot;]; }

                    set                    { this[&quot;size&quot;] = value; }

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              For the font’s name, a <code>StringValidator</code> is used. It limits the length to between 1 and 60. The name is not
              allowed to contain several characters. The font’s size is limited with an <code>IntegerValidator</code>. <code>
                ExcludeRange
              </code> defines
              whether the values provided as <code>
                MaxValue
              </code> and <code>
                MinValue
              </code> are part of the range or not. Here, the range is between 6 and 24,
              including the values “6" and “24" respectively.
            </p>

            <p>
              The access to the underlying
              configuration element is through an indexer. The code behind this serializes
              and deserializes the values to create a link between the element’s name and its
              attribute in code. This means that the values used as keys for the indexer (&quot;size&quot;
              and &quot;name&quot; respectively) are responsible for retrieving the
              configuration’s XML. In the string <code>

                &lt;font size=&quot;12&quot;&gt;,
              </code> the name of the attribute “size" is defined by <code>this[&quot;size&quot;]</code> and made accessible in the code via the <code>Size</code> property. Although it’s highly recommended to use the same names,
              there is no technical restriction on changing them.
            </p>

            <p>
              The color element operates
              similarly:
            </p>

          </Element>
          <Element Type="Listing" Name="The ColorElement class defines a single element that represents a color value">

            public class ColorElement :
            ConfigurationElement            {

              
            [ConfigurationProperty(&quot;background&quot;, DefaultValue =
            &quot;FFFFFF&quot;, IsRequired = true)]

               [StringValidator(

                          InvalidCharacters=&quot;~!@#$%^&amp;*()[]{}/;'\&quot;|\\GHIJKLMNOPQRSTUVWXYZ&quot;,

                          MinLength = 6, MaxLength = 6)]

               public String Background               {

                   get                   {

                       return
            (String)this[&quot;background&quot;];

                   }

                   set                   {

                       this[&quot;background&quot;] = value;
                   }

               }

              
            [ConfigurationProperty(&quot;foreground&quot;, DefaultValue =
            &quot;000000&quot;, IsRequired = true)]

               [RegexStringValidator(Pattern=&quot;[0-9A-Fa-f]{6}&quot;]

               public String Foreground               {

                   get                   {

                       return
            (String)this[&quot;foreground&quot;];

                   }

                   set                   {

                       this[&quot;foreground&quot;] = value;

                   }

               }

            }

          </Element>
          <Element Type="Text">

            <p>
              The <code>StringValidator</code> is again used to constrain the <code>

                Background=""
              </code> property. The <code>
                RegexStringValidator
              </code> has the same effect by using a regular expression. As you can see,
              the values have the same constraint. However, the regular expression is
              shorter, clearer, and easier to read. Using regular expressions is a good style
              and allows better control when searching, restricting, or replacing strings.
            </p>

            <p>
              To understand what all this creates,
              see the following valid <i>web.config</i> section. Firstly, the custom
              configuration itself has to be registered.
            </p>

          </Element>
          <Element Type="Listing" Name="The configuration definition must be registered using this code">

            &lt;configSections&gt;
               &lt;sectionGroup Name=&quot;pageAppearanceGroup&quot;&gt;
                  &lt;section Name=&quot;pageAppearance&quot;
                              type=&quot;Apress.Extensibility.Configuration.PageAppearanceSection&quot;
                              allowLocation=&quot;true&quot;
                              allowDefinition=&quot;Everywhere&quot; /&gt;
               &lt;/sectionGroup&gt;
            …
            &lt;/configSections&gt;

          </Element>
          <Element Type="Text">

            <p>
              Secondly, the configuration section can
              be used. The code snippet below is an example.
            </p>

          </Element>
          <Element Type="Listing" Name="The configuration definition allows the following usage scenario">

            &lt;pageAppearanceGroup&gt;
              &lt;pageAppearance remoteOnly=&quot;true&quot;&gt;
                &lt;font Name=&quot;TimesNewRoman&quot; size=&quot;18&quot;/&gt;
                &lt;color background=&quot;000000&quot; foreground=&quot;FFFFFF&quot;/&gt;
              &lt;/pageAppearance&gt;
            &lt;/pageAppearanceGroup&gt;

          </Element>
          <Element Type="Text">

            <p>
              However, this does not make
              sense if the values are not used. Defining values is one issue; using them in custom
              code is another.
            </p>
            <p>
              Recall the point of this
              chapter: providers and their configuration should assist other developers to easily
              replace parts of your application, simply by defining another provider. On the
              user interface side, ASP.NET uses powerful server controls as much as possible
              to construct the HTML markup. On the code side, anything that’s configurable in
              any way should be placed in either the <i>web.config</i> file, another
              configuration file, or a database. Custom configuration is a part of the
              extensibility model.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Usage of a Custom Configuration Section" >
          <Element Type="Text">

            <p>
              Assuming the configuration section is
              defined, present, and filled with data, it’s time to access its values at
              runtime from your own code. The following code shows how to achieve this.
            </p>

          </Element>
          <Element Type="Listing" Name="Access the configuration data">

            &lt;%@ Page Language=&quot;C#&quot; %&gt;
            &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
                                  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
            &lt;script runat=&quot;server&quot;&gt;
              protected void Page_Load(object sender, EventArgs e)
              {
                Apress.Extensibility.Configuration.PageAppearanceSection config =
                    (Apress.Extensibility.Configuration.PageAppearanceSection)
                       System.Configuration.ConfigurationManager.GetSection(&quot;pageAppearanceGroup/pageAppearance&quot;);
                StringBuilder sb = new StringBuilder();
                sb.Append(&quot;&lt;h2&gt;Settings in the PageAppearance Section:&lt;/h2&gt;&quot;);
                sb.Append(String.Format(&quot;RemoteOnly: {0}&lt;br&gt;&quot;, config.RemoteOnly));
               sb.Append(String.Format(&quot;Font name and size: {0} {1}&lt;br&gt;&quot;,
                                         config.Font.Name, config.Font.Size));
                sb.Append(String.Format(&quot;Background and foreground color: {0} {1}&lt;br&gt;&quot;, 

                    config.Color.Background,
            config.Color.Foreground));

                lblConfig.Text = sb.ToString();

              }

            &lt;/script&gt;

            &lt;html &gt;

            &lt;head id=&quot;Head1&quot;
            runat=&quot;server&quot;&gt;

              &lt;title&gt;Custom Configuration Section
            Example&lt;/title&gt;

            &lt;/head&gt;

            &lt;body&gt;

              &lt;form id=&quot;form1&quot;
            runat=&quot;server&quot;&gt;

              &lt;div&gt;

                &lt;asp:Label runat=&quot;server&quot;
            ID=&quot;lblConfig&quot; &gt;&lt;/asp:Label&gt;

              &lt;/div&gt;

              &lt;/form&gt;

            &lt;/body&gt;

            &lt;/html&gt;

          </Element>
          <Element Type="Text">
            <p>
              The <code>ConfigurationManager</code> class is the entry point into the configuration. You can address
              any section here by giving the full path or, at least, a distinct part of the
              leaf path. As shown in the section about providers, there are several ways to
              handle these strings. Consider attributes, constant literals, and helper
              classes.
            </p>

            <p>
              Once you have the section, and
              the section is a private type, you can cast as shown in the listing. The properties
              will represent the current values in the configuration. This will not only
              handle private data but also give fully typed access to the elements.
            </p>

            <p>
              The configuration is based on
              the serialization and deserialization features that the base class provides. This
              could make it difficult to read or to modify the values in the <i>web.config</i>
              file. If you understand how the serializer works and can create similar strings
              by hand, your configuration class should function correctly as is.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Accessing the Configuration Declaratively" >
        Accessing the Configuration Declaratively
        <Element Type="Text">

          <p>
            We now have an extended configuration
            model allowing the storage of complex values in a clearly defined way. The
            programmatic access is easy. However, ASP.NET favors declarative techniques.
            Making the configuration accessible from markup would be ideal. 
          </p>

        </Element>
        <Element Type="Section" Name = "Extending the Expression Binding Syntax" >
          Extending the Expression Binding Syntax
          <Element Type="Text">

            <p>
              Integrated expressions play an important
              role in accessing data dynamically. You probably work with data binding
              expressions following the <code>
                &lt;%# %&gt;
              </code> pattern. A different declarative syntax is available, with this
              pattern:
            </p>
            <pre>
              &lt;%$ %&gt;
            </pre>
            <p>
              This is also an extensible model,
              allowing the creation of your own syntax in order to access data within the
              markup:
            </p>
            <pre>
              &lt;asp:literal text=&quot;&lt;%$
              MyConfig:GetData %&gt;&quot; runat=&quot;server&quot; /&gt;
            </pre>
            <p>
              Read this as an enhancement to the configuration
              extension described in the section “Extending the Configuration". It transfers
              access to the markup. Developers can access data without writing explicit code.
              Now page designers working with <i>.aspx</i> pages can add specific formatting
              options without doing any coding tasks.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Introduction to Expression Syntax" >
          Introduction to Expression Syntax
          <Element Type="Text">

            <p>
              Expression builders process
              expressions. These build code from expressions during the page processing
              phase—the parsing procedure. Expressions have this distinct pattern:
            </p>
            <pre>
              &lt;%$ [prefix]:[declaration] %&gt;
            </pre>
            <p>
              The first part, the prefix, maps to a
              type that handles the expression. Any string will do for the prefix. The colon
              is mandatory, but you can enter whatever you like in the declaration part. Anything
              from the colon to the end of the expression is treated as a <code>String</code> and processed at once. One common usage is the accessing of the <code>AppSettings</code> section in <i>web.config</i>. It follows this pattern:
            </p>
            <pre>
              &lt;%$ AppSettings:KeyName %&gt;
            </pre>
            <p>
              The prefix is “AppSettings". It
              determines the expression builder via a mapping (explained in the “Declare the
              Prefix" section below) to a built-in class called <code>AppSettingsExpressionBuilder</code>. The expression builder must be able to handle the remaining part,
              “KeyName" in the example.
            </p>

            <p>
              For localized resources there is
              another built-in class:
            </p>
            <pre>
              &lt;%$ Resources:ResourceCategory,Name
              %&gt;
            </pre>
            <p>
              The prefix is now “Resources".
              The expression builder used behind the scenes is the
            </p>

            <p>
              <code>
                ResourceExpressionBuilder
              </code>. There is also another, <code>

                ConnectionStringsExpressionBuilder="",
              </code> which makes connection strings available in markup. All expression
              builders derive from the abstract base class <code>

                ExpressionBuilder=““
              </code>. The extensibility concept follows the common pattern. By implementing
              this base class, you can build your own expression builder.
            </p>

          </Element>
          <Element Type="Section" Name = "How it Works Internally" >
            How it Works Internally
            <Element Type="Text">

              <p>
                Internally, the expression builder
                creates a code snippet. This code is inserted into the page during the parsing
                step. The compiler treats this code as part of your custom code and creates the
                page object. This requires the code snippet to follow specific rules. Essentially,
                the code is an assignment. It assigns a value to a property of a control. Where
                the value comes from might require complex code, but the assignment is simple
                and limits the usage of such expressions. The most evident limitation is that
                usage without a control is not allowed. The following code will not function:
              </p>

              <pre>
                &lt;div&gt;
                  &lt;%$ MyConfig:Value1 %&gt;
                &lt;/div&gt;
              </pre>
              <p>Instead, you must use a control:</p>
              <pre>
                &lt;div&gt;
                  &lt;asp:label runat=&quot;server&quot;
                Text=&quot;&lt;%$ MyConfig:Value1 %&gt;&quot; /&gt;
                &lt;/div&gt;
              </pre>
              <p>
                However, using the prefix is not enough
                to put it into operation. First, you must map the prefix to a specific type.
              </p>

            </Element>
            <Element Type="Section" Name = "Declare the Prefix" >
              Declare the Prefix
              <Element Type="Text">

                <p>
                  The declaration of the prefix takes
                  place in the <i>web.config</i> file. The path to the configuration element is <code>&lt;system.web&gt;&lt;compilation&gt;&lt;expressionBuilders&gt;</code>. The <code>
                    &lt;expressionBuilders&gt;
                  </code> element is usually absent. Add the following element to define a new
                  mapping between a prefix and a type:
                </p>
                <pre>
                  &lt;expressionBuilders&gt;
                    &lt;add expressionPrefix=&quot;prefix&quot;
                  type=&quot;type,assembly&quot;/&gt;
                  &lt;/expressionBuilders&gt;
                </pre>
                <p>
                  The <code>type=""</code> follows the common schema of an assembly reference:
                </p>
                <ul>
                  <li>
                    Namespace.Class, Assembly,
                    Version, Culture, PublicKeyToken
                  </li>
                  <li>Namespace.Class, Assembly</li>
                  <li>Namespace.Class, __code</li>
                </ul>
                <p>
                  The first form defines the fully
                  qualified name of an assembly. The last references the App_Code folder, if the
                  appropriate project type is used in Visual Studio. (Note the two underscores before
                  the word “code" here.) An example could look like this:
                </p>

                <ul>
                  <li>
                    Apress.Extensions.MyBuilder,
                    Apress.Extensions
                  </li>
                </ul>

                <p>
                  Now we need to create the type. As
                  mentioned above, the abstract base class is where we start.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name = "How the Expression Builder Works" >
              How the Expression Builder Works
              <Element Type="Text">

                <p>
                  The expression builder has only a few
                  methods. Using these methods, it can parse the expression and generate the
                  required code. Parsing is initiated using the <code>
                    ParseExpression
                  </code> method. If this step is successful, the <code>GetCodeExpression</code> method generates a code snippet. The only condition is that the
                  compiler must be able to assign the snippet to a property. Therefore, the
                  snippet must form the right hand side of an assignment:
                </p>
                <pre>
                  control.Property = &lt;this is the code expression&gt;;
                </pre>
                <p>
                  While the right hand side is merely
                  a method call, this method can contain any amount of code (meaning that even
                  the most complex operations are possible).
                </p>

                <p>
                  If the parsing fails, you should
                  throw an exception. Otherwise, the <code>GetCodeExpression=""</code> method is invoked to create the code using the Code Document Object
                  Model (CodeDOM). Although a short explanation follows, this book does not teach
                  CodeDOM in depth. Refer to the MSDN documentation to learn more about source code
                  generation:
                </p>

                <p class="Query">
                  style='>http://msdn.microsoft.com/en-us/library/system.codedom.aspx
                </p>

                <p>
                  Table 4.6 lists the methods you have to
                  implement to add an expression builder to an operation.
                </p>

              </Element>
              <Element Type="Table" Name="Methods of an expression builder">
                <table>
                  <tr>
                    <th>
                      Method 
                    </th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>
                      <code>
                        EvaluateExpression
                      </code>         Returns
                      the value for non-compiled pages (see section “Accessing Settings for
                      Non-Compiled Pages" in this chapter for details)
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>
                        GetCodeExpression
                      </code>         Creates
                      the code snippet to insert into the page
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>
                        ParseExpression
                      </code>  Parses
                      the syntax of the expression
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>SupportsEvaluate=''</code>
                    </td>
                    <td>
                      Indicates whether this expression builder supports
                      non-compiled pages
                    </td>
                  </tr>
                </table>
              </Element>
              <Element Type="Text">

                <p>
                  These methods are sufficient for creating
                  our own expression builder.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name = "Creating an Expression Builder" >
              Creating an Expression Builder
              <Element Type="Text">

                <p>
                  In the first example, we need direct
                  access to values stored in a SQL Server database. We are using the same
                  database and table we created earlier in this chapter. Please refer to Figure 4.2
                  at the beginning of the chapter. Specific criteria are used to retrieve the
                  right values. The prefix is called “Cfg" and the syntax of the expressions
                  looks like this:
                </p>
                <pre>
                  &lt;%$ Cfg:Key FROM category WHERE type
                  %&gt;
                </pre>
                <p>
                  The syntax is similar to SQL, which
                  makes it more readable. The type refers to the type of data, such as “image" or
                  “label". In the markup portion, this would look like:
                </p>
                <pre>
                  &lt;asp:Label ID=&quot;lblHeader&quot;
                  runat=&quot;server&quot;
                             Text=&quot;&lt;%$ Cfg:Header FROM
                  PageData WHERE label %&gt;&quot;&gt;&lt;/asp:Label&gt;
                </pre>
                <p>
                  The following code is the same for an
                  image:
                </p>
                <pre>
                  &lt;asp:Image ID=&quot;imgHeader&quot;
                  runat=&quot;server&quot;
                             ImageUrl=&quot;&lt;%$ Cfg:Header
                  FROM PageData WHERE image %&gt;&quot;&gt;&lt;/asp: Image&gt;
                </pre>
                <p>
                  The created code for the image example
                  looks like “images/header1.png". Once defined, Visual Studio recognizes the
                  expression syntax, as shown in the following figure:
                </p>
              </Element>
              <Element Type="Image" Name="The private expression builder appears in Visual Studio’s expression dialog">
                images/ASPEXTf0406.tif
              </Element>
              <Element Type="Text">
                <p>One solution is shown in Listing 4.16.</p>
              </Element>
              <Element Type="Listing" Name="Using expressions for retrieving configuration data from a database">
                <Element Type="Text">

                  using System;
                  using System.Text;
                  using System.Web.Compilation;
                  using System.Data.SqlClient;
                  using System.CodeDom;

                  namespace Apress.Extensibility.Expressions
                  {

                    public class CfgExpression : ExpressionBuilder
                    {

                    private static ConfigDataDataContext ctx;
                    private static void EnsureCfgContext()  
                    {
                      ctx = new ConfigDataDataContext();
                    }

                    public static string GetCfg(string key, string category, string type)
                    {

                      EnsureCfgContext();
                      var res = from row in ctx.aspnet_Configurations
                                where row.cfg_key == key
                                   &amp;&amp; row.cfg_category == category
                                   &amp;&amp; row.cfg_type == type
                                select row.cfg_content;

                      return res.FirstOrDefault&lt;string&gt;();
                    }
                    public override System.CodeDom.CodeExpression GetCodeExpression(

                               System.Web.UI.BoundPropertyEntry entry,

                               object parsedData,
                               ExpressionBuilderContext context) 

                    {

                      ExpressionValues cfgValues = parsedData as ExpressionValues;

                      if (cfgValues == null) throw new ArgumentException(&quot;parsedData&quot;);

                      CodePrimitiveExpression[] cArg = new CodePrimitiveExpression[]
                      {
                         new CodePrimitiveExpression(cfgValues.Key),
                         new CodePrimitiveExpression(cfgValues.Category),
                         new CodePrimitiveExpression(cfgValues.Type)
                      };

                      CodeTypeReferenceExpression t = new CodeTypeReferenceExpression(
                                                          typeof(CfgExpression));
                      CodeMethodInvokeExpression exp = new CodeMethodInvokeExpression(t,
                                                           &quot;GetCfg&quot;, cArg);
                      return exp;
                    }

                    public override object ParseExpression(string expression,
                                                           Type propertyType,
                                                           ExpressionBuilderContext context)
                    {
                      return TokenParser.Parse(expression);
                    }

                    public override bool SupportsEvaluate
                    {
                      get
                      {
                        return false;
                      }
                    }

                    public override object EvaluateExpression(object target,
                                                              System.Web.UI.BoundPropertyEntry entry,
                                                              object parsedData,
                                                              ExpressionBuilderContext context)
                    {
                      return base.EvaluateExpression(target, entry, parsedData, context);
                    }

                    #region ConfigValues                    class ExpressionValues
                    {
                      public string Key { get; set; }
                      public string Category { get; set; }
                      public string Type { get; set; }
                    }

                    #endregion                    #region SimpleTokenParser                    static class TokenParser
                    {

                      static ExpressionValues values;
                      static TokenParser()
                      {
                        values = new ExpressionValues();
                      }

                      internal static ExpressionValues Parse(string toParse)
                      {

                        if (String.IsNullOrEmpty(toParse))
                           throw new ArgumentNullException(toParse);

                        int i = 0;
                        string currentToken = String.Empty;
                        // value FROM cat WHERE type
                        while (true)
                        {
                          char c = toParse[i];
                          switch (c) 
                          {
                          case 'F':
                            if (toParse.Substring(i, 5).Equals(&quot;FROM &quot;))
                            {
                              values.Key = currentToken.Trim();
                              currentToken = String.Empty;
                              i += 4;
                            }
                            break;
                          case 'W':
                            if (toParse.Substring(i, 6).Equals(&quot;WHERE &quot;))
                            {
                              values.Category = currentToken.Trim();
                              currentToken = String.Empty;
                              i += 5;
                            }
                        break;
                      default:
                        currentToken += c;
                        break;
                      }

                      if (++i &lt; toParse.Length) continue;
                      values.Type = currentToken;
                      break; // end while
                    }

                    return values;
                      }
                    }
                    #endregion
                    }
                  }

                </Element>
                <Element Type="Text">

                  <p>
                    The creation of dynamic code is the most
                    important part. However, it doesn’t make sense to do everything dynamically.
                    This is why the code for retrieving data is moved to the static method, <code>GetCfg</code>. The dynamic portion calls that method, which leads to generated
                    code, such as:
                  </p>
                  <pre>
                    lblHeader.Text = GetCfg(…);
                  </pre>
                  <p>
                    The method is static because
                    the private expression builder is not instantiated at run time. It’s a design-time
                    tool which supports the page parser and design-time experience in Visual Studio.
                    Only the assignment remains in the page’s code after compilation.
                  </p>
                  <p>
                    The procedure commences with the
                    <code>ParseExpression</code> method. The
                    object created here appears later as the <code>parsedData=""</code> parameter of the <code>
                      GetCodeExpression
                    </code> method. The <code>
                      TokenParser
                    </code> class in the example demonstrates how to parse custom strings. It
                    analyses the string after the expression’s colon and creates three required
                    parameters from it. The private class, <code>

                      ExpressionValues=““,
                    </code> stores the values, while the <code>
                      GetCodeExpression=““
                    </code> method builds the necessary code. It must return an object of type <code>System.CodeDom.CodeExpression</code>, which will contain a code fragment assignable to the right hand side
                    of an assignment statement. Refer to the next table to view the most important CodeDOM
                    functions. In this example, I use a simple call to a static method so that the
                    code generation is as simple as possible. The core element is the method
                    invocation:
                  </p>

                  <pre>
                    new CodeMethodInvokeExpression(t,
                    &quot;GetCfg&quot;, cArg)
                  </pre>
                  <p>
                    The argument <i>cArg</i> is the
                    collection of private parameters.
                  </p>

                </Element>
                <Element Type="Table" Name="Important CodeDOM methods">
                  <table>
                    <tr>
                      <th>
                        Method 
                      </th>
                      <th>Description</th>
                    </tr>
                    <tr>
                      <td>
                        <code>
                          CodeExpression
                        </code>  An
                        abstract base class for all CodeDOM types.
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>
                          CodeTypeReferenceExpression
                        </code>     A type reference, such as a type used in code
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>
                          CodePrimitiveExpression
                        </code>  Any
                        code expression, which does not fit into other categories
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <code>CodeMethodInvokeExpression=''</code>
                      </td>
                      <td>
                        A method call which requires, as parameters, the type where
                        the method is defined, the name of the method, and an array of code fragments
                        used as parameters for the method
                      </td>
                    </tr>
                  </table>
                </Element>
              </Element>
              <Element Type="Text">

                <p>
                  The <code>GetCfg=''</code> method follows the same pattern as used in the configuration
                  example earlier. This draws from the <code>DataContext=''</code> class and LINQ to SQL to retrieve the values. The name of the
                  context, <code>ConfigDataDataContext</code>, is based
                  on the definition in <i>ConfigData.dbml</i>.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name = "Accessing Settings for Non-Compiled Pages" >
              Accessing Settings for Non-Compiled Pages
              <Element Type="Text">

                <p>
                  If pages contain mainly static content,
                  the compilation step can be suppressed. Code expressions and expression
                  builders will still function. Moreover, expression builders which support non-compiled
                  pages offer a different way of handling the code creation.
                </p>

                <p>
                  You can suppress the compilation by
                  setting the following attribute in the <code>
                    @Page
                  </code> directive:
                </p>

                <pre>
                  &lt;%@ Page Language=&quot;C#&quot;
                  CompilationMode=&quot;Never&quot; %&gt;
                </pre>
                <p>
                  This can also be set globally in <i>web.config</i>.
                </p>

                <pre>
                  &lt;pages
                  compilationMode=&quot;Never&quot; /&gt;
                </pre>
                <p>
                  This might sound strange, but
                  imagine that this is a <i>web.config</i> file for a subfolder where all static
                  pages reside. It makes sense to suppress compilation if you have a tool which
                  is modifying the static content directly and frequently, as the compiler causes
                  an additional load on the server when compiling pages over and over, without creating
                  any useful code.
                </p>

                <p>
                  The point of this section is the
                  fact that expression builders are still allowed and assigned. However, they aren’t
                  able to create code snippets, as there is no compilation step able to support
                  them. To indicate this usage scenario, the property <code>SupportsEvaluate</code> of the expression builder class must return <code>true</code>. This forces the page parser to call <code>

                    EvaluateExpression=""
                  </code>. The same will happen at runtime. Even if the page contains no code,
                  and no compiler is invoked, the page handler serving the page will call the
                  expression builder’s <code>
                    EvaluateExpression
                  </code> method. As shown in the first example, the code invokes the
                  appropriate configuration settings. This is a high-performance technique. It
                  has limitations, but it is not as restricted as HTML pages would be. Beneath the
                  configuration settings, you can also express date specifications or statistical
                  data.
                </p>

              </Element>
              <Element Type="Listing" Name="Support for non compiled pages">

                using System;
                using System.Text;
                using System.Web.Compilation;
                using System.Data.SqlClient;
                using System.CodeDom;

                namespace Apress.Extensibility.Expressions
                {

                  public class CfgExpression : ExpressionBuilder
                  {

                  private static ConfigDataDataContext ctx;
                  private static void EnsureCfgContext() 
                  {
                    ctx = new ConfigDataDataContext();
                  }

                  public static string GetCfg(string key, string category, string type)
                  {
                    EnsureCfgContext();

                    var res = from row in ctx.aspnet_Configurations
                              where row.cfg_key == key
                                 &amp;&amp; row.cfg_category == category
                                 &amp;&amp; row.cfg_type == type
                              select row.cfg_content;
                    return res.FirstOrDefault&lt;string&gt;();
                  }

                  public override bool SupportsEvaluate
                  {
                      get
                      {
                          return true;
                      }
                  }

                  public override object EvaluateExpression(object target,
                                         System.Web.UI.BoundPropertyEntry entry,
                                         object parsedData, ExpressionBuilderContext context)
                  {
                     ExpressionValues cfgValues = parsedData as ExpressionValues;
                     return GetCfg(cfgValues.Key, cfgValues.Category, cfgValues.Type);
                  }
                }

              </Element>
              <Element Type="Text">

                <p>
                  Read the <code>EvaluateExpression=""</code> method as a combination of the <code>ParseExpression=""</code>
                  and <code>GetCodeExpression</code> methods. The database access is the same as in the last example.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name = "Beyond Simple Expressions" >
              Beyond Simple Expressions
              <Element Type="Text">

                <p>
                  This expression model supports several
                  other features. However, as they are beyond the scope of this book, I’ll only
                  give a short overview of them. Please refer to the official documention for
                  more usage scenarios.
                </p>
                <p>
                  The <code>ParseExpression</code> method has another parameter named <code>
                    context
                  </code>. It’s not used in the example, as it’s intended for more advanced
                  scenarios. This parameter is of the type <code>
                    ExpressionBuilderContext
                  </code>. Its purpose is to support template based controls, and it contains
                  the virtual path to the page or user control that contains the control. The
                  expression builder refers to the control and is able to support different code
                  generation strategies, depending on the requirements of the template based
                  control.
                </p>

                <p>
                  Another parameter, <code>propertyType</code>, refers to the type of the property. Usually, this is <code>String</code>, but it can be modified to any type that suits your needs. For
                  instance, when using a very limited set of options, an <code>enum</code> would be appropriate. This would create a dropdown element in
                  Visual Studio’s expression builder for an advanced design-time experience.
                </p>

                <p>
                  The last parameter named <code>entry</code> is of the <code>
                    BoundPropertyEntry
                  </code>type. This allows access to the control itself, its <code>ControlID</code> property, and the control’s type.
                </p>

                <p>
                  Finally, the parameter <code>ExpressionPrefix</code> retrieves the currently used prefix. This assumes that you can
                  assign the same expression builder multiple times and create complex and
                  sophisticated frameworks on top of expression builders.
                </p>

              </Element>
            </Element>
            <Element Type="Section" Name = "Design-time Support" >
              Design-time Support
              <Element Type="Text">

                <p>
                  As demonstrated earlier, Visual Studio
                  supports expressions through simple Expression dialogs. These can be invoked
                  using the Expression section of the property browser. Simply select a control
                  on the designer surface, open the property browser (F4) and click on the
                  ellipses in the <i>Expressions</i> element in the <i>Data</i> section. The
                  dialog contains a mapping tool, which assigns properties to expressions. Here,
                  the property grid uses attributes read by reflection to modify its behavior.
                </p>

              </Element>
              <Element Type="Image" Name="Invoke the Expression dialog using the ellipses button. Bound properties appear with a small icon in the name column.">
                images/ASPEXTf0408.tif
              </Element>
              <Element Type="Text">

                <p>
                  To support this, decorate the class of
                  the expression builder with an  <code>
                    ExpressionEditorAttribute
                  </code>, defined in the <code>
                    System.Web.UI.Design
                  </code> namespace of the <code>System.Design</code><code>
                    assembly
                  </code>:
                </p>
                <pre>
                  [ExpressionEditor(typeof(CfgExpressionEditor))]
                </pre>
                <p>
                  The type <code>CfgExpressionEditor=""</code> implements the abstract base class <code>ExpressionEditor=""</code>. The only required step is to implement the <code>GetExpressionEditorSheet</code> method:
                </p>
                <pre>
                  public override ExpressionEditorSheet GetExpressionEditorSheet(
                                                        string expression,
                                                        IServiceProvider serviceProvider)
                  {
                    return new CfgExpressionEditorSheet(expression, serviceProvider);
                  }
                </pre>
                <p>
                  The <code>CfgExpressionEditorSheet=""</code> type results from the implementation of the base class <code>ExpressionEditorSheet</code>. This type defines the properties in the property grid of the
                  expression builder dialog that Visual Studio displays. Regarding other types,
                  you can use the classes <code>EditorAttribute</code> and <code>TypeConverterAttribute</code> to change the data the property grid reads via reflection. You can
                  find both types in the <code>System.ComponentModel</code>. In the example, it would be helpful to have three properties, such
                  as “Key", “Category", and “Type". The <code>EditorAttribute=""</code>defines the editor used in one entry of the property grid. This can
                  be a dropdown list, or another dialog opened by clicking on the ellipses.
                </p>

              </Element>

              <Element Type="SideBar" SidebarType="Note">

                <header>Note</header>
                <aside>
                  Dialogs and controls that
                  are used in Visual Studio to extend the design-time experience must be WinForm
                  controls. You cannot use web controls here. Some familiarity with Windows Forms
                  Control programming is highly recommended before you begin extending Visual
                  Studio’s design-time environment.
                </aside>

              </Element>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Implementing an Expression Builder with Design-time Support" >
          Implementing an Expression Builder with Design-time Support
          <Element Type="Text">

            <p>
              The next example shows the complete
              implementation of an expression builder with design-time support. The purpose
              is the output of current data or time including variations like yesterday,
              tomorrow, and so on. The current value should appear in design-time view. Additionally,
              it is selectable in the Expressions dialog using a dropdown. The usage in
              markup could look like this:
            </p>

            <pre>
              &lt;asp:Label runat=&quot;server&quot;
              ID=&quot;lblHeader&quot; Text='style='background:yellow'>&lt;%$
              Time:YesterDay style='background:yellow'>%&gt;'            Font-Bold=&quot;true&quot;&gt;&lt;/asp:Label&gt;
            </pre>
            <p>
              In design-time view, it shows the
              current value.
            </p>

          </Element>
          <Element Type="Image" Name="Design-time view with real values">
            images/ASPEXTf0409.tif
          </Element>
          <Element Type="Text">

            <p>
              The next code listing is the basic
              implementation of the Expression builder itself. In the remaining part of the
              section, I will show how to extend this to get the full design-time support.
            </p>

          </Element>
          <Element Type="Listing" Name="The complete definition of the design-time
environment">

            using System;
            using System.CodeDom;
            using System.Web.Compilation;
            using System.Web.UI;
            using System.Web.UI.Design;

            namespace Apress.Extensibility.Expressions.Time
            {
                [ExpressionPrefix(&quot;Time&quot;)]
            [ExpressionEditor(typeof(TimeExpressionEditor))]
                public class TimeExpression : ExpressionBuilder
                {

                    public override CodeExpression GetCodeExpression(BoundPropertyEntry entry, object parsedData, ExpressionBuilderContext context)
                    {

                        TimeOptions to = (TimeOptions)Enum.Parse(typeof(TimeOptions),  entry.Expression, true);
                        switch (to)
                        {
                            case TimeOptions.Today:
                            // System.DateTime.Now               
                            return new CodePropertyReferenceExpression(
                                new CodeTypeReferenceExpression(typeof(DateTime)), &quot;Now&quot;);
                            case TimeOptions.Yesterday:
                                // System.DateTime.Now.AddDays(-1)                   
                                return new CodeMethodInvokeExpression(
                                    new CodePropertyReferenceExpression(
                                        new
            CodeTypeReferenceExpression(typeof(DateTime)),

                                        &quot;Now&quot;),

                                        &quot;AddDays&quot;,

                                        new
            CodePrimitiveExpression(-1));               

                            case TimeOptions.Tomorrow:

                                    //
            System.DateTime.Now.AddDays(1)

                                    return new
            CodeMethodInvokeExpression(

                                        new
            CodePropertyReferenceExpression(

                                            new
            CodeTypeReferenceExpression(typeof(DateTime)),

                                           
            &quot;Now&quot;),

                                           
            &quot;AddDays&quot;,

                                            new
            CodePrimitiveExpression(1));
                            case TimeOptions.NextWeek:

                                    //
            System.DateTime.Now.AddDays(7)

                                    return new CodeMethodInvokeExpression(

                                        new
            CodePropertyReferenceExpression(

                                            new
            CodeTypeReferenceExpression(typeof(DateTime)),

                                           
            &quot;Now&quot;),

                                           
            &quot;AddDays&quot;,

                                            new
            CodePrimitiveExpression(7));

                            default:

                                    throw new
            InvalidOperationException(&quot;The expression                                          value should be
            one of:

                                          Today, Yesterday,
            Tomorrow, NextWeek.&quot;);

                        }

                    }

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              This expression builder takes an
              enumeration value (see Listing 4.19) and creates code snippets that return a
              date value based on the current time and date. Note the attribute at the top of
              the class:
            </p>

            <pre>
              [ExpressionEditor(typeof(TimeExpressionEditor))]
            </pre>
            <p>
              This assigns the <code>TimeExpressionEditor</code> type to modify the design-time environment.
            </p>

          </Element>
          <Element Type="Listing" Name="A supporting enumeration">
            namespace Apress.Extensibility.Expressions.Time
            {

                public enum TimeOptions
                {
                    Yesterday,
                    Today,
                    Tomorrow,
                    NextWeek
                }
            }
          </Element>
          <Element Type="Text">

            <p>
              The <code>TimeExpressionEditor</code> type derives from the <code>ExpressionEditor</code>. Its purpose is twofold. Firstly, it allows the output of values in
              the designer. If a user opens the designer surface editing a page or user
              control, the expressions can be used just like any other expression. Instead of
              showing the expression’s code, such as <i>Time:Today</i>, it shows the calculated
              value, <i>March 20, 2009</i>. This results in a more realistic design-time
              experience.
            </p>

          </Element>
          <Element Type="Listing" Name="This code supports a custom editor at design-time">

            using System;
            using System.Web.UI.Design;
            namespace Apress.Extensibility.Expressions.Time
            {

                public class TimeExpressionEditor : ExpressionEditor
                {

                    // Evaluates an expression at design-time for preview purposes       
                    public override object EvaluateExpression(string expression,
                                                               object parseTimeData,

                                                              
            Type propertyType,

                                                              
            IServiceProvider serviceProvider)

                    {

                        TimeOptions to = (TimeOptions)
            Enum.Parse(typeof(TimeOptions),

                                                       expression,
            true);

                        switch (to)

                        {

                            case TimeOptions.Today:

                                return
            System.DateTime.Now.ToString();
                            case TimeOptions.Yesterday:
                                return
            System.DateTime.Now.AddDays(-1).ToString();

                            case TimeOptions.Tomorrow:

                                return
            System.DateTime.Now.AddDays(1).ToString();

                            case TimeOptions.NextWeek:

                                return
            System.DateTime.Now.AddDays(7).ToString();

                            default:

                                throw new
            InvalidOperationException(&quot;The expression value                                      should be one of:
            Today, Yesterday, Tomorrow, NextWeek.&quot;);

                        }

                    }

                    public override ExpressionEditorSheet
            GetExpressionEditorSheet(

                                    string expression,
            IServiceProvider serviceProvider)

                    {

                        return new TimeExpressionEditorSheet(expression,
            serviceProvider);

                    }
                }
            }

          </Element>
          <Element Type="Text">
            <p>
              The code demonstrates how to define the
              editor sheet using the <code>GetExpressionEditorSheet</code> method. The <code>TimeExpressionEditorSheet</code> type used here is defined below:
            </p>
          </Element>
          <Element Type="Listing" Name="This code supports the propertysheet at design-time">
            using System;
            using System.ComponentModel;
            using System.Web.UI.Design;

            namespace Apress.Expressions.Time
            {

                public sealed class TimeExpressionEditorSheet : ExpressionEditorSheet
                {

                    private string _day;

                    public TimeExpressionEditorSheet(string day,
                                                     IServiceProvider serviceProvider)

                        : base(serviceProvider)
                    {
                        Day = day;
                    }

                    [TypeConverter(typeof(TimeConverter))]
                    public string Day
                    {

                        get
                        {
                            return _day;
                        }

                        set
                        {
                            _day = value;
                        }
                    }

                    public override string GetExpression()
                    {
                        return Day;
                    }

                    // TypeConverter to provide dropdown of valid values           
                    private sealed class TimeConverter : StringConverter
                    {

                        public override bool GetStandardValuesExclusive(
                                             ITypeDescriptorContext context)
                        {
                            return true;
                        }

                        public override bool GetStandardValuesSupported(
                                             ITypeDescriptorContext context)
                        {
                            return true;
                        }

                        public override TypeConverter.StandardValuesCollection
                                        GetStandardValues(ITypeDescriptorContext context)
                        {
                            string[] standardValues = Enum.GetNames(typeof(TimeOptions));
                            return new StandardValuesCollection(standardValues);
                        }
                    }
                }
            }

          </Element>
          <Element Type="Text">

            <p>
              These are the properties shown
              in the expression builder dialog in Visual Studio. The <code>[TypeConverter(typeof(TimeConverter))]</code> attribute converts values from the property grid into the
              enumeration. This is necessary as the property grid transforms a type
              internally into a string representation, which allows you to select it. In this
              case, the dropdown will return single strings like “Today" or “Tomorrow". These
              values must be converted back and forth by the <code>

                10.0pt=""'>TimeOptions
              </code> enumeration.
            </p>

            <p>
              In the property grid, we handle
              the enumeration as a dropdown. You can force this by returning <code>true</code> in the <code>GetStandardValuesSupported
              </code> method. The <code>GetStandardValues</code>
              method must return the array of elements presented in the dropdown. <code>Enum.GetNames</code> performs this function. If the enumeration values do not fit your
              needs, you may decorate them with <code>DescriptionAttribute</code> attributes (<code>System.Componentmodel</code>
              namespace) and obtain the final strings from this attribute instead of using
              the enum values.
            </p>

          </Element>
          <Element Type="Listing" Name="">

            public enum TimeOptions
            {
                [Description(&quot;The day before today&quot;)]
                Yesterday,
                [Description(&quot;Now&quot;)]
                Today,
                [Description(&quot;The day after today&quot;)]
                Tomorrow,
                [Description(&quot;Some time in the future&quot;)]
                NextWeek
            }

          </Element>
          <Element Type="Text">
            <p>
              This is just one of the many options you
              have in extending the design-time environment. However, the more code you add,
              the harder it will be to debug. The next section covers the basic principles of
              design-time debugging.
            </p>

          </Element>
          <Element Type="Section" Name = "Debugging Design-time Extensions" >
            Debugging Design-time Extensions
            <Element Type="Text">

              <p>
                Design-time support should be part of any
                extension model. However, it’s difficult to debug these extensions, and this is
                probably why developers avoid adding design-time support to their applications.
                There is no debugger attached to design-time code. This means that you cannot add
                breakpoints easily or step into the code to view its internal operations. Using
                smart exceptions and try/catch blocks might help, but this is not a good
                debugging experience.
              </p>

              <p>
                To debug within the Visual Studio design-time
                environment, you must launch another instance of Visual Studio and debug the
                same code there. To accomplish this, open the property pages of the Web project
                and select the option <i>Start external program</i>.
              </p>

            </Element>
            <Element Type="Image" Name="Start another instance of Visual Studio to debug at design-time">
              images/ASPEXTf0407.tif
            </Element>
            <Element Type="Text">
              <p>
                Choose the Visual Studio executable <i>devenv.exe</i>
                as the external program. When you start debugging the project (by hitting F5)
                another instance of Visual Studio will appear. In this instance, you load the
                same project and start using the design-time environment. In the first instance
                of Visual Studio, you can now set breakpoints and debug as you would do at
                runtime. To reach specific code sections, just start using the code within the
                second instance.
              </p>

            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Summary" >
        Summary
        <Element Type="Text">

          <p>
            In this chapter, we saw an overview of
            providers and how they can be used to create modern, multi-tier architecture.
            Providers result in highly configurable and extensible applications which don’t
            require additional code when changes to basic features are made. The
            configuration of providers is a major part of this environment. In addition to
            providers, the whole configuration can be extended through <i>web.config</i>. This
            chapter showed the extensibility of <i>web.config</i> in defining private
            sections and elements. Lastly, the configuration settings were made available
            in the declarative part of the web pages, the markup, by supporting private
            expression builders. Expression builders form a final extensibility feature
            that improves the design-time experience.
          </p>

        </Element>
      </Element>
    </Element>
    <Element Type="Section" Name = "Extending the Resource Model" >
      Extending the Resource Model
      <Element Type="Text">

        <p>
          Web sites consist of both pure HTML and
          resources. Resources are everything not directly embedded into the page’s
          source, such as images, JavaScript, ActiveX controls, Flash, and Silverlight
          code. Resources can also be used more widely. You can structure a page’s content
          by moving parts of it into resources, thus changing its content dynamically
          based on different resource sources. This technique is primarily used to create
          localized applications able to display different languages and formats for a
          global market.
        </p>

        <p>
          In this chapter, I’ll explain how to extend
          the resource model in ASP.NET. In particular, I’ll look at:
        </p>

        <ul>
          <li>How the resource model works</li>
          <li>
            Extending the provider-based resource
            management
          </li>
          <li>Creating custom resource providers</li>
          <li>
            Editing resources online at
            runtime
          </li>
        </ul>

      </Element>
      <Element Type="Section" Name = "Principles of Resource Management" >
        Principles of Resource Management
        <Element Type="Text">

          <p>
            Resource files are usually stored in XML
            format and located in special folders called either <i>App_GlobalResources</i>
            for global resources or <i>App_LocalResources</i> for page or control specific
            ones. <i>App_LocalResources</i> is created on a per folder basis. This means
            that, within your application, there will normally be several such folders
            available.
          </p>

          <p>
            Each resource file has a defined file
            name format:
          </p>

          <pre>
            PageName.Culture.resx
          </pre>
          <p>
            However, for fallback reasons,
            a common base resource is required. The first resource file has the default
            name <i>Pagename.resx</i>. Whenever ASP.NET isn’t able to find a particular resource
            file, it will load the default resource file. It’s a good idea to define all your
            resources there in order to avoid users seeing strange results.
          </p>

          <p>
            At compile time, the resource
            compiler takes all these files and compiles them into a binary format. This improves
            the speed of reading the content and reduces the file size.
          </p>
        </Element>
        <Element Type="Section" Name = "The Fallback Strategy" >
          The Fallback Strategy
          <Element Type="Text">

            <p>
              If you think in terms of cultures, you’ll
              see a very straightforward model. A culture is a combination of a language and
              a country. In several countries around the world, people speak more than one
              language. You define the country to receive information regarding currency
              format or calendar, for instance, and you define the language to obtain the correct
              format of numbers, and names of months and weekdays. Even if several countries
              only define one such combination, others are much more complex. In some cases,
              you’ll also find information about the script; for example, certain languages can
              be written in either Cyrillic or Latin letters. Well-globalized pages will support
              this situation.
            </p>

            <p>
              For most applications, it may be unwarranted
              to distinguish between countries—a simple language definition will suffice. A
              good example is the usage of German in Germany, Austria, and Switzerland. As
              long as you don’t deal with currency, it’s almost the same (the differences are
              subtle). Defining German as the final language will drastically reduce the
              development effort and still have a great impact on internationalization. In
              real life scenarios, browsers will usually transmit preferred culture
              information, which consists of language and country details. If one sends “German,
              Austria” and your systems only support German globally, the fallback mechanism
              must find the appropriate resource information.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Using Global Resources" >
          Using Global Resources
          <Element Type="Text">

            <p>
              It’s much the same approach for global
              resources, except that there is no need to bind resources to a specific page.
              This opens the possibility of holding resources for any situation, with or
              without adding support for cultures, languages, and fallback behavior. Such
              resources are called shared resources. It’s easy to handle any kind of resource
              file embedded within an assembly by accessing the resource manager. The access
              is enabled via implicit definition in the page’s markup, using the expression:
            </p>

            <pre>
              &lt;%$ Resources:ResourceKey,Tag %&gt;
            </pre>
            <p>
              Alternatively, you can call the <code>Page</code> class’s <code>
                GetGlobalResource
              </code>
              method.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Limitations of the Existing Provider" >
          Limitations of the Existing Provider
          <Element Type="Text">

            <p>
              The only drawback is that the internal
              resource provider has a single method of accessing resources—based on <i>resx</i>
              files. File-based operations are not unusual, but they limit us to just one way
              of accessing resources at design-time and runtime. Large applications with
              frequently changing resources might need a different behavior, either with
              better runtime support or with using a different storage location for the
              resource information.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Programming a Custom Resource Provider" >
        Programming a Custom Resource Provider
        <Element Type="Text">

          <p>
            The system of .<i>resx</i> files
            provided out-of-the-box has some limitations. While it’s well supported in
            Visual Studio at design-time and works at runtime without any coding effort, there
            is almost no way of parameterizing or configuring the behavior.
          </p>

          <p>
            Imagine that you have different themes
            and want to manage different resources for each theme. Even if the resource
            management fits your needs (apart from wishing to store the data in a database
            instead of in XML files), you can’t use the default resource provider.
            Developers often discard the whole default resource handling approach and
            implement their own solution. However, resource management is based on
            providers and, as shown in the previous chapter, the model is extensible. It is
            not easy, but it can be done, and this chapter will explain how.
          </p>

        </Element>
        <Element Type="Section" Name = "Extending the Provider Model" >
          Extending the Provider Model
          <Element Type="Text">

            <p>
              Whenever you depart from the default resource
              model, you’ll need to manage some specific requirements. Leaving the default
              resource model and creating an independent solution has serious drawbacks. Not
              only do you lose the ability to assign a control’s property a resource-based
              value, but you also lose the whole world of design-time support, runtime
              behavior, and certain optimizations. Therefore, instead of implementing a
              completely isolated solution, the extension of the provider model is a highly recommended
              alternative.
            </p>

            <p>
              To understand the resource model, we’ll look
              firstly at the classes involved. The classes support three phases:
            </p>
            <ul>
              <li>The design-time step</li>
              <li>The compilation phase</li>
              <li>The runtime step</li>
            </ul>
            <p>
              Usually we distinguish between
              runtime and design-time phases only. It might look as though the compilation
              step has a special meaning.
            </p>

            <p>
              As you’ll see later in this
              chapter, this is a quirk of the resource management. The <i>.resx</i> files
              used by default to store resources are compiled into binary resource files.
              Even if not file-based, the resources must be embedded into each page before being
              delivered to the browser. The runtime then handles the resources and transforms
              the pre-compiled data into values read by the controls on the fly.
            </p>

            <p>
              The design-time stage is
              mostly for local resources. Visual Studio provides a feature in the Tools menu to
              create local resources for all the controls on a page. This assigns the <i>meta:resourcekey</i>
              attribute with a key that points to the resource file. This file is a simple
              key-value list that is able to return the right data. The same approach occurs with
              any explicit call to the resources, using the <code>&lt;%$ Resource:Key %&gt;</code> expression.
            </p>

            <p>
              Several .<i>resx</i> files
              co-exist and hold data for each culture supported. Implementing the design-time
              feature is essential for supplying full support to Visual Studio. At compile time,
              these expressions are translated into calls to the methods <code>GetLocalResource</code>
              and <code>GetGlobalResource</code>. At
              runtime, these methods return values from the compiled resources. The two tiers—the
              call to resources at the UI level and the access to the data layer—are separate,
              and the replacement of the data access is quite easy. It’s not unusual to
              change both the behavior and the data source.
            </p>
            <p>
              The following example extends
              the default behavior by reading the current theme and managing as many resource
              file structures as you have themes. It is still using the .<i>resx</i> file
              model. Additionally, you’ll see a web service based client application which demonstrates
              how to handle resources at runtime and allow users to change formerly static
              content.
            </p>

          </Element>
          <Element Type="Image" Name="Bindable properties in the Expression editor in Visual Studio">
            images/ASPEXTf0501.tif
          </Element>
        </Element>
        <Element Type="Section" Name = "Prerequisites" >
          Prerequisites
          <Element Type="Text">

            <p>
              There are good examples in the MSDN
              documentation of how to implement the various interfaces and abstract base
              classes to create a usable resource provider. The problem is that it doesn’t
              give you the whole picture, or explain how the isolated examples fit together
              and fill in the gaps. Normally, you’ll need the following:
            </p>
            <ul>
              <li>
                A factory class that creates the
                provider at design-time
              </li>
              <li>
                A factory class that creates the
                provider at runtime
              </li>
              <li>Implementations of both providers</li>
            </ul>
            <p>
              The providers are responsible for using
              specific reader and writer classes to access the resources. These
              implementations need:
            </p>
            <ul>
              <li>
                A class to read the global
                resources
              </li>
              <li>A class to write the global resources</li>
              <li>A class to read the local resources</li>
              <li>
                A class to write the local
                resources
              </li>
            </ul>
            <p>
              You don’t have to completely
              implement all classes. For instance, if your application does not write
              resources because you manage all resources outside the application, you don’t
              need to implement the writer classes fully.
            </p>

            <p>
              In Figure 5-2, you can see the base classes and
              their dependencies:
            </p>

          </Element>
          <Element Type="Image" Name="2 Class diagram of the base classes and interfaces">
            images/ASPEXTf0502.tif
          </Element>
        </Element>
        <Element Type="Section" Name = "Implementing the Custom Provider" >
          Implementing the Custom Provider
          <Element Type="Text">

            <p>
              The implementation of a custom resource
              provider starts with the <code>ResourceProviderFactory</code>
              class. There are two methods required in order to access both global and local
              resources. Each method returns the configured provider which is responsible for
              requesting resources from resource storage. Implementing the factory allows
              some customization features. In the following examples, I customize by adding
              support for the current theme. Storing the active theme in the factory allows the
              factory to pass the information to the provider via a parameter. The provider
              can then modify the storage using this additional information.
            </p>

            <p>
              In the example, the <code>CustomResourceProvider</code>
              is based on <code>IResourceProvider</code>, and our
              particular interest is in <code>ResourceReader</code>. This is
              the class that implements the reader. The main method is <code>GetObject</code>
              , which returns the resource value based on the conditions obtained from
              the factory and the current conditions, such as the culture, passed via
              parameters. <code>CustomResourceReader</code> implements the <code>IResourceReader</code>
              interface to make the custom implementation available. That means
              the <code>ResourceReader.GetObject</code> method returns an object of type
              <code>IResourceReader</code>. The object is of the type that contains the actual implementation.
            </p>

            <p>
              In a similar manner, to get the
              resource writer classes you can use the <code>GetResourceWriter</code> method to return a type that implements
              <code>IResourceWriter</code>. The implementation in the example code is called
              <code>CustomResourceWriter</code>. As mentioned before, the implementation is only required if you
              plan to support resource writing at runtime.
            </p>

            <p>
              The whole schema must be
              implemented a second time to support the design-time environment. Visual
              Studio’s design-time support creates resource files, and reads and writes
              resources, if you use the designer view. Visual Studio writes <i>.resx</i>
              files by default. Implementing the design-time support allows your custom
              resource provider to work inside Visual Studio and still support different
              storage or schema.
            </p>

            <p>
              To implement the custom resource
              provider, begin with the factory class:
            </p>

          </Element>
          <Element Type="Listing" Name="The entry point is a simple factory class">

            using System.Web.Compilation;

            public sealed class CustomResourceProviderFactory : ResourceProviderFactory
            {

              private string theme;

              public string Theme
              {
                get { return theme; }
                set { theme = value; }
              }

              public override IResourceProvider CreateGlobalResourceProvider(string classKey)
              {
                return new CustomResourceProvider(null, classKey, theme);
              }

              public override IResourceProvider CreateLocalResourceProvider(string virtualPath)
              {

                return new CustomResourceProvider(virtualPath, null, theme);
              }

            }

          </Element>
          <Element Type="Text">

            <p>
              This code shows how simple the factory
              is. It returns a custom resource provider for local and for global resource
              access. In the example, the same provider is used for both, and it
              distinguishes between access methods by supplying either the <code>virtualPath</code>
              or <code>classKey</code> parameter.
            </p>

          </Element>
          <Element Type="Listing" Name="The provider with theme-based resx support">

            public class CustomResourceProvider : IResourceProvider 
            {

                class ResourceTuple 
                {

                    public ResourceTuple(IResourceReader reader, IResourceWriter writer)
                    {

                        this.Reader = reader;

                        this.Writer = writer;

                        this.Culture = ci;

                    }

                    public IResourceReader Reader 
                    {
                        get;
                        set;
                    }

                    public IResourceWriter Writer
                    {
                        get;
                        set;
                    }
                }

                private string virtualPath;
                private string theme;
                private bool isGlobal;
                private static Dictionary&lt;string, Dictionary&lt;CultureInfo, ResourceTuple&gt;&gt; resourceCache;

                public CustomResourceProvider(string virtualPath, string className,
                                             string theme)
                {
                    if (theme == null) 
                       theme = &quot;Default&quot;;
                    if (String.IsNullOrEmpty(className))
                    {
                        this.virtualPath = virtualPath;
                        isGlobal = false;
                    }
                    else
                    {
                        this.virtualPath = className;
                        isGlobal = true;
                    }
                    this.theme = theme;
                    GetResources();
                }
               
                private CultureInfo GetNativeCulture(CultureInfo culture)
                {
                    if (culture == null)
                    {
                        culture = System.Threading.Thread.CurrentThread.CurrentUICulture;
                    }

                    // switch to country neutral parent to handle languages only                    
                    if (culture.Parent != CultureInfo.InvariantCulture)
                    {
                        culture = culture.Parent;
                    }
                    return culture;
                }
                private void GetResources()
                {
                    try
                    {
                        if (resourceCache == null)
                        {
                            resourceCache = new Dictionary&lt;string,
                                                Dictionary&lt;CultureInfo, ResourceTuple&gt;&gt;();
                        }
                        string regPath;
                        if (isGlobal)
                        {
                            // global
                            regPath = &quot;&quot;;
                        }
                        else
                        {
                            // local, XmlResourceHelper is explained in next listing
                            regPath = XmlResourceHelper.GetLocalResxBasePath(virtualPath, theme);

                        }
                        // no context means that it's
            compile time and we don't support this
                        if (HttpContext.Current == null)
            return;

                        // read all resources for all
            cultures for this file                        string filter =
            Path.GetFileName(virtualPath) + &quot;*.resx&quot;;

                        if
            (!resourceCache.ContainsKey(virtualPath))

                        {

                            resourceCache[virtualPath] = new
            Dictionary&lt;CultureInfo,

                                                                      
             ResourceTuple&gt;();

                        }

                        foreach (string file in
            Directory.GetFiles(

                                                Path.GetDirectoryName(regPath),
            filter))

                        {

                            string[] pathParts =
            Path.GetFileName(file).Split(

                                                                        
            &quot;.&quot;.ToCharArray());

                            CultureInfo ci =
            CultureInfo.InvariantCulture;

                               if (pathParts.Length == 4)

                            {

                                // Example: In
            Default.aspx.de.resx =&gt; [2] is &quot;de&quot;

                                ci = new
            CultureInfo(pathParts[2]);

                            }

                            // per path and per culture
            we store a reader and a writer                           
            resourceCache[virtualPath].Add(ci,

                                       new ResourceTuple(new
            CustomResourceReader(file),

                                       new CustomResourceWriter(file)));

                        }
                    }

                    catch (Exception ex)

                    {

                        throw new
            ApplicationException(ex.Message, ex);

                    }

                }

                object IResourceProvider.GetObject(string
            resourceKey, CultureInfo culture)

                {

                    IResourceReader reader = null;

                    if (culture == null)

                    {

                        // if not explicitly defined
            take over page's UI culture                        culture =
            CultureInfo.CurrentUICulture;

                    }

                    do                    {

                        if
            (resourceCache[virtualPath].ContainsKey(culture))
                        {

                            // found it                            break;

                        }
                        else                        {

                            // try native culture                            culture = GetNativeCulture(culture);

                        }

                        // end of fallback path                        if (culture ==
            CultureInfo.InvariantCulture) break;

                    } while (reader == null);

                    reader =
            resourceCache[virtualPath][culture].Reader;

                    if (reader != null)

                    {

                        object value =
            ((CustomResourceReader)reader).GetObject(resourceKey);

                        MissHandler(ref value, resourceKey);

                        return value;

                    }

                    return null;

                }

                // get object from key and culture                public object GetResxObject(string
            resourceKey, CultureInfo culture)

                {

                    culture = GetNativeCulture(culture);

                    string uniqueKey = virtualPath;

                    ResXResourceReader rr = null;

                    object value = null;

                    // get the cached object or create
            it                    if (HttpContext.Current.Cache[uniqueKey]
            == null)
                    {

                        uniqueKey =
            XmlResourceHelper.GetResxPath(uniqueKey, theme,

                                                                 
            virtualPath == null, culture);

                        if (String.IsNullOrEmpty(uniqueKey))
            return &quot;RESX&quot;;

                        rr = new
            ResXResourceReader(uniqueKey);

                        HttpContext.Current.Cache[uniqueKey]
            = rr;

                    }

                    // Use resource reader to retrieve
            the value                    rr =
            (ResXResourceReader)HttpContext.Current.Cache[uniqueKey];

                    IDictionaryEnumerator id =
            rr.GetEnumerator();

                    while (id.MoveNext())

                    {

                        if
            (String.Compare(id.Key.ToString(), resourceKey, true) == 0)

                        {

                            value = id.Value;

                            break;

                        }

                    }

                    // check whether nothing has been
            found                    MissHandler(ref value, resourceKey);

                    // return                    return value;

                }

                private void MissHandler(ref object value,
            string resourceKey)

                {

                    // Create a generic value if
            resource object is missing                    if (value == null)

                    {

                        if
            (!resourceKey.Contains(&quot;.&quot;))

                        {

                            value =
            String.Format(&quot;Missing:{0}&quot;, resourceKey);

                        }

                        else                        {

                            switch
            (resourceKey.Substring(resourceKey.LastIndexOf(&quot;.&quot;)))

                            {

                                case &quot;.Visible&quot;:

                                    value = true;

                                    break;

                                case &quot;.Tooltip&quot;:

                                case &quot;.ToolTip&quot;:

                                    value = &quot;&quot;;

                                    break;

                                default:

                                case &quot;.Text&quot;:

                                    value =
            String.Format(&quot;Missing:{0}&quot;, resourceKey);

                                    break;

                            }

                        }

                    }

                    if (value == null) throw new
            ArgumentException(&quot;Unexpectadly found                                        an unresolvable
            missing resource: &quot; + resourceKey);

                }
                IResourceReader
            IResourceProvider.ResourceReader                {

                    get                    {

                        if
            (resourceCache.ContainsKey(virtualPath))

                        {

                            return
            resourceCache[virtualPath]

                                                [CultureInfo.InvariantCulture].Reader;
                        }

                        return null;

                    }

                }

                public IResourceWriter ResourceWriter                {

                    get                    {

                        if
            (resourceCache.ContainsKey(virtualPath))

                        {

                            return
            resourceCache[virtualPath]
                                                [CultureInfo.InvariantCulture].Writer;

                        }

                        return null;

                    }

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              The provider itself is not so simple. Firstly,
              we need to define the storage location and storage handling. The solution used
              in this example is based on .<i>resx</i> files. To improve performance, the
              provider retains a copy of the resources in an internal cache. This is global
              and therefore can be defined as static:
            </p>

            <pre>
              static Dictionary&lt;string,
              Dictionary&lt;CultureInfo, ResourceTuple&gt;&gt; resourceCache;
            </pre>
            <p>
              This is a nested <code>Dictionary</code>.
              The key to the outer dictionary is the resource key, which is
              either the <code>virtualPath</code> to a local resource or the <code>className</code>
              of a global one. For each resource, we need to handle multiple resource
              containers. There is one container per culture.
            </p>

            <p>
              The inner <code>Dictionary</code>
              contains these containers and employs the <code>CultureInfo</code>
              as the index to a particular container. The <code>Dictionary</code> value (the container) holds the appropriate reader and writer
              objects, which are of type <code>CustomResourceReader</code>
              and <code>CustomResourceWriter</code>. The <code>ResourceTuple</code> class is
              an inner helper class which stores the reader and writer objects and allows
              type-safe access to them.
            </p>

            <p>
              The provider is instantiated on
              a per file basis. Each local resource (<i>aspx</i> as well as <i>ascx</i> files)
              creates one provider. The same happens for each global resource. In the <code>GetResources</code>
              method, the provider immediately constructs the cache. The <code>
                HttpContext.Current
                == null
              </code> check ensures that the provider is not
              active at both design and compile time. The provider searches a designated
              directory from the <code>GetLocalResxBasePath</code>.
              This is a helper method specific to the required behavior. It creates the path
              to the <i>.resx</i> file based on both theme and local resource. In the example,
              the full path conforms to the pattern:
            </p>

            <p class="Query">App_Data/Resx/&lt;Theme&gt;/virtualPath/ResourceFile.&lt;Culture&gt;.ResourceType</p>

            <p>
              The <code>App_Data</code>
              folder is defined as the storage location. The <i>Resx</i> subfolder ensures that
              there is no conflict with other data stored there. The <i>&lt;Theme&gt;</i>
              part is a placeholder for the named theme. At a minimum, the default theme
              named “Default” must exist. The <i>virtualPath</i> is the path to the file that
              uses the resource within your project. <i>ResourceFile</i> is the name of the <i>aspx</i>
              or <i>ascx</i> file, and these extensions define the <i>ResourceType</i>. A
              full path could look like this:
            </p>

            <p class="Query">App_Data/Resx/MyTheme/storeFront/Basket.en-us.aspx</p>

            <p class="Query">App_Data/Resx/Default/storeFront/Basket.en-us.aspx</p>

            <p class="Query">App_Data/Resx/MyTheme/storeFront/Basket.de.aspx</p>

            <p class="Query">App_Data/Resx/Default/storeFront/Basket.de.aspx</p>

            <p>
              These examples show how to
              store different resources for one file (Basket.aspx) for different themes and
              cultures. The fallback resource file—the one without any culture information—is
              handled with the <code>CultureInfo.InvariantCulture</code> key.
            </p>

            <p>
              Once the cache is populated and
              the provider is loaded, the runtime requests the provider for a specific
              resource object using the <code>GetObject</code> method. This
              method is passed a key and the culture. Because each resource store has its own
              provider (based on the <code>virtualPath</code> member), this
              is sufficient information to retrieve the correct value. The goal of this
              method is to implement the fallback strategy. A <code>do</code>-<code>while</code>
              loop ascends the path of cultures to obtain an existing definition.
              Either it finds the invariant culture, or, as a final fallback, the default
              definition is used. You will need to create at least a default resource
              definition to avoid an exception being thrown if no resource is found.
            </p>

            <p>
              If the stored resources have
              been located, the <code>GetObject</code> method of the
              <code>CustomResourceReader</code> type is called to obtain the resource reader for the current
              culture. Remember that such an object exists per culture. The resource reader
              does not know anything about cultures; it only returns the value based on the
              resource key.
            </p>

            <p>
              During the process of resource
              creation, translation, and storing, some values may get lost. In this case, the
              resource reader would return <code>null</code>. The <code>MissHandler</code>
              method checks the value to assure valid content. Depending on the
              property retrieved (“.Text”, “.Tooltip” etc.), the method adds the prefix
              “Missing:”. This leads to a page that is shown without any exceptions, but with
              several text portions such as “Missing:Label1Text”. Authors can recognize the
              missing values and the name of the corresponding control, including the
              property that’s not properly set.
            </p>
            <p>
              So far there is nothing unusual
              about this code. The final step is to implement the resource reader.
            </p>

          </Element>
          <Element Type="Listing" Name="The resource reader used to retrieve a specific resource object">

            public class CustomResourceReader : IResourceReader
            {

                private Hashtable resources;

                public CustomResourceReader(string fileName)
                {

                    using (ResXResourceReader rr = new ResXResourceReader(fileName))
                    {

                        resources = new Hashtable();

                        IEnumerator enu = rr.GetEnumerator();
                        enu.Reset();

                        // Cache it in a Hashtable                        while (enu.MoveNext())
                        {

                         
            resources.Add(((DictionaryEntry)enu.Current).Key.ToString(),

                                         ((DictionaryEntry)enu.Current).Value);

                        }

                    }

                }

                IDictionaryEnumerator
            IResourceReader.GetEnumerator()
                {

                    return resources.GetEnumerator();

                }

                void IResourceReader.Close() {  }

                IEnumerator IEnumerable.GetEnumerator()

                {

                    return resources.GetEnumerator();

                }

                void IDisposable.Dispose()

                {

                }

                internal object GetObject(string
            resourceKey)

                {

                    return resources[resourceKey];

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              The resource reader is easy to
              implement because it still uses .<i>resx</i> files. The <code>ResXResourceReader</code>
              class from the <code>System.Resource</code>
              namespace provides almost everything we need. The only addition is another
              internal cache, to provide rapid read-write access to the underlying resources
              at runtime. This means that the resource reader must have read and write access
              to the <i>.resx</i> files. In the code, the <code>ResXResourceReader</code>
              loads each XML file, reads all the content, and copies it into the <code>Hashtable</code>.
              (A <code>Hashtable</code> is
              appropriate because the values are of  type <code>object</code> and a
              generic <code>List</code> would not have any advantages.) The class returns an enumerator used
              by the runtime to find keys. It also implements a <code>GetObject</code>
              method which retrieves the correct resource value using the <code>Hashtable</code> indexer.
            </p>

            <p>
              At this point, the resource
              provider could start working if any required resource is present in the
              appropriate files. The following sections describe the usage scenarios. Refer
              to the end of the chapter for more information about additional tasks, such as:
            </p>

            <ul>
              <li>
                Extending the provider by
                implementing a writer
              </li>
              <li>
                Adding support for the design-time
                experience
              </li>
              <li>
                Adding support for handling resources
                at both design-time and runtime
              </li>
              <li>
                Replacing the provider to access
                a database that stores the resources
              </li>
            </ul>

            <p>
              However, firstly we’ll put this into
              operation by starting the configuration step.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Configure the Resource Provider" >
          Configure the Resource Provider
          <Element Type="Text">

            <p>
              Because the provider is instantiated
              and called from a factory, registering the factory is a necessary step. This is
              a setting in the <i>web.config</i> file. In the <code>&lt;system.web&gt;</code>
              section, the following tag registers the custom factory:
            </p>

            <pre>
              &lt;globalization
              resourceProviderFactoryType=&quot;CustomResourceProviderFactory&quot;/&gt;
            </pre>
            <p>
              Whether to use just the class name or
              the fully-qualified assembly name depends on the implementation. If you write the
              class in a separate Visual Studio project, the fully-qualified name is required.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Using the Custom Resource Provider" >
          Using the Custom Resource Provider
          <Element Type="Text">

            <p>
              Now that everything is implemented and
              configured, you can start using the resources at runtime. As you can see in the
              implementation, classes distinguish between local and global resources. For
              local resources, the key is the name of either the <i>.aspx</i> or <i>.ascx</i>
              file. Internally, the <code>virtualPath</code> parameter retains
              this data. For global resources, the <code>classKey</code> parameter
              is used. To refer to these resources in your web pages, use the expression
              format:
            </p>
            <pre>
              &lt;%$ classKey:Resource %&gt;
            </pre>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Implementing Design-time Support" >
        Implementing Design-time Support
        <Element Type="Text">
          <p>
            Implementing design-time support is
            required for one feature only. In Visual Studio, you can add a resource’s meta
            attributes through the following:
          </p>
          <ul>
            <li>
              Open an <i>aspx</i> page or <i>ascx</i>
              control in the designer view
            </li>
            <li>
              In the “Tools” menu, click the “Generate
              Local Resource” item
            </li>
          </ul>
          <p>
            This will create a <code>meta:resourcekey</code>
            attribute for each localizable element. The provider is responsible
            for creating the corresponding entry in the resource file and writing the
            current values there. However, our current provider supports runtime operations
            only, and therefore we need an additional provider for design-time support.
          </p>
        </Element>
        <Element Type="SideBar" SidebarType="Note">
          <header>Note</header>
          <aside>
            If you’re sure that the Visual
            Studio design-time support option will never be used, you should not bother to  implement
            the design-time support classes. But it won’t harm your code if you do build it.
          </aside>
        </Element>
        <Element Type="Section" Name = "Register the Design-time Support" >
          Register the Design-time Support
          <Element Type="Text">
            <p>
              Firstly, you’ll need to register the design-time
              support. There is no such option in the <i>web.config</i> file; instead, an
              attribute is required. You can register your design-time classes by decorating
              the factory class like this:
            </p>
            <pre>
              [DesignTimeResourceProviderFactory(
                typeof(CustomDesignTimeResourceProviderFactory))]
              public sealed class CustomResourceProviderFactory : ResourceProviderFactory
            </pre>
            <p>
              The <code>CustomDesignTimeResourceProviderFactory</code>
              type defines another factory used at design-time. This factory is
              very similar to the one shown above, the difference being that the design-time
              support requires several specific actions:
            </p>

            <ul>
              <li>
                You don’t have a current theme
                at design-time; only one predefined theme can be supported (the default theme
                in the example code)
              </li>
              <li>
                You don’t have access to <code>HttpContext</code> to resolve paths
              </li>
              <li>
                You don’t have a current culture,
                so anything created at design-time is written into the fallback resource file
              </li>
            </ul>

            <p>
              The factory derives from the <code>DesignTimeResourceProviderFactory</code>
              base class. This abstract base class is defined as:
            </p>
            <pre>
              public abstract class DesignTimeResourceProviderFactory
              {
                  protected DesignTimeResourceProviderFactory();
                  public abstract IResourceProvider CreateDesignTimeGlobalResourceProvider(
                                  IServiceProvider serviceProvider, string classKey);
                  public abstract IResourceProvider CreateDesignTimeLocalResourceProvider(IServiceProvider serviceProvider);
                  public abstract IDesignTimeResourceWriter CreateDesignTimeLocalResourceWriter(IServiceProvider serviceProvider);
              }
            </pre>
            <p>
              As you can see, there are three
              methods and a constructor only. Two methods are similar to the runtime factory.
              They create and return the appropriate provider. The third method returns a
              resource writer. This writer explicitly supports the Visual Studio resource
              creation option available through the Tools menu.
            </p>

            <p>
              All these methods obtain the <code>serviceProvider</code> parameter. The design-time environment is also highly extensible.
              Visual Studio doesn’t know anything about the various controls handled within
              the designer. If it were to know, then every new or third party control would
              have to be installed and registered in Visual Studio. To avoid such a
              dependency, the control or the provider itself supplies all features required
              by Visual Studio to operate well. To determine whether a specific feature is
              supported, a service provider pattern is used. The <code>IServiceProvider</code> interface, implemented by Visual Studio, delivers a collection of
              services using its <code>GetService</code> method. The
              attached module or plug-in requiring these services requests the <code>GetService</code> method for a specific implementation.
            </p>

            <p>
              Finally, we’ll need access to
              the currently designed document. Visual Studio acts as a Designer Host,
              represented by the <code>IDesignerHost</code> interface.
              To access it, request the service in this manner:
            </p>

            <pre>
              IDesignerHost host;
              host = (IDesignerHost) _serviceProvider.GetService(typeof(IDesignerHost));
            </pre>
            <p>
              The idea behind this technique
              is that there is no direct dependency between the provider and the host. If you
              use another host—not Visual Studio—that is well implemented, your provider
              should still work. These methods also break the dependency on specific
              assemblies deployed with Visual Studio. Otherwise, when your code runs on a
              server, it would require Visual Studio to be installed there—a completely
              unreasonable prospect.
            </p>

            <p>
              Once you have the designer host,
              you can ask for the current root document.
            </p>

            <pre>
              WebFormsRootDesigner rootDesigner;
              rootDesigner = host.GetDesigner(host.RootComponent) as WebFormsRootDesigner;
            </pre>

            <p>
              This type is from <code>System.Web.UI.Design</code> and does not depend on Visual Studio. Using the
              <code>DocumentUrl</code> property, you have the full name of the file currently open in the
              designer view without any direct access to Visual Studio.
            </p>

            <p>
              With all these techniques in mind, it’s
              time to create the design-time factory:
            </p>

          </Element>
          <Element Type="Listing" Name="The design-time factory implementation">

            public sealed class
            CustomDesignTimeResourceProviderFactory :

                                DesignTimeResourceProviderFactory            {

                private DesignTimeResourceProvider
            globalResourceProvider;

                private DesignTimeResourceProvider
            localResourceProvider;

                private CustomDesignTimeResourceWriter
            localResourceWriter;

                private string _rootDocument;

                public override IResourceProvider
            CreateDesignTimeGlobalResourceProvider(

                                IServiceProvider
            serviceProvider, string classKey)

                {

                    // Return an IResourceProvider.

                    if (globalResourceProvider == null)

                    {

                        globalResourceProvider = new
            DesignTimeResourceProvider(classKey,

                                                     serviceProvider);

                    }

                    _rootDocument =
            globalResourceProvider.RootDocument;
                    return globalResourceProvider;

                }
                public override IResourceProvider
            CreateDesignTimeLocalResourceProvider(

                                                  IServiceProvider
            serviceProvider)

                {           

                    // Return an IResourceProvider                    if (localResourceProvider == null)

                    {

                        localResourceProvider = new
            DesignTimeResourceProvider(serviceProvider);

                    }

                    return localResourceProvider;

                }

                public override IDesignTimeResourceWriter
            CreateDesignTimeLocalResourceWriter(

                                                          IServiceProvider
            serviceProvider)

                {

                  if (localResourceWriter == null)

                  {      

                      // Get the host, usually Visual
            Studio                      IDesignerHost host = (IDesignerHost)
                                           serviceProvider.GetService(typeof(IDesignerHost));

                      // Get the designer currently represents
            the design view                      WebFormsRootDesigner rootDesigner =
            host.GetDesigner(host.RootComponent)

                                                          as
            WebFormsRootDesigner;

                      // Retrieve the local URL of the
            file currently opened in the designer                     _rootDocument =
            rootDesigner.DocumentUrl;

                      if (_rootDocument != null)

                      {

                         // Create the resource writer
            for this file                         localResourceWriter =
                                   new
            CustomDesignTimeResourceWriter(_rootDocument);

                      }

                  }

                  return localResourceWriter;

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              The factory returns both a
              global and a local design-time resource provider. Because we can’t access
              global resources in the Visual Studio environment, it’s the same provider class
              in both cases. Future versions or other applications might behave differently
              and the class design is ready for this. However, the <code>CreateDesignTimeLocalResourceWriter</code>
              method is of more interest to us. This method has a <code>serviceProvider</code> parameter containing the current designer host. As shown before,
              retrieving the URL of the current document is easy with the right services.
            </p>

            <p>
              If you’d like to extend the
              behavior, it’s a good idea to investigate the options by looking into the provider
              objects.
            </p>

            <p>
              <code>System.ComponentModel.Design.DesignerHost</code> provides the following properties out-of-the-box:
            </p>

            <ul>
              <li>
                <code>TransactionDescription</code>: This returns the transaction invoked from the user’s action, which
                is usually the “Generate Local Resource” string. That means that you can
                determine exactly what led to the call.
              </li>
              <li>
                <code>RootComponent</code>: The roots for the current transaction, whether it’s Page or
                Control or any derived type currently open in the designer surface. You might
                modify your action after recognizing the type.
              </li>
              <li>
                <code>CurrentCulture</code>: The culture run by the design-time host, which is usually the
                culture of the operating system. You might decide not to write a default
                fallback resource but instead write the specified culture. Visual Studio 2008 currently
                has no option to set the culture, but later versions might support this
              </li>
              <li>
                <code>IsDesignerViewLocked</code>: Returns either <code>true</code> or
                <code>false</code> depending on if the design-time surface is actually writeable.
              </li>
              <li>
                <code>IsLoading</code>.
                Must return <code>false</code>, otherwise the control is not
                completely loaded.
              </li>
              <li>
                <code>ReferenceManager</code> Returns the <code>
                  Microsoft.Web.Design.ReferenceManager
                </code> type. This type allows access to the <code>@Register</code>
                directives that the reference user controls. Use this to handle user controls
                directly instead of on a file-by-file basis.
              </li>
            </ul>

            <p>
              There are several methods to
              modify a document file by accessing the controls in it. However, these are
              beyond the scope of this chapter and left for you to investigate further.
            </p>

            <p>
              Another access method is more
              valuable to us. Besides the <code>IServiceProvider</code>
              interface, the parameter object also implements <code>System.Web.UI.Design.IWebFormsDocumentService</code>:
            </p>

            <pre>
              public interface IWebFormsDocumentService
              {

                  string DocumentUrl { get; }
                  bool IsLoading { get; }
                  event EventHandler LoadComplete;
                  object CreateDiscardableUndoUnit();
                  void DiscardUndoUnit(object discardableUndoUnit);
                  void EnableUndo(bool enable);
                  void UpdateSelection();
              }
            </pre>
            <p>
              Direct access to the <code>DocumentUrl</code> is the most important feature. In fact, this property does not
              return the URL but the full local path at design-time. This is exactly what we
              need. The interface also allows some interaction with undo management.
            </p>

          </Element>
          <Element Type="SideBar" SidebarType="Warning">

            <header>Warning</header>
            <aside>
              The <code>IWebFormsDocumentService</code> interface is marked as obsolete. Presumably Microsoft is going to transform
              the interface into its designated successor <code>WebFormsRootDesigner</code>. Actually, there is no information available as to when and with
              what consequences this will happen, but keep an eye on it.
            </aside>

          </Element>
          <Element Type="Text">

            <p>
              The design-time resource provider has
              support for both reading the current resource at design-time as well as writing
              from the designer surface using the appropriate command. It therefore implements
              two interfaces, <code>IResourceProvider</code> and <code>IDesignTimeResourceWriter</code>.
              The following code listing shows the whole implementation.
            </p>

          </Element>
          <Element Type="Listing" Name="The complete implementation of the design-time resource provider">

            internal sealed class
            DesignTimeResourceProvider :

                                  IResourceProvider,
            IDesignTimeResourceWriter            {

             

                private ResXResourceWriter _writer = null;

                private ResXResourceReader _reader = null;

                private string _rootDocument;

                internal string RootDocument                {

                    get { return _rootDocument; }

                }
                public
            DesignTimeResourceProvider(IServiceProvider serviceProvider) :

                       this(null, serviceProvider)

                {

                }

                public DesignTimeResourceProvider(string
            classKey,

                                                  IServiceProvider
            serviceProvider)

                {

                     // Get the forms designer provided
            by Visual Studio                     IWebFormsDocumentService formsDesigner =

                           serviceProvider.GetService(typeof(IWebFormsDocumentService))

                           as IWebFormsDocumentService;

                    if (formsDesigner == null)           

                    {

                        throw new
            NullReferenceException(&quot;IWebFormsDocumentService is null&quot;);

                    }

                    _rootDocument =
            formsDesigner.DocumentUrl;

                }

                object IResourceProvider.GetObject(string
            resourceKey, CultureInfo culture)

                {

                    if (_reader == null)

                    {

                        throw                        new
            NullReferenceException(&quot;IResourceProvider::ResourceReader::NULL&quot;);

                    }

                    object o = null;

                    IDictionaryEnumerator ide =
            _reader.GetEnumerator();

                    while (ide.MoveNext())

                    {

                        if
            (ide.Key.ToString().ToLowerInvariant().Equals(
                            resourceKey.ToLowerInvariant()))

                        {

                            o = ide.Value;

                            break;

                        }

                    }

                    return o;

                }

                IResourceReader
            IResourceProvider.ResourceReader                {

                    get                    {

                        if (_reader == null)

                        {

                            _reader = new
            ResXResourceReader(
                                XmlResourceHelper.GetInvariantResxPathAtDesignTime(

                                                                     
            _rootDocument));

                             // prepare same for writing                            _writer = new ResXResourceWriter(

                                XmlResourceHelper.GetInvariantResxPathAtDesignTime(

                                                                     
            _rootDocument));

                        }

                        if (_reader != null)

                        {

                            return _reader;
                        }

                        else                        {

                            throw new
            Exception(&quot;IResourceProvider::ResourceReader::NULL&quot;);

                        }

                    }

                }

                string
            IDesignTimeResourceWriter.CreateResourceKey(string resourceName,

                                                                   object
            obj)

                {

                    ((IResourceWriter)this).AddResource(resourceName,
            obj);

                    return resourceName;

                }

                void IResourceWriter.AddResource(string
            name, byte[] value)

                {

                    _writer.AddResource(name, value);

                }
                void IResourceWriter.AddResource(string
            name, object value)

                {
                    _writer.AddResource(name, value);

                }

                void IResourceWriter.AddResource(string
            name, string value)

                {

                    _writer.AddResource(name, value);

                }

                void IResourceWriter.Generate()

                {

                    _writer.Generate();

                }

                void IResourceWriter.Close()

                {

                    _writer.Close();

                }

                void IDisposable.Dispose()

                {

                    _writer.Close();

                    _writer.Dispose();

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              This implementation must support both the
              writing of resources when the user generates the local resource file as well as
              the reading of current resources when the file is opened for the first time in the
              designer surface. The full path to the currently loaded file is retrieved in
              the constructor by obtaining the <code>IWebFormsDocumentService</code> interface:
            </p>
            <pre>
              serviceProvider.GetService(typeof(IWebFormsDocumentService))
            </pre>
            <p>
              The <code>DocumentUrl</code>
              property will return what you need. The design-time environment will use the <code>IResourceProvider.ResourceReader</code>
              property first to retrieve the current values. In the code above, I
              created the reader as well as the writer because the function’s intention is to
              retrieve and write the values back. The helper class <code>XmlResourceHelper</code> is a private implementation which collects several methods needed
              in both the design-time and runtime provider. I’ve called <code>GetInvariantResxPathAtDesignTime</code>
              to obtain the full path of the <i>.resx</i> file. As mentioned above,
              the provider only supports the Default theme. The method points to the paths
              shown at the beginning of the section in a hard coded manner. You can find the
              full implementation of the class in the next code listing:
            </p>

          </Element>
          <Element Type="Listing" Name="Helper class to simplify developers’ life">

            internal static class XmlResourceHelper
            {

                private const string DESIGNTIME_THEME = &quot;Default&quot;;
                private static readonly char[] TRIMCHARS = &quot;/&quot;.ToCharArray();
                // The base path according to the example’s requirements            private static string BasePath
                {
                    get
                    {
                        if (HttpContext.Current == null)
                        {
                            return &quot;/App_Data/Resx/&quot;;
                        }
                        else
                        {
                            return HttpContext.Current.Server.MapPath(&quot;~/App_Data/Resx&quot;) +  Path.DirectorySeparatorChar;
                        }
                    }
                }

                // full path at design-time and runtime
                public static string GetFullPath(string regularPath, string theme, bool global)
                {

                    if (String.IsNullOrEmpty(theme)) throw new ArgumentNullException(&quot;theme&quot;);
                    string path = &quot;&quot;;

                    if (HttpContext.Current == null)

                    {

                        // assume compile time                        path =
            GetInvariantResxPathAtDesignTime(regularPath);

                    }

                    else                    {

                        try                        {

                            // Trim the path                            regularPath =
            Regex.Replace(regularPath,

                                                         HttpContext.Current.Request.

                                                         ApplicationPath.TrimStart(TRIMCHARS),

                                                         &quot;&quot;,

                                                         RegexOptions.IgnoreCase);

                            if (global)

                            {

                                path =
            String.Format(&quot;{0}{1}_Global&quot;, BasePath, theme,

                                                                    
             regularPath);

                            }

                            else                            {

                                path =
            String.Format(&quot;{0}{1}{2}&quot;, BasePath, theme, regularPath);

                            }

                        }

                        catch (Exception ex)

                        {

                            throw new Exception(ex.Message +
            ex.StackTrace);

                        }

                    }

                    return path;

                }

                // Get the local path to file for themed
            page resources                public static string
            GetLocalResxBasePath(string pageId, string theme)

                {

                    if (String.IsNullOrEmpty(pageId))

                    {

                        pageId = &quot;&quot;;

                    }

                    else                    {

                        pageId = Regex.Replace(pageId,

                                 HttpRuntime.AppDomainAppVirtualPath.TrimStart(TRIMCHARS),
            &quot;&quot;,
                                 RegexOptions.IgnoreCase);

                    }

                    pageId = pageId.Replace(&quot;..&quot;,
            &quot;.&quot;).TrimStart(TRIMCHARS).Replace('/',

                             Path.DirectorySeparatorChar);

                    // machine name dependant absolute
            path                    string file = String.Concat(BasePath,
            String.Format(&quot;{0}{2}{1}&quot;, theme,

                                                pageId, Path.DirectorySeparatorChar));

                    return file;

                }

                // Scaffold file name to resx file from
            given information                public static string GetResxPath(string
            pageId, string theme, bool global)

                {

                    pageId = Regex.Replace(pageId,
                             HttpRuntime.AppDomainAppVirtualPath.TrimStart(TRIMCHARS),
            &quot;&quot;,

                             RegexOptions.IgnoreCase);

                    string file = Path.Combine(BasePath,
            String.Format(&quot;{0}{2}{3}{1}.resx&quot;,

                                               theme,
            pageId, (global) ? &quot;_Global&quot; : &quot;&quot;,

                                               Path.DirectorySeparatorChar));

                    if (!File.Exists(file))

                    {

                        throw new
            FileNotFoundException(&quot;The resx file does not                                                          exists
            [GetInvariantResxPath]&quot;, file);

                    }

                    return file;
                }

                public static string GetResxPath(string
            pageId, string theme, bool global,

                                                 CultureInfo ci)

                {

                    pageId = Regex.Replace(pageId,

                            HttpRuntime.AppDomainAppVirtualPath.TrimStart(TRIMCHARS),
            &quot;&quot;,
                             RegexOptions.IgnoreCase);

                    string file = Path.Combine(BasePath,
            String.Format(&quot;{0}{2}{3}{1}.{4}.resx&quot;,

                        theme,

                        pageId,

                        (global) ? &quot;_Global&quot; :
            &quot;&quot;,  

                        Path.DirectorySeparatorChar,

                        ci.Name));

                    if (!File.Exists(file))

                    {

                        throw new
            FileNotFoundException(&quot;The resx file does not  

                                  exists [GetInvariantResxPath]&quot;,
            file);

                        //CreateFileIfNotExists(file);

                    }

                    return file;

                }

                // Scaffold the fallback resource file
            name locally at design-time                public static string
            GetInvariantResxPathAtDesignTime(string pagePath)

                {

                    // full path to file, need to get resx
            to invariant from this                    Uri uri = new
            Uri(pagePath);

                    string path =
            uri.LocalPath;

                    string file =
            String.Format(&quot;{0}{2}{3}{4}{2}{1}.resx&quot;,

                            Path.GetDirectoryName(path),

                            Path.GetFileName(path),

                            Path.DirectorySeparatorChar,

                            BasePath,

                            DESIGNTIME_THEME); // at design-time
            App_Data/Resx/Default                    if (!File.Exists(file))

                    {

                        CreateFileIfNotExists(file);

                    }

                    return file;
                }

                // Create file if one not exists                private static void
            CreateFileIfNotExists(string path)

                {

                    if
            (!Directory.Exists(Path.GetDirectoryName(path)))

                    {
                       
            Directory.CreateDirectory(Path.GetDirectoryName(path));

                    }

                    // Use ResXResourcerWriter to create
            the default resx format                    System.Resources.ResXResourceWriter RwX =  

                                 new
            System.Resources.ResXResourceWriter(path);

                    RwX.Generate();

                    RwX.Close();

                }

                #endregion            }

          </Element>
          <Element Type="Text">
            <p>
              The various path operations are
              a drawback of the file-based solution. However, a database driven project might
              need additional work to support database access at design-time. For the design-time
              portion, the <code>GetInvariantResxPathAtDesignTime</code> method is
              required. Because the <code>Uri</code> is built like any
              web <code>Uri</code>, it must be resolved and converted into a local file path. A bit of
              string concatenation will do the trick. If the file is not present, it will be
              created on the fly; this is the default behavior of Visual Studio.
            </p>

            <p>
              The creation of resource files
              is simple. The <code>ResXResourceWriter</code> class provides a <code>Generate</code>
              method that creates a file with unpleasant comments and schema
              codes. Calling <code>Close</code> flushes the content back to disk.
            </p>

          </Element>
          <Element Type="Image" Name="Figure 5-3 Resx files contain a comment (closed) and a full schema description">
            images/ASPEXTf0504.tif
          </Element>
          <Element Type="Text">

            <p>
              The <code>GetResxPath</code>
              method is called at compile time. The compiler needs to resolve the implicit
              expressions that define resources. To determine what values are required to be
              placed in the page, use the resource provider again. Since neither the <code>HttpContext</code>
              nor the design-time host exist at this point, we instead use the <code>HttpRuntime.AppDomainAppVirtualPath</code>
              property. The virtual path is defined at this stage and enables
              file paths to be resolved. The helper class is used to change the format
              slightly to meet our needs.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Debugging Design-time Extensions" >
          Debugging Design-time Extensions
          <Element Type="Text">
            <p>
              Design-time support should be part of
              any extension model. However, the difficulty of debugging these extensions is
              probably the reason why developers avoid adding design-time support to their
              applications. At design-time, there is no debugger attached. Therefore, you
              cannot easily add breakpoints or step into the code to see the internal
              processes. Using smart exceptions and try/catch blocks might help, but this is
              not a good debugging experience.
            </p>
            <p>
              To debug within the Visual Studio design-time
              environment must open another
              instance of Visual Studio and debug the code there. To do this, open the
              property pages of the Web project and activate the option <i>Start external program</i>.
            </p>
          </Element>
          <Element Type="Image" Name="Start another instance of Visual Studio to debug at design-time">
            images/ASPEXTf0407.tif
          </Element>
          <Element Type="Text">
            <p>
              As the external program, choose the
              Visual Studio executable, <i>devenv.exe</i>. When you start debugging the
              project by hitting F5, another instance of Visual Studio appears. Load the same
              project in this instance and launch the design-time environment. You can now
              set breakpoints in the first instance and debug as you would do at runtime. To
              get to specific code sections just start using the code within the second
              instance.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Edit Resources at Runtime" >
        Edit Resources at Runtime
        <Element Type="Text">
          <p>
            Now that we have flexible access to the
            resources, it is easy to implement additional options. Imagine a complex site
            that contains hundreds or thousands of resources. Several authors add content,
            change content, and add new languages. Doing so in XML files is very inefficient.
            Consider also the way translators usually work. Good translators might handle
            the content well, but dealing with XML is not their area of proficiency.
            Deploying a separate application to support their translation work introduces
            additional complications. Text portions often require a different translation
            depending on the context in which they appear. This context is lost when
            translating fragments of a sentence or single words.
          </p>
          <p>
            Editing content online would be a better
            option. However, handling resources the standard way (in files) and compiling them
            into binary resources precludes the saving of new content into the resources.
            In this section, I demonstrate how to use an extended resource provider model
            to access resource files online—anytime.
          </p>
        </Element>
        <Element Type="Section" Name = "How it Works" >
          How it Works
          <Element Type="Text">
            <p>
              In the previous sections, we looked at a
              different storage model. The provider still relays the files, but the file
              structure and availability is much more flexible. Most importantly, we have
              total control over it. To have access at runtime, a service must be able to
              open each .<i>resx</i> file, write new or changed content into it, and close
              the file.
            </p>
            <p>
              The only disadvantage with the
              provider reading the data directly from the .<i>resx</i> files is: how can we continue
              to use caching to improve performance?
            </p>
            <p>
              There are several options. For
              example, you could recognize the editing mode and suppress caching while editing.
              Alternatively, you could add a refresh button or link that forces the cache to
              be destroyed. Both options are easy to implement, but beyond the scope of this
              chapter.
            </p>
            <p>
              To access the resources from the
              client, we must find a way of communicating between the browser and the server.
              A web service and JavaScript could achieve this. As you only need JavaScript
              when editing pages—not when merely viewing pages—it’s a good idea to have a
              special master page containing all the JavaScript functions.
            </p>
            <p>
              From the perspective of the
              application, you’ll need to create the following functions:
            </p>
            <ul>
              <li>
                Retrieve supported languages and
                deliver as a web service
              </li>
              <li>
                Retrieve resources for the current
                page and language from the web service
              </li>
              <li>
                Write data back to the web service to
                store in the appropriate <i>.resx</i> file
              </li>
              <li>
                Extend the page to support the
                editing of the elements on a control by control basis
              </li>
              <li>
                Create an editor to allow editing
                the control’s content on the client
              </li>
            </ul>
            <p>
              The client portion is written in
              JavaScript, which has several functions:
            </p>
            <ul>
              <li>
                Create an editor to edit parts
                of a page
              </li>
              <li>Load current resource data from the server</li>
              <li>Save changed content back to the server</li>
              <li>
                Change the currently edited
                language
              </li>
            </ul>
            <p>
              In this example, I store the supported
              languages in another XML file, called <i>Cultures.xml</i>.
            </p>

          </Element>
          <Element Type="Listing" Name="The supported cultures stored as XML">

            &lt;?xml version=&quot;1.0&quot;
            encoding=&quot;utf-8&quot; ?&gt;

            &lt;Cultures&gt;

              &lt;CultureInfo Name=&quot;English&quot;
            id=&quot;en-Us&quot; /&gt;

              &lt;CultureInfo Name=&quot;Deutsch&quot;
            id=&quot;de-De&quot; /&gt;

              &lt;CultureInfo Name=&quot;Italiano&quot;
            id=&quot;it-It&quot; /&gt;

            &lt;/Cultures&gt;

          </Element>
          <Element Type="Text">

            <p>
              The web service method exposes this
              content to the client. To cache this information, I store the data during the application
              start.
            </p>

          </Element>
          <Element Type="Listing" Name="Retrieve supported cultures on application star">

            void Application_Start(object sender, EventArgs e)
            {

                XDocument xmlDoc = XDocument.Load(Path.Combine(Server.MapPath(&quot;~/App_Data&quot;),
                                                                            &quot;Cultures.xml&quot;));
                var cultures = from c in xmlDoc.Descendants(&quot;CultureInfo&quot;)
                               select new CultureInfo(c.Attribute(&quot;id&quot;).Value);
                Application[&quot;cultures&quot;] = cultures.ToList&lt;CultureInfo&gt;();
            }

          </Element>
          <Element Type="Text">

            <p>
              The service’s method transforms this
              into a serializable object that is easy to read on the client. Firstly, we need
              a web service class with the following definition:
            </p>

          </Element>
          <Element Type="Listing" Name="The web service’s class head">

            [ScriptService()]

            [WebService(Namespace = &quot;http://www.apress.com/ws&quot;)]

            [GenerateScriptType(typeof(Cultures))]

            [WebServiceBinding(ConformsTo =
            WsiProfiles.BasicProfile1_1)]

            public class ResourceService :
            System.Web.Services.WebService            {

              CustomResourceProviderFactory rf;

              public ResourceService()

              {

                 rf = new CustomResourceProviderFactory();

              }

               …

            }

          </Element>
          <Element Type="Text">

            <p>
              This definition makes the code available
              for JavaScript pages and defines a private data type, <code>Cultures</code>
              , as shown in the next code listing. Additionally, the constructor
              prepares the factory we created earlier in this chapter to obtain access to the
              resources. This means that the majority of code is in the existing classes, and
              leaves us with only a few tasks:
            </p>

          </Element>
          <Element Type="Listing" Name="The supported cultures exposed via a service">

            [WebMethod()]

            public Cultures GetAllLanguages()

            {

                List&lt;CultureInfo&gt; cList =
            (List&lt;CultureInfo&gt;)Application[&quot;cultures&quot;];

                Cultures c = new Cultures(cList.Count);

                for (int i = 0; i &lt; cList.Count; i++)

                {
                    c.cultureName[i] = cList[i].DisplayName;

                    c.cultureID[i] = cList[i].Name;

                }

                return c;

            }

            [Serializable()]

            public class Cultures            {

                public Cultures() : this(2)

                {
                }

                public Cultures(int len)

                {

                    this.len = len;

                    cultureName = new string[len];

                    cultureID = new string[len];

                }

                public string[] cultureName;

                public string[] cultureID;

                public int len;

            }

          </Element>
          <Element Type="Text">

            <p>
              The remaining tasks required of the web
              service are coded in two methods—<code>LoadResource</code>
              and <code>SaveResource</code>. Both receive four parameters:
            </p>
            <ul>
              <li>
                <code>pageId</code>: The
                name of the resource file, which names the <i>aspx</i> or <i>ascx</i> file
              </li>
              <li>
                <code>ctrlId</code>: The
                Id of the control requesting the resource. This includes the property name, such
                as <i>Label1Resource1.Text</i>.
              </li>
              <li>
                <code>culture</code>: The
                id of the culture, such as “en-us” or “de-de”.
              </li>
              <li>
                <code>theme</code>: The
                current theme that the resource is written to or read from. This is the special
                extension, as explained at the beginning of the chapter. If themed resources
                are not a requirement, you can safely remove this parameter.
              </li>
            </ul>
            <p>
              The next code listing illustrates the
              methods. The <code>SaveResource</code> method has one additional
              parameter called <code>content</code> that contains
              the data to be written into the resource file. The <code>LoadResource</code>
              method returns exactly that value using the same parameters.
            </p>

          </Element>
          <Element Type="Listing" Name="Web methods to load and save resources directly from the client">

            [WebMethod()]

            public string LoadResource(string pageId, string
            ctrlId,
                                       string culture,
            string theme)

            {

                pageId = pageId.Replace(&quot;~&quot;,
            &quot;&quot;);

                rf.Theme = theme;

                IResourceProvider rp =
            rf.CreateLocalResourceProvider(pageId);

                object value = ((CustomResourceProvider)rp).GetResxObject(

                                                            
            ctrlId, new CultureInfo(culture));

                return (value == null) ? String.Empty :
            value.ToString();

            }

            [WebMethod()]

            public void SaveResource(string pageId, string
            ctrlId,

                                     string content, string
            culture, string theme)

            {

                pageId = pageId.Replace(&quot;~&quot;,
            &quot;&quot;);

                rf.Theme = theme;

                IResourceProvider rp =
            rf.CreateLocalResourceProvider(pageId);

                CultureInfo ci = new CultureInfo(culture);
               ((CustomResourceProvider)rp).GetResourceWriter(ci).AddResource(ctrlId,

                                                                              
            content);

            }
          </Element>
          <Element Type="Text">

            <p>
              There are some additional steps
              required. To display and enable the editor, you’ll need to prepare the page. To
              avoid including all the JavaScript in the page, another master page is used.
              With two different master pages, you can decide which one to use, depending on
              whether the page is displayed in edit mode or not. Changing the master page
              dynamically requires access to the page’s <code>PreInit</code>
              event.
            </p>

          </Element>
          <Element Type="Listing" Name="Changing the master page and theme programmatically">

            public partial class _Default : BasePage            protected override void OnPreInit(EventArgs e)

            {

              base.OnPreInit(e);

              // Set Editor (special handling beyound the
            domain scope)

              if (Request.QueryString[&quot;e&quot;] != null
            &amp;&amp; Request.QueryString[&quot;e&quot;] == &quot;on&quot;)

              {

                Session[&quot;Editor&quot;] = true;

              }

              if (Request.QueryString[&quot;e&quot;] != null
            &amp;&amp; Request.QueryString[&quot;e&quot;] == &quot;off&quot;)

              {

                Session[&quot;Editor&quot;] = null;

              }
              string domain = Request.Url.Host;

              // Set Dynamic Theming and Master Pages              if (Session[&quot;Editor&quot;] != null)
              {

                Master.MasterPageFile =
            &quot;editor.master&quot;;

              }

              else              {

                Master.MasterPageFile =
            &quot;default.master&quot;;

              }

              if (Session[&quot;theme&quot;] != null)

              {

                Theme = Session[&quot;theme&quot;] as
            string;

              }

            }

          </Element>
          <Element Type="Text">
            <p>
              As you can see from the code, a
              QueryString parameter is used to switch between the master pages with editing
              capabilities enabled or disabled. Just append <code>?e=on</code> to the
              URL, and the editor will appear. Once enabled, a session variable retains the
              state. To switch the editor off on the fly add <code>?e=off</code>. This
              is only a suggestion—you may find smarter ways of achieving this. Now we need
              to build the master page to support the necessary features.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Creating an Online Editor" >
          Creating an Online Editor
          <Element Type="Text">
            <p>
              For the online editor to function, the
              JavaScript on the page must handle all controls and call the web service’s
              methods with the right parameters. The first step is preparation. Each control
              on the page must be tested for the presence of the <code>meta:resourcekey</code> attribute. If this exists, then a connected resource is available,
              and the editor should handle this control. To achieve this, the <code>ReadControls</code> method loops through all the controls. The
              <code>Init</code> event is the right place in the pipeline for this method call, as
              the controls are ready to go at that stage. Later, in the <code>PreRender</code> event, the code uses the data collected here to add the JavaScript
              calls.
            </p>

            <p>
              To test for the attribute, a regular
              expression is used. This may seem strange, since we have an object model which
              we could access directly. However, although the object model is present, the
              implicit resource expressions have already been replaced by code snippets at
              the page parser stage. The <code>meta:resourcekey</code>
              attributes do not exist in the object model. Your only option is to parse the
              source code of the page directly and to virtually add another parser cycle
              after the internal one.
            </p>

          </Element>
          <Element Type="SideBar" SidebarType="Note">
            <header>Note</header>
            <aside>
              The page must exist at runtime
              with full markup available. Pre-compiled sites with hidden source will not work
              with this example.
            </aside>

          </Element>
          <Element Type="Text">

            <p>
              The next code listing shows the methods
              that parse the page, collect the controls, and add the required JavaScript.
              Because the scripting is a little tricky, it’s explained afterwards in more
              depth.
            </p>

          </Element>
          <Element Type="Listing" Name="The master page with the default setting for regular expression">

            public partial class EditorMasterPage :
            System.Web.UI.MasterPage            {

                private static Regex rx;

                private Dictionary&lt;string, Dictionary&lt;string,
            string&gt;&gt; pages;

                static EditorMasterPage()

                {

                    rx = new
            Regex(@&quot;\&lt;(?&lt;tagName&gt;\w+(:\w+){0,1}) (?&lt;attr&gt;[^&gt;]*)
            ?&gt;&quot;,

                             RegexOptions.ExplicitCapture |
                             RegexOptions.Multiline |

                             RegexOptions.IgnoreCase |

                             RegexOptions.IgnorePatternWhitespace);

                }

          </Element>
          <Element Type="Text">

            <p>
              The regular expression simply
              addresses a tag with several attributes and returns the matching element as a
              collection of named arrays. This array contains all tags on the page captured
              with the key <code>&lt;tagName&gt;</code> and the attributes
              block—the remaining part of the element—with the key <code>&lt;attr&gt;</code>. An element like &lt;asp:button runat=”server”
              meta:resourcekey=”ButtonRes1” /&gt; would be divided into the “asp:button” part
              and the “runat=”server” meta:resourcekey=”ButtonRes1” part in the first step.
            </p>

            <p>
              Regular expressions are beyond
              the scope of this book; please refer to the documentation if you have
              difficulties reading this expression. For the moment, it’s sufficient to know
              that the string fragments recognized by the expression are collected in named
              arrays, whereas the names are defined in <code>&lt;angle brackets&gt;</code>. The attributes are splitted into single ones by using the space as
              a divider.
            </p>

          </Element>
          <Element Type="Listing" Name="Analysing the controls regarding the meta:resourcekey attribute">
            protected override void OnInit(EventArgs e)

            {

              pages = new Dictionary&lt;string,
            Dictionary&lt;string, string&gt;&gt;();

             
            ReadControls(this.Page.AppRelativeVirtualPath);

              base.OnInit(e);
            }

            privat void ReadControls(string path) {

              if (!pages.ContainsKey(path))

              {

                StreamReader sr = new
            StreamReader(Server.MapPath(path));

                string s = sr.ReadToEnd();
                sr.Close();

                pages.Add(path, new Dictionary&lt;string,
            string&gt;());

                MatchCollection mc = rx.Matches(s);

                foreach (Match m in mc)

                {

                  Group g = m.Groups[&quot;attr&quot;];

                  if (g != null) 

                  {
                    string[] attributes =
            g.Value.Split(&quot; &quot;.ToCharArray(),

                                          StringSplitOptions.RemoveEmptyEntries);

                    string key = null, id = null;

                    foreach (string attr in attributes)

                    {

                      if
            (attr.StartsWith(&quot;meta:resourcekey&quot;))

                      {

                        string param =
            attr.Split(&quot;=&quot;.ToCharArray())[1].Trim();

                        key = param.Substring(1,
            param.Length - 2);

                      }

                      if (attr.StartsWith(&quot;id&quot;,
            StringComparison.InvariantCultureIgnoreCase))

                      {

                        string[] fragments =
            attr.Split(&quot;=&quot;.ToCharArray());

                        if (fragments.Length == 2) {

                          string param =
            fragments[1].Trim();

                          id = param.Substring(1,
            param.Length - 2);

                        }
                      }

                    }

                    if (!String.IsNullOrEmpty(id) &amp;&amp;
            !(String.IsNullOrEmpty(key)))

                    {

                      // need to support server transfer                      if (!pages[path].ContainsKey(id))  
                      {

                        pages[path].Add(id, key);

                      }

                    }

                  }
                }

              }

            }

          </Element>
          <Element Type="Text">

            <p>
              The collection pages contain data from all
              the files scanned so far. Remember that a page can contain several user
              controls, and that these controls must become available at the same time. For
              each page, we store the control’s id and resource key. This makes it possible
              to access the control, based on its id, and the resource, based on its key.
              Once all the data has been collected, the page is processed normally. In <code>PreRender</code>, the information is used to add the JavaScript calls.
            </p>

          </Element>
          <Element Type="Listing" Name="Add editing capability to the collected controls">

            protected override void
            OnPreRender(EventArgs e)

            {

              foreach (string name in
            this.ContentPlaceHolders)
              {

                ContentPlaceHolder cph =
            (ContentPlaceHolder)FindControl(name);

                ControlCollection cc = cph.Controls;

                this.NavigateControls(cc);

              }

              base.OnPreRender(e);

            }

          </Element>
          <Element Type="Text">
            <p>
              This is only the first part—the entry
              point. Assuming we’re operating on a page that uses a master page—a
              prerequisite for this solution—we’ll need to handle the <code>ContentPlaceHolders</code>
              . Each such control is processed as its own container. The <code>NavigateControl</code> method works recursively.
            </p>

          </Element>
          <Element Type="Listing" Name="Navigating all controls and adding the required script (the next listing)">

            private void
            NavigateControls(ControlCollection cc)

            {

                string path = String.Empty;

                for (int i = 0; i &lt; cc.Count; i++)

                {

                    Control ctl = cc[i];

                    // updatepanel container might have no
            id, but children                    if (ctl != null &amp;&amp; (ctl.ID !=
            null || ctl.HasControls()))

                    {               

                        if (ctl.HasControls())

                        {

                            if (ctl is UserControl
            &amp;&amp;

                               
            !(ctl.GetType().Name.Contains(&quot;collapseliteral&quot;)) &amp;&amp;

                               
            !(ctl.GetType().Name.Contains(&quot;pageheader&quot;)))

                            {

                                path =
            ctl.TemplateControl.AppRelativeVirtualPath;

                            }

                            else                            {

                                path =
            ctl.Page.AppRelativeVirtualPath;

                            }

                            ReadControls(path);

                           
            this.NavigateControls(ctl.Controls);                   

                            if (!pages.ContainsKey(path))
            continue;

                            if (ctl.ID == null) continue;

                            if
            (!pages[path].ContainsKey(ctl.ID)) continue;

                            string ctlKey =
            pages[path][ctl.ID];

                            if (ctlKey != null)

                            {

                                if (ctl is UserControl)

                                {

                                    AddEditorControl(ctl,
            path, ctlKey, i);

                                }

                            }

                        }
                        else                        {

                            path =
            ctl.TemplateControl.AppRelativeVirtualPath;

                            if (!pages.ContainsKey(path))
            continue;

                            if
            (!pages[path].ContainsKey(ctl.ID)) continue;

                            string ctlKey =
            pages[path][ctl.ID];

                            if (ctlKey != null)

                            {
                                switch (ctl.GetType().Name)

                                {

                                    case
            &quot;ValidationSummary&quot;:

                                        continue;

                                    case
            &quot;WebPartZone&quot;:

                                        // access the
            webparts, which are not part                                        // of the control
            collection                                        foreach (Control
            part in ((WebPartZone)ctl).WebParts)

                                        {

                                            path =
            part.Controls[0].TemplateControl.

                                                   AppRelativeVirtualPath;

                                           
            AddEditorControl(part, path, ctlKey, i);

                                        }

                                        break;

                                    default:

                                       
            AddEditorControl(ctl, path, ctlKey, i);                               

                                        break;

                                }
                                cc = ctl.Parent.Controls;

                            }

                        }

                    }

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              The final step for each valid control located
              is to call the <code>AddEditorControl</code> method. The methods add
              a small image (8x8 pixel) which appears near the control, allowing the user to
              click there and open the editor. Different images express different states:
            </p>
            <ul>
              <li>
                <i>validator.gif</i>: The
                control is a validator. The control itself might be invisible depending on the
                page’s validation state. However, the editor control is present.
              </li>
              <li>
                <i>webpart.gif</i>: Webparts do not
                handle resources, but they have additional content which might contain resources.
              </li>
              <li>
                <i>resx.gif</i>: Regular control with
                previously added resources
              </li>
              <li>
                <i>edit.gif</i>: Regular control with
                no attached resources
              </li>
            </ul>
            <p>
              Additionally, a tooltip is created in
              order to inform the user about the control beneath the mouse pointer. This is helpful
              as, on complex pages, it isn’t always possible to align the image exactly.
            </p>

          </Element>
          <Element Type="Listing" Name="Adding the script code">

            private void AddEditorControl(Control ctl,
            string path, string ctlKey, int i)

            {

                bool HasRes = false;

                string[] attributeList =
            GetPossibleResourceList(ctl);

                HasRes = this.GetLocalResource(path, ctlKey,
            attributeList);

                StringBuilder sb = new StringBuilder();

                using (StringWriter sw = new
            StringWriter(sb))
                {

                    HtmlTextWriter ht = new
            HtmlTextWriter(sw);

                   
            ht.AddStyleAttribute(HtmlTextWriterStyle.Display, &quot;inline&quot;);

                   
            ht.AddStyleAttribute(HtmlTextWriterStyle.Cursor, &quot;hand&quot;);

                   
            ht.AddStyleAttribute(HtmlTextWriterStyle.Position, &quot;relative&quot;);

                   
            ht.AddStyleAttribute(HtmlTextWriterStyle.Left, &quot;-8&quot;);

                   
            ht.AddStyleAttribute(HtmlTextWriterStyle.Top, &quot;-8&quot;);

                   
            ht.AddStyleAttribute(HtmlTextWriterStyle.ZIndex, &quot;100000&quot;);

                    if (HasRes)

                    {

                        if (ctl is IValidator)

                        {

                            ht.AddAttribute(&quot;src&quot;,
            Request.ApplicationPath +

                                            &quot;/images/Resxeditor/validator.gif&quot;);

                        }

                        else if (ctl is IWebPart)

                        {
                            ht.AddAttribute(&quot;src&quot;,
            Request.ApplicationPath +

                                            &quot;/images/Resxeditor/webpart.gif&quot;);

                        }

                        else                        {

                            ht.AddAttribute(&quot;src&quot;,
            Request.ApplicationPath +

                                            &quot;/images/Resxeditor/resx.gif&quot;);
                        }

                    }

                    else                    {

                        ht.AddAttribute(&quot;src&quot;,
            Request.ApplicationPath +
                                        &quot;/images/Resxeditor/Edit.png&quot;);

                    }

                    ht.AddAttribute(&quot;width&quot;,
            Unit.Pixel(8).ToString());

                    ht.AddAttribute(&quot;height&quot;,
            Unit.Pixel(8).ToString());

                    // Add all required data as
            attributes to let loading them from JScript                    bool allowHtml = (ctl is Literal) ||
            (ctl is LiteralControl) ||

                                     (ctl is
            HtmlGenericControl) ||

                                     (ctl.GetType().Name.Contains(&quot;collapseliteral&quot;));

                    ht.AddAttribute(&quot;allowHtml&quot;,
            (allowHtml) ? &quot;true&quot; : &quot;false&quot;);

                    ht.AddAttribute(&quot;pageID&quot;,
            path);

                   
            ht.AddAttribute(&quot;ctrlClientID&quot;, ctl.ClientID);

                    ht.AddAttribute(&quot;ctrlID&quot;,
            ctlKey);

                    ht.AddAttribute(&quot;attributes&quot;,
            String.Join(&quot;,&quot;, attributeList));

                        ht.AddAttribute(&quot;alt&quot;,
            String.Format(&quot;Type (What?):{0}\n                                                           Name
            (Who?):{1}\n                                                          
            Content (Why?):{2}\n                                                           Container
            (Where?):{3}\n                                                          
            State (How?):{4}&quot;,

                                     ctl.GetType().Name,

                                     ctlKey,

                                     (allowHtml) ?
            &quot;HTML&quot; : &quot;Text&quot;,

                                     path,

                                     (ctl.Visible) ?
            &quot;Visible&quot; : &quot;Hidden by Default&quot;));

                    // make the icon clickable                    ht.AddAttribute(&quot;onclick&quot;,

                    String.Format(&quot;showEditor({0},
            this); return false;&quot;, (allowHtml) ? 1 : 0));

                    ht.RenderBeginTag(HtmlTextWriterTag.Img);

                    ht.RenderEndTag();

                    LiteralControl lb = new
            LiteralControl(sb.ToString());

                    ctl.Parent.Controls.AddAt(i + 1, lb);

                }

            }

            // Check for existence of a local resource
            to modify icon            private bool GetLocalResource(string path,
            string ctrlId, string[] reslist)

            {

                bool hasRes = false;

                for (int i = 0; i &lt; reslist.Length; i++)

                {

                    try                    {

                        if (reslist[i] != null)

                        {

                            string resId =
            String.Format(&quot;{0}.{1}&quot;, ctrlId, reslist[i]);

                            object oValue =
            HttpContext.GetLocalResourceObject(path, resId,

                                            Thread.CurrentThread.CurrentCulture);

                            if (oValue != null)

                            {

                                hasRes = true;

                                break;

                            }
                        }
                        else                        {
                            break;
                        }

                    }

                    catch { }

                }
                return hasRes;

            }

            // Return a list of supported properties by
            this editor (extend at your will)

            private string[] GetPossibleResourceList(Control
            _Control)

            {

                List&lt;string&gt; res = new
            List&lt;string&gt;();

                switch (_Control.GetType().ToString())

                {  

                    case
            &quot;System.Web.UI.WebControls.Literal&quot;:

                        res.Add(&quot;Text&quot;);

                        break;

                    case
            &quot;System.Web.UI.WebControls.DropDownList&quot;:

                        res.Add(&quot;ToolTip&quot;);

                        break;

                    case
            &quot;System.Web.UI.WebControls.Menu&quot;:

                        res.Add(&quot;ScrollDownText&quot;);

                        res.Add(&quot;ToolTip&quot;);

                        res.Add(&quot;ScrollUpText&quot;);

                        res.Add(&quot;SkipLinkText&quot;);

                        break;

                    case
            &quot;System.Web.UI.WebControls.TextBox&quot;:

                        res.Add(&quot;ToolTip&quot;);

                        res.Add(&quot;Text&quot;);

                        break;

                    default:

                        if (Control is IWebPart)

                        {

                            // internally set title                            res.Add(&quot;Text&quot;);

                        }

                        else if (_Control is IValidator)

                        {

                            res.Add(&quot;Text&quot;);

                            res.Add(&quot;ToolTip&quot;);

                           
            res.Add(&quot;ErrorMessage&quot;);

                        } else {
                            res.Add(&quot;Text&quot;);

                            res.Add(&quot;ToolTip&quot;);

                        }

                        break;

                }

                return res.ToArray();

            }

            // Resolve place holders in case of master
            page driven web site            private Control GetAndFindInPlaceHolder(string
            controlName)

            {

                MasterPage mp =
            (MasterPage)this.Page.Master;

                PropertyInfo pi =
            mp.GetType().GetProperty(&quot;ContentPlaceHolders&quot;,
                                               System.Reflection.BindingFlags.Instance                                               System.Reflection.BindingFlags.NonPublic);
                IList names = (IList) pi.GetValue(mp,
            null);       

                foreach (string name in names)

                {

                    ContentPlaceHolder cph =
            (ContentPlaceHolder)MainContent.FindControl(name);

                    if (cph != null)

                    {

                        Control c =
            cph.FindControl(controlName);

                        if (c != null)

                        {
                            return c;

                        }

                    }

                }

                return null;
            }

          </Element>
          <Element Type="Text">

            <p>
              The <code>GetPossibleResourceList</code> method contains a hard coded sequence of supported attributes. This
              solution, therefore, does not support all the possible properties of a control.
              Extending the method is trivial. It takes much more effort to create the
              JavaScript-based editor to add the content. As long as it’s text, simple
              controls will achieve this. However, editing image paths or colors would
              require more work.
            </p>

            <p>
              To understand the entire code, a
              glance at the result might help:
            </p>

          </Element>
          <Element Type="Listing" Name="A typical JavaScript sequence created with the above code">

            &lt;img src=&quot;/DemoApplication/images/Resxeditor/resx.gif&quot;
              width=&quot;8px&quot; height=&quot;8px&quot;
              allowHtml=&quot;false&quot;
              pageID=&quot;~/Default.aspx&quot;  
              ctrlClientID=&quot;ctl00_ctl00_MainContent_MainContent_LinkButtonTheme1&quot;
              ctrlID=&quot;LinkButtonTheme1Resource1&quot;
              attributes=&quot;Text,ToolTip&quot; alt=&quot;Tooltip&quot;
              onclick=&quot;showEditor(0, this); return false;&quot;
              style=&quot;display:inline;cursor:hand;position:relative;left:-8;top:-8;z-index:100000;&quot; /&gt;

          </Element>
          <Element Type="Text">

            <p>
              Before defining the JavaScript editor
              itself, here is the working editor:
            </p>

          </Element>
          <Element Type="Image" Name="The page in edit mode">
            images/ASPEXTf0504.tif
          </Element>
          <Element Type="Text">

            <p>
              After clicking on one of the small icons,
              which represents a resource, the editor appears.
            </p>

          </Element>
          <Element Type="Image" Name="The editor in action">
            images/ASPEXTf0505.tif
          </Element>
          <Element Type="Text">

            <p>
              The editor needs access to the web
              service method we defined earlier. To achieve this, a <code>ScriptManager</code>
              control is helpful. It references the web service definition.
            </p>

          </Element>
          <Element Type="Listing" Name="The supported cultures exposed via a service">

            &lt;asp:ScriptManager
            ID=&quot;ScriptManager1&quot; runat=&quot;server&quot;

            EnablePartialRendering=&quot;False&quot;&gt;

              &lt;services&gt;

                &lt;asp:ServiceReference
            path=&quot;~/ResxEditor/ResourceService.asmx&quot; /&gt;

              &lt;/services&gt;

            &lt;/asp:ScriptManager&gt;

          </Element>
          <Element Type="Text">

            <p>
              More code is required for the editor
              itself. This is accomplished via a user control on the editor master page. The
              first block of code is sourced from CodeLifter.com—it creates a draggable popup
              window. As it’s helpful to view the resources in the context of the page, let
              the user move the window around and make hidden parts of the surface
              accessible.
            </p>
          </Element>
          <Element Type="Listing" Name="The JavaScript editor defined in the edit.ascx control, part 1: the drag window">

            &lt;%@ Control Language=&quot;C#&quot;
            AutoEventWireup=&quot;false&quot; CodeFile=&quot;edit.ascx.cs&quot;
            Inherits=&quot;edit&quot; %&gt;

            &lt;script language=&quot;JavaScript1.2&quot;
            type=&quot;text/javascript&quot;&gt;

                // Script Source: CodeLifter.com                // Copyright 2003                // Do not remove this header                isIE = document.all;

                isNN = !document.all &amp;&amp;
            document.getElementById;

                isHot = false;

                function ddInit(e) {

                    topDog = isIE ? &quot;BODY&quot; :
            &quot;HTML&quot;;

                    hotDog = isIE ? event.srcElement :
            e.target;

                    while (hotDog.id != &quot;titleBar&quot;
            &amp;&amp; hotDog.tagName != topDog) {

                        hotDog = isIE ? hotDog.parentElement
            : hotDog.parentNode;

                        if (hotDog == null || hotDog.id ==
            null || hotDog.tagName == null)

                            return;

                    }

                    if (hotDog.id == &quot;titleBar&quot;) {
                        offsetx = isIE ? event.clientX :
            e.clientX;

                        offsety = isIE ? event.clientY :
            e.clientY;

                        nowX =
            parseInt(whichDog.style.left);

                        nowY = parseInt(whichDog.style.top);

                        ddEnabled = true;

                        document.onmousemove = dd;

                    }

                }

                function dd(e) {

                    if (!ddEnabled) return;

                    whichDog.style.left = isIE ?

                                    nowX + event.clientX -
            offsetx : nowX + e.clientX - offsetx;

                    whichDog.style.top = isIE ?

                                    nowY + event.clientY -
            offsety : nowY + e.clientY - offsety;

                    return false;

                }

                function hideMe() {

                    whichDog.style.visibility =
            &quot;hidden&quot;;

                }

                function showMe() {

                    whichDog.style.visibility =
            &quot;visible&quot;;

                }

                document.onmousedown = ddInit;

                document.onmouseup =
            Function(&quot;ddEnabled=false&quot;);

            &lt;/script&gt;

          </Element>
          <Element Type="Text">

            <p>
              This code portion is shown for
              completeness. It is used to move the editor window around. When editing the
              page, it’s helpful to see the page which might be partly hidden by the overlaid
              window.
            </p>

          </Element>
          <Element Type="Listing" Name="The JavaScript editor defined in the edit.ascx control, part 2: the resource access">

            &lt;script language=&quot;javascript&quot;
            type=&quot;text/javascript&quot;&gt;

                var parentObj;

                function showMessage(msg) {

                    var label = document.getElementById('MessageLabel')

                    label.innerText = msg;

                    label.style.display = (msg.length == 0)
            ? 'none' : 'block';

                    label.style.color = &quot;#00FF33&quot;;

                }

                function showError(msg) {

                    var label =
            document.getElementById('MessageLabel')

                    label.innerText = msg;

                    label.style.display = (msg.length == 0)
            ? 'none' : 'block';

                    label.style.color = &quot;#FF0000&quot;;

                }

                // These functions call the Web Service
            method. 

                function initLanguages() {

                    showMessage(&quot;Calling
            Server...&quot;);

                   
            ResxEditor.ResourceService.GetAllLanguages(initLanguagesCallback,

                                                              
            initLanguagesError);

                }

                function initLanguagesCallback(result) {

                    var selLoad =
            document.getElementById('ResxLanguageSelector');

                    var selCopy =
            document.getElementById('ResxCopySelector');

                    selLoad.options.length = 0;

                    selCopy.options.length = 0;

                    for (i = 0; i &lt; result.len; i++) {

                        selLoad.options[i] = new
            Option(result.cultureName[i],

                                                        result.cultureID[i]);
                        selCopy.options[i] = new
            Option(result.cultureName[i],

                                                        result.cultureID[i]);

                    }

                    showMessage(&quot;&quot;);

                   
            document.getElementById('theContentContainer').setAttribute(&quot;disabled&quot;,

                                                                                 
            false);

                }

                function initLanguagesError(error) {

                    showError(error.get_message());

                }

                function saveMe() {

                    showMessage(&quot;Save the data...&quot;);

                    var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);
                    var ctrlId = parentObj.getAttribute(&quot;ctrlID&quot;);

                    var theme = '&lt;% = Theme %&gt;';

                    var tb = document.getElementById('&lt;%
            = EditTextBox.ClientID %&gt;').innerText;

                    var sel =
            document.getElementById('ResxLanguageSelector');

                    if (sel.options.length &gt; 0) {

                        var culture =
            sel.options[sel.selectedIndex].value;

                        // Text                       
            ResxEditor.ResourceService.SaveResource(pageId, ctrlId + &quot;.Text&quot;,

                                                               
            tb, culture, theme,

                                                                saveMeCallbackText,

                                                               
            saveMeError);

                    }

                    // close after save is done                    if
            (document.getElementById('saveMeCloseCheckbox').checked == true) {

                        hideEditor();

                    }

                }

                // This is the callback function that
            processes the Web Service return value                function saveMeCallbackText(result,
            eventArgs) {

                    if
            (parentObj.getAttribute(&quot;attributes&quot;).search(/ToolTip/) != -1) {

                        showMessage(&quot;Save the data....&quot;);

                        // Tooltip                        var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);

                        var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                        var theme = '&lt;% = Theme %&gt;';

                        var sel = document.getElementById('ResxLanguageSelector');

                        if (sel.options.length &gt; 0) {

                            var culture =
            sel.options[sel.selectedIndex].value;

                            var tb =

                            document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').value;

                           
            ResxEditor.ResourceService.SaveResource(pageId,

                                                                    
            ctrlId + &quot;.ToolTip&quot;,

                                                                   
             tb, culture, theme,

                                                                     saveMeCallbackTooltip,

                                                                    
            saveMeError);

                        }

                    } else {

                        saveMeCallbackTooltip(null, null);

                    }

                }

                function saveMeCallbackTooltip(result,
            eventArgs) {

                    if
            (parentObj.getAttribute(&quot;attributes&quot;).search(/ErrorMessage/) != -1) {

                        showMessage(&quot;Save the data.....&quot;);

                        // Tooltip                        var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);

                        var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                        var theme = '&lt;% = Theme %&gt;';

                        var sel =
            document.getElementById('ResxLanguageSelector');

                        if (sel.options.length &gt; 0) {

                            var culture = sel.options[sel.selectedIndex].value;

                            var tb =

                        document.getElementById('&lt;% =
            TextBoxErrorMessage.ClientID %&gt;').value;

                           
            ResxEditor.ResourceService.SaveResource(pageId,

                                                                  
             ctrlId + &quot;.ErrorMessage&quot;,

                                                                  
             tb, culture, theme,

                                                                   
            saveMeCallbackVisibility,

                                                                  
             saveMeError);

                        }

                    } else {

                        saveMeCallbackVisibility(null,
            null);

                    }

                }

                function saveMeCallbackVisibility(result,
            eventArgs) {

                    // Properties::Visible                    var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);
                    var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                    var theme = '&lt;% = Theme %&gt;';

                    var sel =
            document.getElementById('ResxLanguageSelector');

                    if (sel.options.length &gt; 0) {

                        var culture =
            sel.options[sel.selectedIndex].value;

                        var cb =
            document.getElementById('&lt;% = ChkBoxVisible.ClientID %&gt;');

                        if (cb.checked == false) {

                           
            ResxEditor.ResourceService.SaveResource(pageId,

                                                                    ctrlId
            + &quot;.Visible&quot;,

                                                                  
             &quot;False&quot;, culture, theme,

                                                                   
            saveMeCallbackErrorMessage,

                                                                    saveMeError);
                        } else {

                           
            ResxEditor.ResourceService.SaveResource(pageId,

                                                                   
            ctrlId + &quot;.Visible&quot;,

                                                                    &quot;True&quot;,
            culture, theme,

                                                                  
             saveMeCallbackErrorMessage,

                                                                   
            saveMeError);

                        }

                    }

                }

                function saveMeCallbackErrorMessage(result,
            eventArgs) {

                    showMessage(&quot;&quot;);

                }

                function saveMeError(err) {

                    showError(err.get_message());
                }

                function loadMe() {

                    showMessage(&quot;Load Resources from
            Server...&quot;);

                    var pageId = parentObj.getAttribute(&quot;pageID&quot;);

                    var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                    var theme = '&lt;% = Theme %&gt;';

                    var sel =
            document.getElementById('ResxLanguageSelector');

                    if (sel.options.length &gt; 0) {

                        var culture =
            sel.options[sel.selectedIndex].value;

                       
            document.getElementById('LabelControlId').innerText = ctrlId;

                       
            document.getElementById('LabelPageId').innerText = pageId;

                        // Text   

                        ResxEditor.ResourceService.LoadResource(pageId,

                                                               
            ctrlId + &quot;.Text&quot;,  
                                                               
            culture, theme,

                                                              
             loadMeCallbackText,

                                                                loadMeError);

                    }

                }

                function loadMeCallbackText(result,
            eventArgs) {

                    document.getElementById('&lt;% =
            EditTextBox.ClientID %&gt;').innerText = result;

                    if
            (parentObj.getAttribute(&quot;attributes&quot;).search(/ToolTip/) != -1) {

                        showMessage(&quot;Load Resources
            from Server....&quot;);

                        // Tooltip                        var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);
                        var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                        var theme = '&lt;% = Theme %&gt;';

                        var sel =
            document.getElementById('ResxLanguageSelector');

                        if (sel.options.length &gt; 0) {

                            var culture =
            sel.options[sel.selectedIndex].value;

                           
            ResxEditor.ResourceService.LoadResource(pageId,
                                                                   
            ctrlId + &quot;.Tooltip&quot;,  

                                                                   
            culture, theme,

                                                                   
            loadMeCallbackTooltip,

                                                                    loadMeError);

                            document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').

                                                                         
            disabled = false;

                            document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').

                                                           style.backgroundColor
            = &quot;white&quot;;

                        }

                    } else {

                        document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').

                                                                          disabled
            = true;

                        document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').

                                                           style.backgroundColor
            = &quot;silver&quot;;
                        getErrorMessage();

                    }

                }

                function loadMeCallbackTooltip(result,
            eventArgs) {
                    document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').

                                                                        
            innerText = result;

                    getErrorMessage();

                }

                function getErrorMessage() {
                    if
            (parentObj.getAttribute(&quot;attributes&quot;).search(/ErrorMessage/) != -1) {

                        showMessage(&quot;Load Resources
            from Server.....&quot;);

                        // ErrorMessage
                        var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);

                        var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                        var theme = '&lt;% = Theme %&gt;';

                        var sel =
            document.getElementById('ResxLanguageSelector');

                        if (sel.options.length &gt; 0) {

                            var culture = sel.options[sel.selectedIndex].value;

                           
            ResxEditor.ResourceService.LoadResource(pageId,
                                                                   
            ctrlId + &quot;.ErrorMessage&quot;,

                                                                   
            culture, theme,

                                                                    loadMeCallbackErrorMessage,

                                                                   
            loadMeError);
                        }

                    } else {

                        // Proceed with next                        getVisibility();

                    }

                }

                function loadMeCallbackErrorMessage(result,
            eventArgs) {

                    // Save result                    document.getElementById('&lt;% =
            TextBoxErrorMessage.ClientID %&gt;').

                                                                  
            innerText = result;

                    // Proceed with next                    getVisibility();

                }

                function getVisibility() {

                    var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);

                    var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                    var sel =
            document.getElementById('ResxLanguageSelector');

                    var theme = '&lt;% = Theme %&gt;';

                    if (sel.options.length &gt; 0) {

                        var culture =
            sel.options[sel.selectedIndex].value;

                       
            ResxEditor.ResourceService.LoadResource(pageId,
                                                              
             ctrlId + &quot;.Visible&quot;,  

                                                               
            culture, theme,

                                                               
            loadMeCallbackVisible,

                                                               
            loadMeError);

                    }

                }

                function loadMeCallbackVisible(result,
            eventArgs) {

                    // Save result                    if (result == null || result == true ||
            result == &quot;True&quot;) {

                        document.getElementById('&lt;% =
            ChkBoxVisible.ClientID %&gt;').checked =

                                                                                          true;

                    } else {

                        document.getElementById('&lt;% =
            ChkBoxVisible.ClientID %&gt;').checked =
                                                                                         
            false;

                    }

                    // Done, clear message                    showMessage(&quot;&quot;);

                }

                function loadMeError(err) {

                    showError(err.get_message());
                }

                function copyMe() {

                    showMessage(&quot;Load Resources from
            Server...&quot;);

                    var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);

                    var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                    var sel =
            document.getElementById('ResxCopySelector');

                    var theme = '&lt;% = Theme %&gt;';

                    if (sel.options.length &gt; 0) {

                        var culture =
            sel.options[sel.selectedIndex].value;

                        // Text   

                       
            ResxEditor.ResourceService.LoadResource(pageId,

                                                                
            ctrlId + &quot;.Text&quot;,  

                                                                 culture,
            theme,

                                                                
            copyMeCallbackText,

                                                                
            loadMeError);

                    }

                }

                function copyMeCallbackText(result,
            eventArgs) {

                    document.getElementById('&lt;% =
            EditTextBox.ClientID %&gt;').innerText = result;

                    showMessage(&quot;Load Resources from Server....&quot;);

                    // Tooltip                    var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);

                    var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                    var sel =
            document.getElementById('ResxCopySelector');

                    var theme = '&lt;% = Theme %&gt;';

                    if (sel.options.length &gt; 0) {

                        var culture =
            sel.options[sel.selectedIndex].value;
                       
            ResxEditor.ResourceService.LoadResource(pageId,

                                                                
            ctrlId + &quot;.Tooltip&quot;,

                                                                
            culture, theme,

                                                                 copyMeCallbackTooltip,

                                                                
            loadMeError);

                    }

                }

                function copyMeCallbackTooltip(result,
            eventArgs) {

                    showMessage(&quot;Load Resources from
            Server.....&quot;);

                    // Tooltip
                    var pageId =
            parentObj.getAttribute(&quot;pageID&quot;);

                    var ctrlId =
            parentObj.getAttribute(&quot;ctrlID&quot;);

                    var sel =
            document.getElementById('ResxCopySelector');

                    var theme = '&lt;% = Theme %&gt;';

                    if (sel.options.length &gt; 0) {
                        var culture =
            sel.options[sel.selectedIndex].value;

                       
            ResxEditor.ResourceService.LoadResource(pageId,

                                                                
            ctrlId + &quot;.ErrorMessage&quot;,

                                                            
                culture, theme,

                                                                
            copyMeCallbackErrorMessage,

                                                                
            loadMeError);

                    }

                }

                function copyMeCallbackErrorMessage(result,
            eventArgs) {

                    document.getElementById('&lt;% =
            TextBoxErrorMessage.ClientID %&gt;').innerText =

                                                                                        
            result;

                    showMessage(&quot;&quot;);

                }

                function showEditor(allowHtml, parent) {

                    showMessage(&quot;&quot;);

                    document.getElementById('&lt;% =
            EditTextBox.ClientID %&gt;').disabled = true;
                    document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').disabled = true;
                    document.getElementById('&lt;% =
            EditTextBox.ClientID%&gt;').

                                                               style.backgroundColor=
            &quot;silver&quot;;

                    document.getElementById('&lt;% =
            TextBoxTooltip.ClientID %&gt;').

                                                              
            style.backgroundColor = &quot;silver&quot;;

                    document.getElementById('ErrorMessage').style.display
            = &quot;none&quot;;

                    parentObj = parent;

                    // image with attribute referencing
            to object data                    var etb =
            document.getElementById('textBoxContainer');

                    // TODO: support more attributes                    var attr =
            parentObj.getAttribute(&quot;attributes&quot;);

                    var a = attr.split(&quot;,&quot;);

                    for (i = 0; i &lt; a.length; i++) {

                        switch (a[i]) {

                            case &quot;Title&quot;:

                                break;

                            case &quot;Text&quot;:

                                document.getElementById('&lt;%
            = EditTextBox.ClientID %&gt;').

                                                                             
            disabled = false;

                               
            document.getElementById('&lt;% = EditTextBox.ClientID %&gt;').

                                                                    
            style.backgroundColor = &quot;&quot;;

                                etb.style.visibility =
            'visible';

                                etb.style.display =
            'inline';

                                break;

                            case &quot;ToolTip&quot;:

                               
            document.getElementById('&lt;% = TextBoxTooltip.ClientID %&gt;').

                                                              
            disabled = false;

                               
            document.getElementById('&lt;% = TextBoxTooltip.ClientID %&gt;').

                                                              
            style.backgroundColor = &quot;white&quot;;

                                break;

                            case &quot;ErrorMessage&quot;:

                               
            document.getElementById('ErrorMessage').style.display = &quot;block&quot;;

                                break;

                        }

                    }

                    loadMe();

                    showMe();

                }

                function hideEditor() {

                    var etb =
            document.getElementById('textBoxContainer');

                    etb.style.visibility = 'hidden';

                    etb.style.display = 'none';

                    hideMe();

                }

                function initEditor() {

                    // init                    var sel =
            document.getElementById('ResxLanguageSelector');

                    if (sel.options.length == 0) {

                        initLanguages();

                    }

                    hideEditor();

                }

            &lt;/script&gt;

          </Element>
          <Element Type="Text">

            <p>
              This longer JavaScript code block
              invokes the web services. The pattern is, according to Ajax convention, asynchronous.
              One method calls the web service, defining callback methods as parameters. Once
              the web service responds, the callback method is invoked. This could be either a
              success or error path depending on the outcome. The result is written back into
              the elements of the editor window. Other methods transfer data from the editor
              window to the server. Due to the complexity, several methods are required:
            </p>
            <ul>
              <li>
                SaveXX. Each Save method saves a
                particular control’s content
              </li>
              <li>
                LoadXX. Each Load method loads the
                content from the server
              </li>
              <li>
                CopyXX. The copy method copies from
                one language to another
              </li>
              <li>
                XXCallback. The callback containing
                the data
              </li>
            </ul>
            <p>
              Some callback methods invoke the subsequent
              step. For the Load procedure, the <code>LoadMe</code>
              function is the entry point. In the callback, the next control’s resource is retrieved
              from the server and read in its own callback method. This creates a chain of
              callbacks that are dependent on each other. This is similar for the Save procedure.
              After defining the access methods to the server, the editor window can be
              created.
            </p>

          </Element>
          <Element Type="Listing" Name="Part 3 The editor popup window definition">

            &lt;div id=&quot;theLayer&quot;
            style=&quot;background-color: silver; position: absolute; top: 40px; left:
            175px; width: 740px; border: solid 2px gray;
             padding: 5px; font-family: Verdana; color:
            Blue; font-size: 10pt; visibility: visible; z-index: 10000&quot;&gt;

             &lt;table border=&quot;0&quot;
            width=&quot;100%&quot; bgcolor=&quot;transparent&quot;
            cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;

              &lt;tr&gt;

               &lt;td width=&quot;100%&quot;&gt;

                &lt;table border=&quot;0&quot;
            bgcolor=&quot;blue&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot;
            cellpadding=&quot;3&quot;

                       height=&quot;32&quot;&gt;

                 &lt;tr&gt;

                  &lt;td id=&quot;titleBar&quot;
            style=&quot;cursor: move&quot; width=&quot;95%&quot;&gt;

                   &lt;ilayer width=&quot;100%&quot;
            onselectstart=&quot;return false&quot;&gt;

                     &lt;layer width=&quot;100%&quot;
            onMouseover=&quot;isHot=true;if (isN4) ddN4(theLayer)&quot;

                                                       onMouseout=&quot;isHot=false&quot;&gt;

                     &lt;span
            style=&quot;font-family:Verdana;font-size:12pt; font-weight:bold;

                                   color:Wheat&quot;&gt;Online
            Resource Editor&lt;/span&gt;

                     &lt;/layer&gt;

                    &lt;/ilayer&gt;

                  &lt;/td&gt;

                  &lt;td style=&quot;cursor: hand&quot;
            valign=&quot;top&quot; align=&quot;right&quot; width=&quot;5%&quot;&gt;

                   &lt;div onclick=&quot;hideEditor();return
            false&quot; style=&quot;padding: 2px; color: #ffffff;

                        background-color: Red; width: 8px;
            height: 12px; font-size: 9px;

                        font-family: Verdana;
            text-decoration: none; text-align: center;

                        vertical-align: top&quot;&gt;

                    x                   &lt;/div&gt;

                  &lt;/td&gt;

                 &lt;/tr&gt;

                 &lt;tr&gt;

                  &lt;td width=&quot;100%&quot;
            bgcolor=&quot;#FFFFFF&quot; style=&quot;padding: 4px&quot;
            colspan=&quot;2&quot;

                      disabled=&quot;true&quot;
            id=&quot;theContentContainer&quot;&gt;

                   &lt;table&gt;

                    &lt;tr&gt;

                     &lt;td&gt;

                      Language selection:

                     &lt;/td&gt;

                     &lt;td&gt;

                      &lt;select
            id=&quot;ResxLanguageSelector&quot; onchange=&quot;loadMe();&quot;&gt;

                      &lt;/select&gt;

                     &lt;/td&gt;

                    &lt;/tr&gt;

                    &lt;tr&gt;

                     &lt;td&gt;

                      Copy from language:

                     &lt;/td&gt;

                     &lt;td&gt;

                      &lt;select
            id=&quot;ResxCopySelector&quot; onchange=&quot;copyMe();&quot;&gt;
                      &lt;/select&gt;

                     &lt;/td&gt;

                    &lt;/tr&gt;
                   &lt;/table&gt;

                   &lt;hr width=&quot;100%&quot;
            size=&quot;2&quot; color=&quot;gray&quot; /&gt;

                   Resource: &lt;span
            style=&quot;font-weight: bold;&quot;

                       id=&quot;LabelControlId&quot;&gt;&lt;/span&gt;&amp;nbsp;on&amp;nbsp;

                       &lt;span style=&quot;font-weight:
            bold;&quot;

                       id=&quot;LabelPageId&quot;&gt;

                       &lt;/span&gt;

                   &lt;br /&gt;

                   &lt;hr width=&quot;100%&quot;
            size=&quot;2&quot; color=&quot;gray&quot; /&gt;

                   Tooltip:&lt;br /&gt;

                   &lt;asp:TextBox runat=&quot;server&quot;
            ID=&quot;TextBoxTooltip&quot;

                       TextMode=&quot;SingleLine&quot;
            Width=&quot;720px&quot;

                       Visible=&quot;true&quot;&gt;&lt;/asp:TextBox&gt;

                   &lt;span style=&quot;display: none&quot;
            id=&quot;ErrorMessage&quot;&gt;

                                                                            ErrorMessage
            (Message in group, Text = Message text)

                   &lt;br /&gt;

                    &lt;asp:TextBox runat=&quot;server&quot;
            ID=&quot;TextBoxErrorMessage&quot;

                        TextMode=&quot;SingleLine&quot;
            Width=&quot;720px&quot;

                        Visible=&quot;true&quot;&gt;&lt;/asp:TextBox&gt;

                   &lt;/span&gt;

                   &lt;hr width=&quot;100%&quot;
            size=&quot;2&quot; color=&quot;gray&quot; /&gt;

                   &lt;asp:CheckBox runat=&quot;server&quot;
            ID=&quot;ChkBoxVisible&quot;             

                        Text=&quot;Make element visible&quot;
            /&gt;

                   &lt;hr width=&quot;100%&quot;
            size=&quot;2&quot; color=&quot;gray&quot; /&gt;

                   &lt;div id=&quot;textBoxContainer&quot;
            style=&quot;visibility: hidden&quot;&gt;

                    &lt;asp:TextBox runat=&quot;server&quot;
            ID=&quot;EditTextBox&quot;

                        TextMode=&quot;MultiLine&quot;

                        Height=&quot;400px&quot; Width=&quot;720px&quot;
                        Visible=&quot;true&quot;&gt;&lt;/asp:TextBox&gt;

                   &lt;/div&gt;

                   &lt;br /&gt;

                   &lt;table border=&quot;0&quot;
            width=&quot;100%&quot;&gt;

                    &lt;tr&gt;

                     &lt;td align=&quot;left&quot;
            width=&quot;80%&quot;&gt;

                      &lt;label&gt;

                       &lt;input
            id=&quot;saveMeCloseCheckbox&quot;  

                           type=&quot;checkbox&quot;
            value=&quot;Close&quot; /&gt;

                        Close after Save                      &lt;/label&gt;

                     &lt;/td&gt;
                     &lt;td align=&quot;right&quot;
            width=&quot;20%&quot;&gt;

                      &lt;input type=&quot;button&quot;

                             onclick=&quot;saveMe();return
            false;&quot; value=&quot;Save&quot; /&gt;&amp;nbsp;

                      &lt;input type=&quot;button&quot;
                             onclick=&quot;hideEditor();return
            false;&quot; value=&quot;Close&quot; /&gt;

                     &lt;/td&gt;

                    &lt;/tr&gt;

                   &lt;/table&gt;

                   &lt;br /&gt;

                   &lt;div id=&quot;MessageLabel&quot;
            style=&quot;color: Green;

                            font-weight: bold&quot;&gt;
                   &lt;/div&gt;

                   &lt;br /&gt;

                   &lt;span style=&quot;color:
            Red&quot;&gt;&lt;strong&gt;Hint: &lt;/strong&gt;

                    Refresh  page by choosing another
            language!&lt;/span&gt;

                  &lt;/td&gt;

                 &lt;/tr&gt;

                &lt;/table&gt;

               &lt;/td&gt;

              &lt;/tr&gt;

             &lt;/table&gt;

            &lt;/div&gt;

            &lt;script language=&quot;javascript&quot;
            type=&quot;text/javascript&quot;&gt;

                whichDog = isIE ? document.all.theLayer :
            document.getElementById(&quot;theLayer&quot;);

                setTimeout('initEditor()', 100);

                if (typeof (Sys) !== &quot;undefined&quot;)
            Sys.Application.notifyScriptLoaded();

            &lt;/script&gt;
          </Element>
          <Element Type="Text">

            <p>
              This is simply a fragment of HTML
              containing the controls and the supporting script that manages the page loading
              cycle. The control has a few trivial lines of code behind (Listing 5.23). As
              written, everything relies on JavaScript in the client. The web service on the
              server acts as an access layer to the underlying resource provider.
            </p>

          </Element>
          <Element Type="Listing" Name="The “code behind” for the control">

            using System;

            using System.Web.UI;

            public partial class edit :
            System.Web.UI.UserControl            {

                protected override void OnInit(EventArgs e)

                {

                    Page.EnableEventValidation = false;

                    base.OnInit(e);

                }

                protected override void OnLoad(EventArgs e)

                {

                    base.OnLoad(e);               

                }

                protected string Theme                {

                    get                    {

                        return Session[&quot;theme&quot;] as
            string;

                    }

                }

            }

          </Element>
          <Element Type="Text">
            <p>
              The only public parameter we need is the
              currently selected theme. This value is included in the web service calls,
              where it is used to route the resource data into the right resource storage.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Summary" >
        Summary
        <Element Type="Text">

          <p>
            In this chapter, we looked closely at
            how to handle resource providers. A complete solution is capable of changing
            internal behavior without losing any default features, and includes a design-time
            control. Design-time support is an important part of any custom solution, and
            it would be shortsighted to ignore the option of using designer tools (even if
            you do not intend to employ them yourself). All code shown in this chapter has
            full design-time support, including the steps for enabling debugging.
          </p>

          <p>
            Furthermore, we made the
            resource provider accessible via a web service. We built a JavaScript-based
            editor on the client to read and save resources at runtime, enabling resource-based
            pages to be editable online. The examples demonstrate how to implement a highly
            customized solution, which fits well into the existing ASP.NET framework.
          </p>

          <p>
            Is there a reason that you are using a deprecated interface and not
            the “designated successor”?
          </p>

          <p>
            It’s not my code, it’s decompiled VS code that explains how we can
            treat the resource management. I guess with VS 2010 Microsoft will move to new
            interfaces, but for now it’s what we’re supposed to work with.
          </p>

          <p>
            This is a repetition of paragraphs from the end of chapter 4. I
            think this section should be deleted, and the reader directed to the
            appropriate page instead.
          </p>

          <p>
            Not sure, <b>question to editor</b>: If one reads the chapter alone
            it’s not complete. Redirecting to another topic to cover this? Repeating seems
            okay, it’s only two pages.
          </p>

        </Element>
      </Element>
    </Element>
    <Element Type="Section" Name = "Page and Session Management" >
      Page and Session Management
      <Element Type="Text">

        <p>
          The Hypertext Transfer Protocol (HTTP)
          is the reason for the success of the Internet. It is also the source of the
          drawbacks in the usability of applications. To overcome these limitations,
          ASP.NET provides several ways of maintaining the state of pages—and the controls
          between postbacks—throughout the whole session. Whatever the type of data existing
          within an application, there are two things to consider: the storage of
          application data on the server, and how to integrate the user’s session with
          the application data.
        </p>

        <p>
          In this chapter, I’ll explain how to
          customize in both of these areas for your real-life applications. In
          particular, you’ll find information about:
        </p>
        <ul>
          <li>The page persister technique</li>
          <li>Writing a custom page persister</li>
          <li>
            The internals of the session state
            provider
          </li>
          <li>
            Writing a custom session state
            provider
          </li>
        </ul>
        <p>
          The approach presented here is based on
          the provider model as explained in Chapter 4. Please refer back for useful
          information about providers, their purpose, and how they fit into the ASP.NET
          framework.
        </p>

      </Element>
      <Element Type="Section" Name = "The Page State Persister" >
        The Page State Persister
        <Element Type="Text">

          <p>
            Handling active content and creating
            rich internet applications are difficult to integrate. Page persistence is the
            key to overcoming this challenge, and a good understanding of this feature is the
            basis of creating complex applications.
          </p>

        </Element>
        <Element Type="Section" Name = "A Look Back" >
          A Look Back
          <Element Type="Text">

            <p>
              The protocol spoken between server and
              browser is HTTP, and there are many books, articles, blogs, and newsgroup posts
              complaining about its limitations. However, HTTP has succeeded mainly because
              of its simplicity. There are three key properties which make HTTP unique:
            </p>
            <ul>
              <li>
                It uses text to transport both
                messages and content
              </li>
              <li>It runs on top of TCP</li>
              <li>It is a stateless protocol</li>
            </ul>
            <p>
              “Stateless” can be thought of as “fire
              and forget”. The client initiates a request to the server; the server processes
              the request and responds with the answer. After that, the server forgets all
              about the procedure. Once the conversation has ended, nothing is left for
              further processing—at least, this is the case for the protocol.  
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "The Default Page State Persister" >
        The Default Page State Persister
        <Element Type="Text">
          <p>
            The statelessness of HTTP means that
            there is no formal way of remembering, either on the client or the server, the
            state of any past actions involving the same user. However, every web
            development environment provides some means of recognizing session states and
            storing user data. ASP.NET is no exception, and as for many other parts of the
            .NET framework, there are several ways of achieving this.
          </p>

        </Element>
        <Element Type="Section" Name = "State Storage in ASP.NET" >
          State Storage in ASP.NET
          <Element Type="Text">

            <p>
              Because all state management approaches
              require custom coding by application developers, it’s worth looking into them
              in more detail. Understanding the pros and cons of each method makes it easier
              to decide which one to use, where to customize it, and how to get the most out of
              it.
            </p>

            <p>
              ASP.NET can store information about the
              page’s state in several collections:
            </p>
            <ul>
              <li>
                Cookies: You can create private
                cookies and store them on the client’s machine in order to obtain information
                from them. This is not the best method, but it’s the default method.
              </li>
              <li>
                View State: ASP.NET controls, as well
                as several other parts, use view state to store control-specific information
                about the previous state. We’ll discuss all facets of view state later in this
                chapter.
              </li>
              <li>
                Session: This is a collection of
                key-value pairs related to the current user’s session. It’s a way of adding
                more information, on the server side, to a session state stored elsewhere (in a
                cookie, for instance).
              </li>
            </ul>
            <p>
              The Application collection is another
              set of key-value pairs which retain application-level data shared among all
              users. In contrast, the Context collection is limited to the current
              request-response flow—data in the Context collection does not survive the page
              cycle.
            </p>

            <p>
              Cookies, View State and the
              Session collection give the developer the illusion of stateful page handling.
              Most commonly, they will use a single cookie, called the session cookie, to
              store an ID with the shortest lifetime possible in the browser’s cookie memory,
              just until the session ends. When the client makes a new request, the cookie is
              returned in the request. The server decodes the ID to determine which browser
              instance (and hence, which user) is sending the request.
            </p>
            <p>
              As an experienced developer, you
              might already know how to use the <code>Cookie</code>,
              <code>Session</code>, and <code>Application</code>
              collections. Each of them has a different storage mechanism and must be used
              wisely. You may remember that there are many code snippets scattered throughout
              the page’s code which obtain access to the information whenever it is required.
              However, this is not ideal, as it detracts from the declarative nature of ASP.NET
              pages. Not only does it make pages harder to read, but it could lead to bugs if
              overused.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Persisting Page State Information" >
        Persisting Page State Information
        <Element Type="Text">

          <p>
            The first step in managing state data
            is to master the techniques for retaining the page state through each postback.
            The information on the “current” page is generally stored within several
            controls. Therefore, we’ll need a way of storing the controls’ state
            information.
          </p>

          <p>
            The state storage relies on two similar
            techniques: the view state and the control state. The internal nature and
            pitfalls of the view state were described in Chapter 1. Here, I’ll show how to
            change the storage and retrieval mechanism.
          </p>

        </Element>
        <Element Type="Section" Name = "View State Explained" >
          View State Explained
          <Element Type="Text">

            <p>
              Recall the purpose of view state: to
              store data about the properties of controls that are set programmatically. View
              state is not responsible for the sticky form behavior that retains the controls’
              current state according to the user’s selection. The control state holding this
              information is retrieved from the form’s data, which is posted back to the
              server during a normal postback. Additional information is stored in a special
              hidden field. Internally, view state uses an object of type <code>StateBag</code>
              . It retains data and includes code which serializes the data into text
              format and stores it in the hidden field.
            </p>

            <p>
              Consider using a
              <code>Label</code>
              control, where you set the color to turn red if an error occurs.
              You’ll want to maintain this state until the error has been corrected, without
              checking and setting the property repeatedly. Once set programmatically, view
              state stores this value in the <code>StateBag</code> and persists
              it in the page via a hidden field. When the page is initialized after a postback,
              the value is retrieved and assigned to the property—no custom code required.
            </p>

            <p>
              Clearly, view state plays a
              crucial role in page development, and can be used internally to store a control’s
              state.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Control State Explained" >
          Control State Explained
          <Element Type="Text">

            <p>
              View state and control state are
              related and therefore need to be discussed together. Whereas view state
              contains programmatically-set property values, control state contains the data required
              for one control to make it appear after a postback in the same state that it
              was in beforehand. Frustratingly, the control state is stored as part of the view
              state data by default. This means that there are two different ways of saving
              control data during postbacks, but both use the same storage—the hidden view
              state field. However, control developers may decide to write the control state
              into private hidden fields to retain the state and decouple view state and
              control state storage, then.
            </p>

          </Element>
          <Element Type="SideBar" SidebarType="Note">

            <header>Note</header>
            <aside>
              Control state is only for
              small amounts of critical data that are essential for the control across
              postbacks. It is not seen as an alternative to view state.
            </aside>

          </Element>
          <Element Type="Text">

            <p>
              In fact, there is no way to
              treat both states separately from each other from page level code. Disabling
              the view state suppresses the serialization and storage mechanism entirely, so the
              control state gets lost. Complex controls such as <code>GridView</code>
              store information about paging and sorting, because there are no
              corresponding HTML fields able to store and send such data as part of a regular
              form. The <code>GridView</code> has several indices that retain the internal state. Changes to underlying
              data are tracked and used to fire appropriate events. These are properties such
              as <code>EditIndex</code>
              , <code>PageIndex</code>
              , and <code>SortDirection</code>
              . Several internal actions might lead to changes that need to be
              stored during postbacks, but this does not use the same path through the code
              as the view state would use for public properties.
            </p>

            <p>
              Control developers should be
              careful about using the control state because of its dependency on view state. A
              disabled view state could cause the control state to not function properly. The
              view state data stored in the hidden field would expand and developers using
              your control might by concerned by the growing page and form data.
            </p>

            <p>
              However, as a control
              developer, you have several options for managing the way your control stores
              internal state values. Firstly, the <code>Page.RegisterRequiresControlState</code>
              method must be called to ensure that the control starts storing the
              control state. Apart from within view state, there is no <code>StateBag</code>
              that stores values directly. It’s up to you to implement the whole
              storage level. This is both good and bad, as although you’ll have more control
              of what happens internally, it requires more effort to store a few primitive
              values.
            </p>

            <p>
              The following code listing shows
              a simple control that stores several values in the control state.
            </p>

          </Element>
          <Element Type="Listing" Name="A custom control using the Control State">

            public class MyControl : Control            {

               string stateData;

               protected override OnInit(EventArgs e)

               {
                  Page.RegisterRequiresControlState(this);

                  base.OnInit(e);

               }

             

               protected override void
            LoadControlState(object savedState)

               {

                  object[] ctrlState = (object[])
            savedState;

                  base.LoadControlState(ctrlState[0]);

                  stateData = [string] ctrlState[1];    

               }

             

               protected override object SaveControlState()

               {

                  object[] ctrlState = new object[2];

                  object[0] = base.SaveControlState();

                  object[1] = stateData;

                  return ctrlState;    

               }

            }

          </Element>
          <Element Type="Text">

            <p>
              If you plan to write a custom
              page state persister, you’ll have to handle the control state’s data as well as
              the view state’s data. The persister’s provider must store both; otherwise
              almost all custom controls will stop functioning properly.
            </p>

            <p>
              An alternative is to store the
              values your own way—using private hidden fields, perhaps—in order to remain independent
              of the provider. However, this is beyond the scope of this chapter. Besides, adding
              infrastructure logic to custom controls run counter to the ASP.NET paradigm, in
              which the base framework contains and exposes a rich infrastructure.
            </p>

            <p>
              In conclusion, view state and
              control state are stored in the same place in order to completely and
              automatically restore a control’s properties. Since the storage and management
              of view state and control state are related, I’ll treat them together in this
              chapter. When I use the term ‘view state’, consider it as including control
              state as well.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "The Default Providers" >
          The Default Providers
          <Element Type="Text">

            <p class="MsoNormal">
              ASP.NET uses a provider to manage storage
              of the view state. The description above assumes the usage of one of the two providers’
              available out-of-the-box. Both providers derive from an abstract base class, <code>PageStatePersister</code>:
            </p>
            <ul>
              <li>HiddenFieldPageStatePersister</li>
              <li>SessionPageStatePersister</li>
            </ul>
            <p>
              By default, the <code>HiddenFieldPageStatePersister</code>
              is used to store the view state in a hidden field. When you look
              into a page’s source code in the browser, you’ll find a field with the name __VIEWSTATE.
              This is the serialized, encoded, and optionally encrypted collection of properties
              stored in the <code>StateBag</code>.
            </p>

          </Element>
          <Element Type="Image" Name="Typical view of the view state‘s hidden field">
            images/image001.jpg
          </Element>
          <Element Type="Text">

            <p>
              This is what you’ll see if the <code>
                HiddenFieldPageStatePersister
              </code> is used. There are several pros and cons to using this method. Many
              pages store information and many users have individual data. The state is
              associated with the current page, and apart from session data that is independent
              of the current page, this data is specific to the page and the user. Storing the
              data on the client computer moves the memory required from the server to the client.
              This costs bandwidth, but saves server resources.
            </p>

            <p>
              If you have 1 KB of session
              data and 1,000 users accessing the server simultaneously, you’ll need to store
              1 MB of data. If this happens for 100 pages, you’ll need to store 100 MB. This
              isn’t usually significant, but growing traffic will increase the resource
              consumption accordingly. For this reason, using the browser’s memory is a better
              option for scalability, and this is why the default provider uses the <code>
                HiddenFieldPageStatePersister
              </code> option.
            </p>

            <p>
              However, sometimes it’s not
              the server’s resources that cause the bottleneck but the bandwidth,
              particularly on mobile devices. View state is transmitted twice for each
              request. Accessing a dozen pages with 1 KB of session data each would force the
              device to transfer and process an additional 24 KB of data, and this could be
              even higher for badly-developed pages.
            </p>
            <p>
              To investigate the contents of
              the view state, a tool such as Fritz Onion’s <i>ViewStateDecoder</i> is invaluable.
              Knowing what is stored in view state makes it’s easier to design a custom page
              state persister. You can find the most recent version of <i>ViewStateDecoder</i>
              at: <i>http://www.pluralsight.com/community/media/p/51688.aspx</i>.
            </p>

          </Element>
          <Element Type="Image" Name="Examine the contents of the view state">
            images\2.tif
          </Element>
          <Element Type="Text">

            <p>
              At this point, the particular contents
              of the view state aren’t important. Decoding the data is merely to understand
              the internal behavior.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Changing the Default Provider" >
          Changing the Default Provider
          <Element Type="Text">

            <p>
              The alternative provider, <code>
                SessionPageStatePersister
              </code>, moves the storage strategy from the client to the server. The data
              is stored in the session, along with other session variables. However, view
              state data is not session data—merely the state of controls. View state for
              each page is stored separately in this provider.
            </p>

            <p>
              To change from the default provider, you
              must override the <code>PageStatePersister</code> property
              of the <code>Page</code> class:
            </p>

            <pre>
              protected override PageStatePersister
              {

                  get
                  {
                      return new SessionPageStatePersister(this);
                  }

              }
            </pre>
            <p>
              It’s also possible to set this globally
              by assigning the following attribute to the <code>pages</code> tag in
              the <i>web.config</i> file.
            </p>
            <pre>
              &lt;System.web&gt;
                 &lt;pages pageBaseType=&quot;PersisterBasePage&quot;&gt;
                 …
              &lt;/System.web&gt;
            </pre>
            <p>
              This assigns a base page to all
              pages—<i>PersisterBasePage</i>, for example, which derives from the <code>Page</code>
              class and overrides the <code>PageStatePersister</code>
              property. However, this prevents you from using code behind.
            </p>

            <p>
              You could set the base class
              individually for each page. This is more flexible, but more demanding. The
              page’s definition could look like:
            </p>

            <pre>
              public partial class _Default :
              PersisterBasePage
            </pre>
            <p>
              As easy as this seems, it always
              involves a compromise. The workload is either on the client or the server.
              Fortunately, the extensibility model of ASP.NET allows you to create custom
              providers to transparently replace the existing ones.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Developing a Custom Page State Provider" >
        Developing a Custom Page State Provider
        <Element Type="Text">

          <p>
            As already mentioned, the entry point
            into a custom provider is the implementation of an abstract base class. Before
            you start coding, you’ll need to answer two questions:
          </p>
          <ol>
            <li>Where shall I store data during postbacks?</li>
            <li>How do I identify when data is no longer current?</li>
          </ol>
          <p>
            The first answer is easy. Data is
            typically stored in a file system, a database, or in memory.
          </p>

          <p>
            The second answer is more complicated.
            Data is related to a particular page, and when a user leaves the page, the data
            becomes redundant. This event is difficult to recognize. The user can leave the
            page by navigating to another page within the same application, by jumping to a
            different website on another server, or even by simply closing the browser. Keeping
            the data in storage forever is not an option, as this would increase the
            storage space used and the effort of retrieving the right data. While the default
            provider is not the ideal solution either, it does answer the second question: if
            the user moves on to another page, the browser removes the data from the client’s
            memory. Thus, you don’t need to worry about obsolete data.
          </p>

          <p>
            There is no satisfactory answer
            to this question. It’s usually sufficient simply to remove outdated data which
            has not been refreshed for a specific period of time. This assumes that a user
            is no longer connected to the server. Selecting a value corresponding to the
            session timeout will be adequate for most applications.
          </p>

        </Element>
        <Element Type="Section" Name = "Choosing the Data Storage" >
          Choosing the Data Storage
          <Element Type="Text">
            <p>
              In this example, I’ll make the storage
              as easy as possible to implement. The data is stored on the server in the file
              system. This could even be a shared drive, if you need to support a web farm. File
              systems are highly efficient for storing and retrieving data and avoid
              dependency on a database. However, this is simply an example of how to extend
              the page state persister. The storage solution you use depends entirely on the characteristics
              of your application.
            </p>

            <p>
              You’ll notice that the hidden field is
              still in charge, because it contains some information for identifying unique pages.
              This is why the hidden field is not empty when using the default provider, even
              if the view state is disabled. However, the identifier only needs a few bytes,
              and shouldn’t affect bandwidth requirements.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Analyzing a Provider" >
          Analyzing a Provider
          <Element Type="Text">

            <p>
              Before implementing the provider from
              scratch, let’s examine the <code>SessionPageStatePersister</code>
              class for firsthand information about the internal structure of
              such a provider. This class stores data on the server, just as the custom
              provider is intended to do. If you investigate the view state value captured
              from the hidden field, you’ll see a simple hexadecimal number, such as 8cb5cd5d086eee0.
              This is the hexadecimal representation of the procedure. Using the following
              code sequence, you can decode the value:
            </p>

            <pre>
              new DateTime(0x8cb5cd5d086eee0, DateTimeKind.Local).ToString()
            </pre>
            <p>
              This value decodes to 14 February 2009,
              4:09pm and 57 seconds. The <code>SessionPageStatePersister</code>
              stores not one, but nine of these values internally, to keep the
              history of page accesses alive. When the user presses the browser’s back button,
              a previous page is pulled from the server. Using the timestamp as a key, the correct
              data is retrieved from the server’s storage. The name of the internal queue is
              __VIEWSTATEQUEUE. Constraining the number of pages in the history solves the
              second question raised earlier, and limits the storage space used. Because the
              user’s behavior depends on the application’s navigation structure, you can alter
              the queue size using the following entry in the <i>web.config</i> file:
            </p>

            <pre>
              &lt;sessionPageState
              historySize=&quot;12&quot; /&gt;
            </pre>
            <p>
              This value allows twelve pages in the
              history list. The value you choose is always a compromise between convenience
              and resource usage. If the user exceeds the queue size limit, the view state
              becomes invalid and an exception is thrown. You can catch the exception,
              deliver an error page, and end the session, or simply redirect to a default
              page. However, as this is not an ideal solution, the following example shows an
              alternative way of dealing with “dead” data.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name="Implementing the Provider">
          Implementing the Provider
          <Element Type="Text">

            <p>
              As we learned from the implementation, the
              whole procedure consists of two methods, <code>Load</code> and <code>Save</code>
              . Both use the fully implemented serialization and deserialization
              methods provided by the base class to convert between the <code>StateBag</code>
              object and a text string. The example stores the data in single
              files in the file system. Each page’s data becomes one file. To retrieve the
              values, two pieces of information must be held in the view state field: the
              name of the file and the timestamp. The timestamp is needed for private garbage
              collection to remove expired data. The file name associates the page’s view
              state field with the file itself. After rendering to the browser, the hidden
              view state looks like:
            </p>
            <pre>
              &lt;input type=&quot;hidden&quot;
              Name=&quot;__VIEWSTATEID&quot; id=&quot;__VIEWSTATEID&quot;
                     value=&quot;8cb5cd5d086eee0-2qi0qprzodivhh55uwog3k45.vs&quot; /&gt;
            </pre>
            <p>
              The first part of the value,
              before the hyphen, is the timestamp. I have retained the coding schema. The
              second part is a randomly generated value, plus the extension, <i>.vs</i>.
            </p>
            <p>
              Listing 6-2 shows the code for
              the custom provider, as described thus far.
            </p>

          </Element>
          <Element Type="Listing" Name="Persisting the view state using local file system">
            public class FilePagePersister :
            PageStatePersister
            {

                private const string ViewStateFormFieldID =
            &quot;__VIEWSTATEID&quot;;

                private const string StateFileFolderPath =
            &quot;~/StateData/&quot;;

                public FilePagePersister(Page p)

                    : base(p)

                {

                }

                public override void Load()

                {
                    string stateIdentifierValue =

                           HttpContext.Current.Request.Form[ViewStateFormFieldID];

                    if (stateIdentifierValue.Length &gt; 0)

                    {

                        string fileName =
            stateIdentifierValue;

                        string filePath =
            HttpContext.Current.Server.MapPath(

                                               StateFileFolderPath
            + fileName);

                        string contents =
            File.ReadAllText(filePath);

                        Pair state =
            base.StateFormatter.Deserialize(contents) as Pair;

                        if (state != null)

                        {

                            base.ViewState = state.First;

                            base.ControlState =
            state.Second;

                        }

                    }

                }

                public override void Save()

                {

                    if (base.Page.Form != null                        &amp;&amp; (base.ControlState !=
            null || base.ViewState != null))

                    {

                        // Create filename for save                        string fileName =
            String.Format(&quot;{0:x8}-{1}.vs&quot;, DateTime.Now.Ticks,

                                          HttpContext.Current.Session.SessionID);

                        string filePath =
            HttpContext.Current.Server.MapPath(

                                               StateFileFolderPath
            + fileName);

                        Pair p = new Pair(base.ViewState,
            base.ControlState);

                        File.WriteAllText(filePath,
            base.StateFormatter.Serialize(p));

                        HiddenField hf = new HiddenField();

                        hf.Value = fileName;

                        hf.ID = ViewStateFormFieldID;
                        base.Page.Form.Controls.AddAt(0,
            hf);

                    }

                }

            }

          </Element>
          <Element Type="Text">
            <p>
              The base class provides methods of serializing
              and deserializing the data. You can access these methods by calling <code>base.StateFormatter</code>
              . The provider saves both the control state and the view state, and creates
              a <code>Pair</code>
              from them, to group the values together. The serialized <code>Pair</code>
              is written directly into the file using <code>File.WriteAllText</code>
              and retrieved using <code>File.ReadAllText</code>. We are
              not concerned about threading here, because each storage location is dedicated
              to one user session and one page. There’s a chance that a user could send the
              same page twice to the server at the same moment, but that’s unlikely—and out
              of our scope. The <code>Load</code> method
              is the reverse of the <code>Save</code> method, using the
              same approach. The <code>Save</code> method creates a
              hidden field using the <code>HiddenField</code> control and
              adds it to the beginning of the current control collection.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Extending the Provider" >
          Extending the Provider
          <Element Type="Text">

            <p>
              Although, from this example, custom
              implementation seems very simple, this isn’t entirely true. Over time, the
              folder for state files accumulates more and more files. You might consider deleting
              session state files triggered by the session end event, but that’s not
              reliable. The event is fired only if the session ends by command. If the user
              closes the browser the session dies “silently”, and only the session timeout
              can be used to remove remaining objects.
            </p>

            <p>
              One option is to remove old
              files regularly, but using such a cleanup process for each page request would
              increase the number of file accesses and thus decrease performance. A better approach
              is to include a regular folder check independent of any requests. Using this test,
              you can delete all files over a certain age.
            </p>

            <p>
              Implementing the tidy-up code in
              the provider is undesirable. Recall the goals and intended behavior of a
              provider: it’s not a good idea to have them running basic tasks. Rather, the
              health monitoring system provided by ASP.NET is ideal for managing the “health”
              of the provider’s storage.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Maintaining the Storage by Using the Health Monitor" >
          Maintaining the Storage by Using the Health Monitor
          <Element Type="Text">

            <p>
              Because the cleaning up procedure must
              be run regularly, the <code>WebHeartbeatEvent</code> is an
              ideal trigger. This event fires at regular intervals, invoking another
              provider. The health monitoring system itself is based on a provider model. Therefore,
              the second part of a custom view state storage solution consists of a “custom
              clean up provider”.
            </p>

            <p>
              Before you implement this provider, take
              a look at the configuration step needed in the <i>web.config</i> file.
            </p>

          </Element>
          <Element Type="Listing" Name="Activating the Health Monitor">
            &lt;healthMonitoring
            enabled=&quot;true&quot; heartbeatInterval=&quot;5&quot;&gt;
              &lt;providers&gt;
                &lt;add Name=&quot;FileCleanupProvider&quot;
                     type=&quot;Apress.Extensibility.EventProvider.FileCleanupProvider,
                           Apress.Extensibility.EventProvider&quot;/&gt;
               &lt;/providers&gt;
               &lt;eventMappings&gt;
                 &lt;add Name=&quot;FileCleanupEvent&quot;
            type=&quot;System.Web.Management.WebHeartbeatEvent&quot;       
                      startEventCode=&quot;0&quot;
            endEventCode=&quot;2147483647&quot;&gt;&lt;/add&gt;
               &lt;/eventMappings&gt;
               &lt;rules&gt;
                &lt;add Name=&quot;CleanupEvent&quot;
            eventName=&quot;FileCleanupEvent&quot;
                     provider=&quot;FileCleanupProvider&quot;
            /&gt;
               &lt;/rules&gt;
            &lt;/healthMonitoring&gt;
          </Element>
          <Element Type="Text">
            <p>
              The <code>healthMonitoring</code> element requires three child elements:
            </p>
            <ul>
              <li>
                <code>provider</code>: The provider that issues the action
              </li>
              <li>
                <code>eventMapping</code>:
                The event that invokes the action
              </li>
              <li>
                <code>rules</code>: A relation between a specific event and a provider
              </li>
            </ul>
            <p>
              The event is based on the
              <code>WebHeartbeatEvent</code> class. Enable the monitor using the <code>
                enabled=&quot;true&quot;
              </code>
              attribute. The <code>heartbeatInterval=&quot;5&quot;</code>
              attribute sets the heart beat to five seconds; this is just for
              testing and debugging purposes. In real life scenarios, set a value that
              provides a compromise between memory consumption and clean-up effort in order
              to monitor the number of files stored in the data folder. A heartbeat interval
              of one hour is a good starting value.
            </p>

            <p>
              The example provider configured here
              is called the <code>FileCleanupProvider</code>. The next code
              listing demonstrates its implementation. Before beginning, you’ll need to know a
              few things about health monitoring providers. The monitoring system is
              implemented to observe an ASP.NET application. It must be active before the
              application starts and after it ends and it must exist independently of current
              requests, the current request’s state in the pipeline, and IIS. Therefore, the
              class must be implemented in an assembly that can be loaded separately. Adding
              the class to <i>App_Code</i> or any place in your current project will fail. Instead,
              create a simple class library project, reference it from the Web application
              you wish to monitor, and add the following class to that project.
            </p>

          </Element>
          <Element Type="Listing" Name="Simple health monitor provider that tidies up a folder">

            public class FileCleanupProvider :
            WebEventProvider            {

                private const string StateFileFolderPath =
            &quot;StateData/&quot;;

                public FileCleanupProvider()

                    : base()

                {

                   

                }

                public override void Flush()

                {

                    // not required                }

                public override void
            ProcessEvent(WebBaseEvent raisedEvent)

                {

                    DateTime dtRaised =
            raisedEvent.EventTime;
                    // Remove files                    string filePath =
            Path.Combine(HttpRuntime.AppDomainAppPath,

                                                    StateFileFolderPath);

                    foreach (string file in
            Directory.GetFiles(filePath))

                    {
                        if (dtRaised -
            File.GetCreationTime(file) &gt; TimeSpan.FromHours(6))

                        {

                            File.Delete(file);

                        }

                    }

                }

                public override void Shutdown()

                {

                    // Clean up on shut down                    string filePath =
            Path.Combine(HttpRuntime.AppDomainAppPath,

                                                   StateFileFolderPath);

                    foreach (string file in
            Directory.GetFiles(filePath))

                    {

                        File.Delete(file);

                    }

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              Each heartbeat of the monitor
              invokes the <code>ProcessEvent</code> method. A simple loop locates
              all the files exceeding the specified age—six hours in the example—and deletes
              them. The file expiry test can be extended to suit your needs. You could check if
              the corresponding session is still alive, or if the data in the file matches certain
              conditions.
            </p>

            <p>
              The current timestamp is passed
              to the method with the <code>raisedEvent.EventTime</code>
              value. The path to the application can be retrieved using the <code>HttpRuntime</code>
              object. Remember that <code>HttpContext</code>
              might not be available, because the first heartbeat arrives when the application
              has not yet begun. Other monitoring events could provide the <code>HttpContext</code>
              object, but basic events such as the <code>WebHeartbeatEvent</code> don’t support this.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Conclusion" >
          Conclusion
          <Element Type="Text">

            <p>
              In this section, we looked at replacing
              the default page state persister provider that is responsible for storing view
              state and embedded control state information. Using the health monitoring
              system with another custom provider allows us to maintain clean up routines.
            </p>

            <p>
              Page states are not the only state
              persisted during a user’s session. Data is also stored in session variables,
              which are, by default, stored in memory. However, as in several other parts of
              ASP.NET, the session state is built on the provider model.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Session State Providers" >
        Session State Providers
        <Element Type="Text">

          <p>
            As shown in chapter 4, providers are responsible
            for allowing storage access to services. The session state module is one such
            service relying on several out-of-the-box storage options. For all available
            options, a dedicated provider exists. You can also add your own provider to
            implement a fully customized storage strategy.
          </p>
        </Element>
        <Element Type="Section" Name = "The Session State Service" >
          The Session State Service
          <Element Type="Text">

            <p>
              The session state service is defined in
              the <code>System.Web.SessionState.SessionStateModule</code>
              . Each instance creates a module that in turn creates a space to
              store data. The data is—as the name implies—associated with the user’s
              session. <code>System.Web.SessionState.SessionStateStoreData</code>is the class that defines the storage space. One
              instance is created for each user session. The <code>
                SessionStateStoreData
              </code> class is responsible for serializing and deserializing the session data.
              The serialization uses a highly efficient binary format partly customized with hardcoded
              transformations for scalar values and the <code>BinaryFormatter</code>
              type for all other values. This type is defined in the <code>System.Runtime.Serialization.Formatters.Binary</code>
              namespace. Because the session serializes all objects, the process
              includes two types of data: static and non-static. Non-static data are held in
              an <code>Items</code>
              collection. This collection is defined as an interface of type <code>ISessionStateItemCollection</code>,
              which is a simple collection based on <code>ICollection</code>
              and <code>IEnumerable</code>. It’s exposed by the <code>Session</code>

              object through an indexer and the <code>Items</code>
              property. The <code>StaticObjects</code> property relies on the
              <code>HttpStaticObjectsCollection</code> type, which in turn is a collection that implements the same
              interfaces. However, the serialization is implemented slightly differently
              here. For both <code>Items</code> and <code>
                StaticObjects,
              </code>
              you can call the <code>Serialize</code> and
              <code>Deserialize</code> methods to translate the data to and from a storable format.
            </p>

            <p>
              Apart from the two types of data
              mentioned above, the data store has its own <code>Timeout</code>
              property. This is necessary as the service is implemented as an HTTP module and
              relies on request events. If the final event is not raised, the store would an
              orphan if the timeout did not terminate it. Internally, the session state
              service class is defined as:
            </p>

            <pre>
              public sealed class SessionStateModule : IHttpModule
            </pre>
            <p>
              The session state module is executed
              before the handlers in the <code>AcquireRequestState</code>
              pipeline state. This ensures that session data is already present when the
              page’s handler is loaded. The module attempts to retrieve the session ID from
              the request and uses this to obtain data from the session store provider. If
              both function correctly, the session data is rebuilt as a dictionary and
              exposed to the <code>HttpSession</code> object. The session data is
              stored at the end of the request processing, within the <code>ReleaseRequestSession</code> stage of the pipeline. If no session ID is present, a new one is
              created. If the ID is there and some session data is changed, the provider is
              used to store these data.
            </p>

            <p>
              The service’s providers use the <code>SessionStateStoreProviderBase</code> provider base class, which defines a subset of methods all providers
              share.
            </p>

          </Element>
          <Element Type="Listing" Name="The SessionStateStoreProviderBase is the base for all session state providers">

            [AspNetHostingPermission(SecurityAction.LinkDemand,

                                    
            Level=AspNetHostingPermissionLevel.Minimal),
            AspNetHostingPermission(SecurityAction.InheritanceDemand,

                                    
            Level=AspNetHostingPermissionLevel.Minimal)]

            public abstract class
            SessionStateStoreProviderBase : ProviderBase            {

                protected SessionStateStoreProviderBase()

                {

                }

                public abstract SessionStateStoreData
            CreateNewStoreData(HttpContext context,

                                                              int
            timeout);

                public abstract void
            CreateUninitializedItem(HttpContext context,

                                                             
            string id,

                                                             
            int timeout);

                public abstract void Dispose();

                public abstract void EndRequest(HttpContext
            context);

                public abstract SessionStateStoreData
            GetItem(HttpContext context,

                                                              
            string id,

                                                              
            out bool locked,

                                                              
            out TimeSpan lockAge,

                                                              
            out object lockId,

                                                              
            out SessionStateActions actions);

                public abstract SessionStateStoreData
            GetItemExclusive(HttpContext context,

                                                              
            string id,

                                                              
            out bool locked,
                                                              
            out TimeSpan lockAge,

                                                              
            out object lockId,

                                                              
            out SessionStateActions actions);

                internal virtual void Initialize(string
            name,

                                                 NameValueCollection
            config,
                                                
            IPartitionResolver partitionResolver)

                {

                }

                public abstract void
            InitializeRequest(HttpContext context);

                public abstract void
            ReleaseItemExclusive(HttpContext context,                                                  

                                                          
            string id,

                                                          
            object lockId);

                public abstract void RemoveItem(HttpContext
            context,

                                                string id,

                                                object
            lockId,

                                               
            SessionStateStoreData item);

                public abstract void
            ResetItemTimeout(HttpContext context, string id);

                public abstract void
            SetAndReleaseItemExclusive(HttpContext context,

                                                                
            string id,

                                                                
            SessionStateStoreData item,

                                                                 object
            lockId,

                                                                
            bool newItem);

                public abstract bool SetItemExpireCallback(

                                    
            SessionStateItemExpireCallback expireCallback);

            }

          </Element>
          <Element Type="Text">

            <p>
              Inspecting the <code>GetItem</code> and <code>RemoveItem</code> methods, you’ll
              notice that the provider is responsible for creating (via the
              <code>out</code> parameter) the session specific <code>SessionStateDataStore</code>. The vital parameter is <code>HttpContext</code>,
              as it passes all the information required for identifying the session.
            </p>

            <p>
              However, the base class is
              abstract. In order to understand the code and learn how to implement a custom
              provider, we’ll need to examine certain implementations.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Identifying the Session" >
          Identifying the Session
          <Element Type="Text">
            <p>
              Despite storage management, the session
              state service needs to retrieve the session ID. The first attempt to overcome
              this stateless behavior led to the invention of cookies.
            </p>

          </Element>
          <Element Type="Section" Name = "Cookies make HTTP taste good…" >
            Cookies make HTTP taste good…
            <Element Type="Text">

              <p>
                A cookie is a small piece of text-based
                information stored in the browser’s memory or disk space. It’s under the
                browser’s control and it exists to send information about the state back to the
                server. When the browser requests a new resource, it searches for cookies
                stored by this specific server and returns this information. The server
                recognizes the information, reading it back from the headers of the HTTP
                request, and uses it to obtain the client’s state.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name = "…and bad" >
            …and bad
            <Element Type="Text">

              <p>
                However, cookies have some serious
                drawbacks. If a server sends portions of a page only, this very portion would
                send the information back to this server and not the one serving the main page.
                An advertising banner is an example of such a section. At the end of the last
                century, the company Doubleclick (eventually bought out by Google) invented a
                business concept based on cookies. Once a banner ad appears, the cookies related
                to it are placed in the browser’s memory. When the user moves to a page drawn
                from another server, but containing a banner pulled from the original ad
                server, the ad server’s code would receive the same cookie back. The original
                server knows that the user has been on different pages, and it also recognises where
                these pages originated. The cookie makes it possible for the ad server to trace
                the user and track his or her behavior. By the third page, the banner ad has
                not been selected at random. Based on the user’s behavior, the ad server chooses
                the banner that best fits the user’s interests. This leads to a much higher
                click rate, which in turn results in more money made. This is the concept invented
                by Doubleclick—with which Google now generates a lot of revenue. It is as
                simple as it sounds. However, it has faced criticism in that it compromises the
                user’s privacy. The ad server knows much more of a user’s behavior than people
                would tell strangers voluntarily. Since cookies work silently, the user is never
                asked to accept or deny them. Even if modern browsers managed cookies well,
                it’s still a complicated task to deal with them, erasing them where appropriate
                and retaining them if harmless.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name = "Beyond Cookies" >
            Beyond Cookies
            <Element Type="Text">

              <p>
                Avoiding the usage of cookies or even
                limiting them to just one—to store the session state—would give your users the opportunity
                to operate within a restrictive cookie usage policy. It is an advantage for a
                site avoiding cookies. However, it makes your life as a developer much more
                difficult because cookies simplify the session handling. Fortunately, ASP.NET
                provides a number of sophisticated techniques which help you handle the drawbacks
                of HTTP’s statelessness. In terms of the session state, you can decide whether
                to work with session cookies or without cookies at all. 
              </p>

              <p>
                ASP.NET maintains the cookieless
                session state by automatically inserting a unique session ID into the URL. This
                would look like:
              </p>

              <pre>
                http://www.apress.com/(S(lit3jk26t05z64v14vlm04s09))/default.aspx
              </pre>
              <p>
                The following configuration in the <i>web.config</i>
                file is required:
              </p>

              <pre>
                &lt;configuration&gt;
                  &lt;system.web&gt;
                    &lt;sessionState cookieless=&quot;true&quot; regenerateExpiredSessionId=&quot;true&quot; /&gt;
                  &lt;/system.web&gt;
                &lt;/configuration&gt;
              </pre>
              <p>
                A session ID will eventually expire
                when the session ends, or has been timed out. In this case, the ID is recycled;
                a later session could have the same ID. If a URL is stored somewhere on the
                client—such as within the favorites folder, sent by email, or gathered by a
                search engine— this could cause a security hole, as the older session ID located
                in the URL could be the same as that of another current session. The <code>regenerateExpiredSessionId=&quot;true&quot;</code> attribute reduces that risk by forcing it to create a new ID every
                time.
              </p>

              <p>
                If this behavior is not sufficient
                for your application, you can  write your own session ID module. For complete control,
                consider implementing the <code>ISessionIDManager</code> interface.
                To just control the creation of the ID, inherit from the <code>SessionIDManager</code> base class. Both types are defined in the <code>System.Web.SessionState</code> namespace.
              </p>

              <p>
                The next example demonstrates how
                to replace the session ID with a custom value.
              </p>

            </Element>
            <Element Type="Listing" Name="Simple session ID manager with custom ID creation">

              namespace Apress.SessionState.Code              {

                  public class SimpleSessionIDManager :
              SessionIDManager                  {

                      public override string
              CreateSessionID(HttpContext context)

                      {

                          return Guid.NewGuid().ToString();

                      }

                      public override bool Validate(string id)

                      {

                          try                          {

                              Guid testGuid = new Guid(id);

                              if
              (id.Equals(testGuid.ToString()))

                              {

                                  return true;

                              }

                          }

                          catch                          {               

                          }

                          return false;

                      }

                  }

              }

            </Element>
            <Element Type="Text">

              <p>
                The only methods to override
                are <code>CreateSessionID</code> and <code>Validate</code>. However, the
                basic form of the ID, such as <code>(S(…))</code>, is still used.
                To obtain completely different behavior, you must implement the interface,
                which requires several additional methods to be implemented. This is achieved
                behind the scenes by adding the ID to the URL first and then redirecting to the
                new URL. The changed URL is then passed to the browser.
              </p>

              <p>
                However you implement this, you
                must configure the new session ID manager in the <i>web.config</i> file:
              </p>

              <pre>
                &lt;sessionState mode=&quot;InProc&quot;
                              cookieless=&quot;true&quot;
                              regenerateExpiredSessionId=&quot;false&quot;
                              timeout=&quot;20&quot;  
                              sessionIDManagerType=&quot;Apress.SessionState.Code.MySessionIDManager,
                                                    Apress.SessionState&quot;/&gt;
              </pre>
              <p>
                The <code>sessionIDManagerType</code> attribute contains the class’s name and the namespace of the
                containing assembly. All other options depend on the entire configuration and
                are not directly associated with the session ID manager.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "The Internal State Providers" >
          The Internal State Providers
          <Element Type="Text">

            <p>
              ASP.NET includes three internal state
              providers. You should investigate these before planning the development of a
              custom provider.
            </p>
            <ul>
              <li>
                <code>InProcSessionStateStore</code>
              </li>
              <li>
                <code>OutOfProcSessionStateStore</code>
              </li>
              <li>
                <code>SqlSessionStateStore</code>
              </li>
            </ul>
            <p>
              This section gives a brief overview of the
              internal state providers, which have several features in common. You can
              control their behavior with the <code>EnableSessionState</code>
              attribute located in the <code>@Page</code> directive.
            </p>

          </Element>
          <Element Type="Image" Name="Principles of the session state providers">
            images/19835f0603.tif
          </Element>
          <Element Type="Section" Name = "InProcSessionStateStore" >
            InProcSessionStateStore
            <Element Type="Text">

              <p>
                The <code>InProcSessionStateStore</code> class defines the default session state provider if no other
                provider is specified. It stores session data within the current process, using
                the <code>HttpCache</code> module to store data in memory.
              </p>

              <p>
                This provider is the most
                efficient. The overhead is limited to the extracting of the session ID and the serializing
                and deserializing of the data. Everything happens in memory using a cache
                lookup, which merely retrieves the data and refreshes the cache expiration
                timestamp.
              </p>

              <p>
                However, the <code>InProcSessionStateStore</code> has some drawbacks. This provider does not survive an application
                restart, since the cache objects are rebuilt on restart—meaning all previous
                sessions would be lost. It also does not function reliably in web farm
                scenarios, where the next request might reach a different server that doesn’t see
                the session data in the first server’s memory.
              </p>

              <p>
                The following <i>web.config</i>
                file snippet shows the configuration:
              </p>

              <pre>
                &lt;sessionState
                   mode=&quot;InProc&quot;
                   cookieless=&quot;false&quot;
                 /&gt;
              </pre>

            </Element>
          </Element>
          <Element Type="Section" Name = "OutOfProcSessionStateStore" >
            OutOfProcSessionStateStore
            <Element Type="Text">

              <p>
                This class enables out-of-process
                storage based on an unmanaged stream that is created when an incoming request
                is handled by the session state service. The stream is read from and written
                back to a state server service. This Windows service runs independently of IIS
                and allows the sharing of memory data through several servers that make up a web
                farm.
              </p>

              <p>
                The provider is not as efficient
                as the in-process version, as it takes time to pass data beyond process
                boundaries. Internally, the process communicates with a Windows service that passes
                the data from one server to another using HTTP. This is a very slim and fast
                implementation of a Web server handling only a subset of Web server functions. While
                the HTTP protocol adds overhead to requests, the <code>OutOfProcSessionStateStore</code> will survive an application restart, as the storage is not part of
                the ASP.NET process.
              </p>

              <p>
                The following snippet from the <i>web.config</i>
                file shows the configuration:
              </p>

              <pre>
                &lt;sessionState                                                      
                   mode=&quot;StateServer&quot;
                stateConnectionString=&quot;tcpip=127.0.0.1:42424&quot;
                   cookieless=&quot;false&quot;
                 /&gt;
              </pre>
              <p>
                The service runs on local
                machines and on port 42424 by default.
              </p>

              <p>
                The state service can be found
                here:
              </p>

              <pre>
                %systemroot%\Microsoft.NET\Framework\ <i>&lt;version&gt;</i>\aspnet_state.exe
              </pre>
              <p>
                It must be installed and started as a
                service. By default, it’s installed, but set to start manually. To launch the
                service after the Web server starts, set the ASP.NET State service’s start
                option to <i>Automatic</i>. 
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name = "SqlSessionStateStore" >
            SqlSessionStateStore
            <Element Type="Text">

              <p>
                ASP.NET provides the <code>SqlSessionStateStore</code> in order to share state across multiple front end servers. The
                provider consists of several pieces you must assemble:
              </p>

              <ul>
                <li>
                  A data table for the session
                  data
                </li>
                <li>
                  Stored procedures to write and read
                  the session data from SQL Server
                </li>
                <li>
                  A connection string defined in <i>web.config</i>
                  which declares the database connection
                </li>
                <li>
                  The <code>SqlSessionStateStore</code> set in the <i>web.config</i> as the default provider
                </li>
              </ul>

              <p>
                To create the data table and add the stored
                procedures, use the <i>Aspnet_regsql.exe</i> tool. You can find  it at:
              </p>
              <pre>
                C:\Windows\Microsoft.NET\Framework\v2.0.50727
              </pre>
              <p>
                Details about all the command line
                options are at:
              </p>

              <pre>
                http://msdn.microsoft.com/en-us/library/ms229862.aspx
              </pre>
              <p>
                The tool also supports settings required
                by other SQL Server based modules. For the session state, the following options
                are important:
              </p>

              <ul>
                <li>
                  <code>-S servername</code>: The name of the database server, such as <i>locahost\sqlexpress</i>.
                </li>
                <li>
                  <code>-d databasename</code>: The name of the database; requires <code>-sstype c</code>.
                </li>
                <li>
                  <code>-ssadd</code>: Adds support.
                </li>
                <li>
                  <code>-ssremove</code>:
                  Removes support.
                </li>
                <li>
                  <code>-sstype t</code>:
                  Installs the data table into the <i>tempdb</i> database.
                </li>
                <li>
                  <code>-sstype p</code>:
                  Installs the data table into a persistent database, like <i>aspnetdb</i>.
                </li>
                <li>
                  <code>-sstype c</code>:
                  Installs the data table into a custom database. Use <code>-d databasename</code> to choose one.
                </li>
              </ul>
            </Element>
            <Element Type="SideBar" SidebarType="Tip">
              <header>Tip</header>
              <aside>
                If you start the
                Aspnet_reqsql tool without any parameters, a wizard is launched that leads you through
                the required steps.
              </aside>
            </Element>
            <Element Type="Text">

              <p>
                This <i>web.config</i> file snippet
                shows an example of the configuration:
              </p>
              <pre>
                &lt;sessionState
                   mode=&quot;SQLServer&quot;
                   cookieless=&quot;true&quot;
                   sqlConnectionString=&quot; Integrated Security=SSPI;data source=MySqlServer;&quot;
                   sqlCommandTimeout=&quot;10&quot; /&gt;
              </pre>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Improving the Session State" >
          Improving the Session State
          <Element Type="Text">
            <p>
              The session state service adds a considerable
              overhead to the performance of your application. Because it’s a valuable tool,
              most developers choose to use session data. However, the serializing and
              deserializing procedures required for each request take time. If the
              application comes under pressure, and if you decide to work with a web farm in
              order to balance the load, things might become worse. The session related
              traffic would increase on the local network between the SQL Server or State
              server and the web servers. There are several ways of improving performance,
              and it’s important to think about these before you start creating your own
              session state providers.
            </p>

            <p>
              Some optimizations are implemented by
              default in order to avoid having a bottleneck for standard features. Firstly,
              the ability to handle the session state can be disabled. You can set this using
              the <code>@Page</code> directive:
            </p>

            <ul>
              <li>
                <code>EnableSessionState=&quot;true&quot;</code>
              </li>
              <li>
                <code>EnableSessionState=&quot;false&quot;</code>
              </li>
              <li>
                <code>EnableSessionState=&quot;ReadOnly&quot;</code>
              </li>
            </ul>
            <p>
              Enabling and disabling the session state
              is trivial; when disabled, no session data is stored. The <code>ReadOnly</code> option is more subtle. Imagine that a user has several browser
              windows or tabs open and all of them are in the same session using the same
              session ID. If the user accesses the web server multiple times at once, the
              first request gains exclusive access, locking access for other requests. The
              second request must wait in order to obtain its exclusive access when the first
              request ends. This could lead to an unsatisfactory user experience, as the user
              will probably open several windows to launch simultaneous tasks, such as downloading
              files. Instead of speeding things up, the windows would be blocked. To avoid
              this, the <code>ReadOnly</code> option is used to allow concurrent read access to the session data.
              The lock is still there for write access and it blocks other requests with same
              session ID. You will only benefit from this setting if you use the session
              variables carefully.
            </p>

          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Implementing the Session State Store Provider" >
        Implementing the Session State Store Provider
        <Element Type="Text">

          <p>
            You might wish to create a custom
            session-state store provider to:
          </p>
          <ul>
            <li>
              Store session-state information
              in a data source other than SQL Server, such as a MySQL database or an Oracle
              database.
            </li>
            <li>
              Manage session-state information
              using a database schema that is different from the default database schema.
            </li>
            <li>
              Use a totally different storage
              strategy, such as the file system.
            </li>
          </ul>

        </Element>
        <Element Type="Section" Name = "The Session State Module" >
          The Session State Module
          <Element Type="Text">

            <p>
              Session state is managed by the <code>SessionStateModule</code> class, which calls the session-state stored provider to read and
              write data to the data store during a request. At the start of a request, the <code>SessionStateModule</code> instance retrieves data from the data source by calling the <code>GetItemExclusive</code> or <code>GetItem</code> method. The exclusive access is
              the default; the <code>GetItem</code> method also supports
              the <code>EnableSessionState=&quot;ReadOnly&quot;</code> attribute, allowing shared read access as explained in the section
              above. At the end of a request, if the session-state values have been changed,
              the <code>SessionStateModule</code> instance calls the <code>SetAndReleaseItemExclusive</code> method to write the updated values to the data store.
            </p>

            <p>
              The <code>SessionStateModule</code> class itself determines the session ID value, rather than relying
              on the session-state store provider. The session ID manager is responsible for
              the ID format, which is based on the implementation of the <code>SessionIDManager</code> class. The <code>SessionStateModule</code> class
              reverts to the ASP.NET process identity in order to access any secured
              resource, such as a database server. You can specify the <code>SessionStateModule</code> instance to impersonate the process identity by setting the <code>useHostingIdentity</code> attribute of the <code>&lt;sessionState&gt;</code>
              configuration element to <code>false</code>.
            </p>

            <pre>
              &lt;sessionState useHostingIdentity=&quot;false&quot; /&gt;
            </pre>
            <p>
              If the <code>useHostingIdentity</code> attribute is <code>true</code>, ASP.NET will
              impersonate either the process identity or the user credentials when connecting
              to the data source. Usually this is a cumbersome process, as you’ll have to
              manage all your users.
            </p>

          </Element>
        </Element>
        <Element Type="Section" Name = "Preface" >
          Preface
          <Element Type="Text">

            <p>
              Before developing a new session state
              persister, let’s briefly investigate what it can be used for. There are three
              major tasks:
            </p>
            <ul>
              <li>
                Handling session locking for concurrent
                requests to the same data
              </li>
              <li>
                Identifying and occasionally removing
                expired session data
              </li>
              <li>
                Allowing more than one
                application to use the provider
              </li>
            </ul>

          </Element>
          <Element Type="Section" Name = "Locking Session-Store Data" >
            Locking Session-Store Data
            <Element Type="Text">

              <p>
                ASP.NET applications respond to
                multiple concurrent requests. Those requests might attempt to access the same
                session information, as explained above. When implementing your own provider,
                you’ll need to manage the locking behavior. A lock is set on session-store data
                at the beginning of the request in the call to the <code>GetItemExclusive</code> method. When the request is completed, the lock is released during
                the call to the <code>SetAndReleaseItemExclusive</code> method. If the <code>SessionStateModule</code>
                instance encounters locked session data during the call to either the <code>GetItemExclusive</code> or <code>GetItem</code> method, it will re-request the
                session data. This occurs at half-second intervals until either the lock is
                released or the amount of time specified in the <code>ExecutionTimeout</code> property has elapsed. After a timeout occurs, the <code>ReleaseItemExclusive</code> method is called in order to free the session-store data.
                Additionally, a lock identifier is used to distinguish between concurrent
                requests accessing the same session data. This is necessary as these requests
                run on separate threads. A call to the <code>ReleaseItemExclusive </code>appears before the <code>SetAndReleaseItemExclusive </code>method is called for the current response.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name = "Handling Expired Data" >
            Handling Expired Data
            <Element Type="Text">

              <p>
                Expiration occurs when a session times
                out or explicitly ends. A session ends with a user action, when the <code>Abandon</code> method is called. The data for that session is deleted from the
                data store using the <code>RemoveItem</code> method. The
                mechanism for deleting expired session data depends on the capabilities of your
                data source. If the session expires according to the session <code>Timeout</code> property, you can use the <code>SetItemExpireCallback</code> method to handle the <code>Session_OnEnd</code> event.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name = "Set Application Name" >
            Set Application Name
            <Element Type="Text">

              <p>
                To maintain session scope,
                session-state providers store session information uniquely for each
                application. This allows multiple ASP.NET applications to use the same data
                source without conflicting. How you ensure uniqueness depends entirely on the
                storage mechanism. For a file based provider, as in the following example, a
                subfolder named after the application will suffice. In a database scenario, an <i>ApplicationName</i>
                column in the data table would be necessary.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name = "Implementation Details" >
            Implementation Details
            <Element Type="Text">

              <p>
                There are many steps to implementation.
                None are difficult, but careful preparation is required.
              </p>

            </Element>
          </Element>
          <Element Type="Section" Name = "Required Classes" >
            Required Classes
            <Element Type="Text">

              <p>
                To implement a session store provider, you
                must create a class that inherits the <code>SessionStateStoreProviderBase</code> abstract class. This class in turn inherits the <code>ProviderBase</code> abstract class, so you must also implement the required members of
                the <code>ProviderBase</code> class. (Refer to chapter 4 to read more about the structure of a
                provider.) The following tables list and describe the properties and methods
                you must implement from the abstract classes.
              </p>

            </Element>
            <Element Type="Table" Name="Required ProviderBase Members">
              <table>
                <tr>
                  <th>Member</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>Initialize</code>
                  </td>
                  <td>
                    Takes as input the name of the provider and a NameValueCollection instance of configuration
                    settings. This method is used to set the property values for the provider
                    instance, including implementation-specific values and options specified in the
                    configuration file (Machine.config or Web.config).
                  </td>
                </tr>
              </table>
            </Element>

            <Element Type="Table" Name="Required SessionStateStoreProvider Members">
              <table>
                <tr>
                  <th>Member</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>InitializeRequest</code>
                  </td>
                  <td>
                    Uses the <code>HttpContext</code> of the current request and performs any initialization required by the
                    provider.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>EndRequest</code>
                  </td>
                  <td>
                    Uses the <code>HttpContext</code> of the current request and performs any cleanup.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>Dispose</code>
                  </td>
                  <td>
                    Frees any resources
                    no longer in use by the provider.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetItemExclusive</code>
                  </td>
                  <td>
                    Retrieves
                    session values and information from the session data store for a given Session
                    ID and <code>HttpContext</code>. Locks the session-item data in the store for the duration of the
                    request. Sets several output-parameter values that inform <code>SessionStateModule</code> about the state of the current item.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetItem</code>
                  </td>
                  <td>
                    As for the <code>GetItemExclusive</code> method, except that it does not attempt to lock the session item in
                    the data store. This method is used when you set the <code>EnableSessionState</code> attribute of @Page directive to <code>ReadOnly</code>.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>SetAndReleaseItemExclusive</code>
                  </td>
                  <td>
                    Updates
                    or releases the lock for the current session-state data. The <code>newItem</code> property forces the creation of a new item. Calls the <code>ResetItemTimeout</code> method internally to extend the expiration period.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>ReleaseItemExclusive</code>
                  </td>
                  <td>
                    This method is
                    called when the <code>GetItem</code> or <code>GetItemExclusive</code> method is called and the item is locked, but the lock duration has
                    exceeded the <code>ExecutionTimeout</code> value. Frees the item
                    and releases the lock.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>RemoveItem</code>
                  </td>
                  <td>
                    This method is called
                    when the <code>Abandon</code> method of the <code>Session</code> object is
                    called. Deletes the session information from the data store.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>CreateUninitializedItem</code>
                  </td>
                  <td>
                    Adds an
                    uninitialized item to the session data store with an <code>actionFlags</code> value set to <code>InitializeItem</code>.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>CreateNewStoreData</code>
                  </td>
                  <td>
                    Returns a new <code>SessionStateStoreData</code> object with empty data collections.
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>SetItemExpireCallback</code>
                  </td>
                  <td>
                    Takes a delegate that references the <code>Session_OnEnd</code> event. If this event is supported the method returns <code>true</code>; otherwise it returns <code>false</code>.
                  </td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">

              <p>
                The <code>GetItemExclusive</code> method is the most significant part of the provider. If no session
                item data is found in the data store, the method sets the <code>locked</code> output parameter to <code>false</code> and returns <code>null</code>. This causes the <code>SessionStateModule</code> to
                call the <code>CreateNewStoreData</code> method in order to create a new <code>SessionStateStoreData</code> object for the request. If the item is located but the data is
                locked, the <code>GetItemExclusive</code> method sets the <code>locked</code> output parameter to <code>true, </code>sets the <code>lockAge</code> output parameter to the current age of the item (that is, current
                timestamp minus creation timestamp), sets the <code>lockId</code>
                output parameter to the lock identifier retrieved from the data store, and
                returns <code>null</code>. This causes the <code>SessionStateModule</code> to
                call the <code>GetItemExclusive</code> method again after a half-second interval in an attempt to retrieve
                the session-item information and obtain a lock on the data. If the <code>lockAge</code> exceeds the <code>ExecutionTimeout</code> value,
                <code>SessionStateModule</code> calls the <code>ReleaseItemExclusive</code>
                method in order to clear the lock on the session-item data and calls the <code>GetItemExclusive</code> method again.
              </p>

              <p>
                The <code>actionFlags</code> parameter is used with sessions whose <code>Cookieless</code> property is <code>true</code> and whose <code>regenerateExpiredSessionId</code> attribute is set to <code>true</code>. The <code>actionFlags</code> value can be set to either <code>InitializeItem</code> or <code>None</code>. <code>InitializeItem</code> indicates that the entry in the session data store is a new session
                requiring initialization. Uninitialized entries are created by a call to the <code>CreateUninitializedItem</code> method. If the item from the session data store is already
                initialized, the <code>actionFlags</code> parameter
                is set to <code>None</code>.
              </p>

              <p>
                If your provider supports
                cookieless sessions, set the <code>actionFlags</code> output
                parameter to the value returned from the session data store for the current
                item. If the <code>actionFlags</code> parameter value for the
                requested session-store item equals <code>InitializeItem</code>, the <code>GetItemExclusive</code> method
                should set the session data in the data store to zero after setting the <code>actionFlags</code> out parameter.
              </p>

              <p>
                The <code>CreateUninitializedItem</code> method is used with cookieless sessions when the <code>regenerateExpiredSessionId</code> attribute is set to <code>true</code>. This causes the <code>SessionStateModule</code> to generate a new session ID value when an expired session is
                encountered. The process of generating a new session ID value requires the
                browser to be redirected to a URL that contains the newly generated ID. Refer
                to Listing 6-6 for an example of how to control the session ID generation
                process. The <code>CreateUninitializedItem</code> method is called
                during an initial request containing an expired session. After the <code>SessionStateModule</code> acquires a new ID to replace the expired one, it calls the <code>CreateUninitializedItem</code> method. The browser is then redirected to the URL containing the
                newly generated ID. The existence of the uninitialized entry in the session
                data store ensures that the redirected request with the newly generated ID is
                not mistaken for a request for an expired session, and is treated as a new
                session.
              </p>

            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Implementing a File-Based Session State Persister" >
          Implementing a File-Based Session State Persister
          <Element Type="Text">

            <p>
              The following example shows the basic
              implementation steps for a file-based store. This is not intended for real-life
              scenarios, but simply for learning and testing. Files are easy to monitor and
              you can see where the data goes.
            </p>

          </Element>
          <Element Type="Listing" Name="A simple file-based session state persister">

            using System;

            using System.Collections.Specialized;
            using System.IO;

            using System.Web;

            using System.Web.Configuration;

            using System.Web.SessionState;

            namespace Apress.SessionState.Code            {

                public sealed class FileSessionStateStore :
            SessionStateStoreProviderBase                {

                    private SessionStateSection sessconfig =
            null;

                    private string basePath;

                    private string applicationName;

                    public string ApplicationName                    {

                        get                        {

                            return applicationName;

                        }

                    }

                    public override void Initialize(string
            name, NameValueCollection config)

                    {

                        if (config == null)

                        {

                            throw new
            ArgumentNullException(&quot;config&quot;);

                        }
                        if (String.IsNullOrEmpty(name))

                        {

                            name =
            &quot;FileSessionStateStore&quot;;

                        }

                        if
            (String.IsNullOrEmpty(config[&quot;description&quot;]))

                        {

                           
            config.Remove(&quot;description&quot;);

                           
            config.Add(&quot;description&quot;, &quot;File Session State Store                                                       provider
            example&quot;);

                        }

                        base.Initialize(name, config);

                        applicationName =
            System.Web.Hosting.HostingEnvironment                                                            .ApplicationVirtualPath;

                        basePath =
            config[&quot;basePath&quot;];

                        System.Configuration.Configuration
            cfg = WebConfigurationManager                                                  .OpenWebConfiguration(ApplicationName);

                        sessconfig =
            (SessionStateSection)cfg                                                 .GetSection(&quot;system.web/sessionState&quot;);

                    }

                    public override void Dispose()

                    {

                    }
                    public override bool
            SetItemExpireCallback(

                                         SessionStateItemExpireCallback
            expireCallback)

                    {

                        return false;

                    }

                    public override void
            SetAndReleaseItemExclusive(HttpContext context,

                                                                  
            string id,

                                                                  
            SessionStateStoreData item,

                                                                   Object
            lockId,

                                                                  
            bool newItem)

                    {

                        // Serialize the
            SessionStateItemCollection as a string.

                        string sessItems =
            Serialize((SessionStateItemCollection)item.Items);

                        string path = Path.Combine(basePath,
            String.Format(&quot;{0}.ssd&quot;, id));

                        FileStream fs = null;
                        try                        {
                            if (newItem)

                            {

                                if (File.Exists(path))

                                {

                                    File.Delete(path);

                                }

                                fs = new FileStream(path,
            FileMode.CreateNew,

                                                          FileAccess.Write,
            FileShare.Read);

                            }

                            else                            {

                                // update item                                fs = new FileStream(path,
            FileMode.Open,                                                      

                                                          FileAccess.Write,
            FileShare.Read);

                            }

                            StreamWriter sw = new
            StreamWriter(fs);

                            sw.Write(sessItems);

                            sw.Close();

                        }

                        catch (IOException exception)

                        {

                            // add error handling                        }

                        finally                        {

                            if (fs != null)

                            {

                                fs.Close();

                                fs.Dispose();

                            }

                        }

                    }

                    public override SessionStateStoreData
            GetItem(HttpContext context,

                                                                  
            string id,

                                                                  
            out bool locked,

                                                                   out
            TimeSpan lockAge,

                                                                  
            out object lockId,

                                                           out SessionStateActions actionFlags)

                    {

                        return GetSessionStoreItem(false,
            context, id, out locked,

                                                    out
            lockAge, out lockId, out actionFlags);

                    }

                    public override SessionStateStoreData
            GetItemExclusive(HttpContext context,

                                                                  
            string id,

                                                                  
            out bool locked,

                                                                  
            out TimeSpan lockAge,

                                                                   out
            object lockId,

                                                           
            out SessionStateActions actionFlags)                  

                    {

                        return GetSessionStoreItem(true,
            context, id, out locked,
                                                    out
            lockAge, out lockId, out actionFlags);

                    }

                    private SessionStateStoreData GetSessionStoreItem(bool
            lockRecord,

                                                                  
            HttpContext context,

                                                                   string
            id,

                                                                  
            out bool locked,

                                                                  
            out TimeSpan lockAge,

                                                                  
            out object lockId,

                                                           
            out SessionStateActions actionFlags)

                    {

                        // Initial values for Return value
            and out parameters.

                        SessionStateStoreData item = null;

                        lockAge = TimeSpan.Zero;

                        lockId = null;

                        locked = false;

                        actionFlags =
            SessionStateActions.None;

                        string serializedItems =
            String.Empty;

                        string path = Path.Combine(basePath,
            String.Format(&quot;{0}.ssd&quot;, id));

                        FileStream fs = null;

                        try                        {

                            fs = new FileStream(path,
            FileMode.Open, FileAccess.Read,

                                                      FileShare.Read);

                            StreamReader sr = new
            StreamReader(fs);

                            serializedItems =
            sr.ReadToEnd();

                            sr.Close();

                        }

                        catch (IOException)

                        {

                            // add error handling here                        }

                        finally                        {

                            if (fs != null)

                            {

                                fs.Close();

                                fs.Dispose();

                            }

                        }
                        item = Deserialize(context,
            serializedItems, 1024);

                        return item;

                    }

                    private string
            Serialize(SessionStateItemCollection items)

                    {

                        MemoryStream ms = new
            MemoryStream();

                        BinaryWriter writer = new
            BinaryWriter(ms);

                        if (items != null)

                        {

                            items.Serialize(writer);

                        }

                        writer.Close();

                        return
            Convert.ToBase64String(ms.ToArray());

                    }

                    private SessionStateStoreData
            Deserialize(HttpContext context,

                                                             
             string serializedItems,

                                                               int
            timeout)

                    {

                        MemoryStream ms = new MemoryStream(

                                               Convert.FromBase64String(serializedItems));

                        SessionStateItemCollection
            sessionItems =

                                          new SessionStateItemCollection();

                        if (ms.Length &gt; 0)

                        {

                            BinaryReader reader = new
            BinaryReader(ms);

                            sessionItems =
            SessionStateItemCollection.Deserialize(reader);

                        }

                        return new SessionStateStoreData(sessionItems,

                               SessionStateUtility.GetSessionStaticObjects(context),
            timeout);

                    }

                    public override void
            ReleaseItemExclusive(HttpContext context,

                                                              
            string id, object lockId)

                    {

                        // release lock                    }

                    public override void
            RemoveItem(HttpContext context, string id,

                                                     object
            lockId, SessionStateStoreData item)

                    {

                        string path = Path.Combine(basePath,
            String.Format(&quot;{0}.ssd&quot;, id));

                        File.Delete(path);

                    }
                    public override void
            CreateUninitializedItem(HttpContext context, string id,

                                                                 int
            timeout)
                    {

                        string path = Path.Combine(basePath,
            String.Format(&quot;{0}.ssd&quot;, id));

                        FileStream fs = File.Create(path);

                        fs.Close();

                    }

                    public override SessionStateStoreData
            CreateNewStoreData(

                                                          HttpContext
            context, int timeout)

                    {

                        return new SessionStateStoreData(new
            SessionStateItemCollection(),

                               SessionStateUtility.GetSessionStaticObjects(context),
            timeout);

                    }

                    public override void
            ResetItemTimeout(HttpContext context, string id)

                    {

                        // refresh item                    }

                    public override void
            InitializeRequest(HttpContext context)

                    {

                    }

                    public override void EndRequest(HttpContext
            context)

                    {
                    }

                }

            }

          </Element>
          <Element Type="Text">

            <p>
              The implementation lacks error
              handling and several advanced features. However, the basic parts of the session
              provider are implemented to demonstrate how you can implement actions appropriate
              to the provider.
            </p>
            <p>
              Essentially, the provider
              obtains session data, serializes it, and stores it in a file. The expiration
              handling is based on the file’s last access time stamp. Concurrent access is also
              handled on the file level.
            </p>

          </Element>
          <Element Type="Section" Name = "Configuring the Provider" >
            Configuring the Provider
            <Element Type="Text">

              <p>
                Before you start working with the
                provider, you must configure the <code>sessionState</code>
                element in the <i>web.config</i> file.
              </p>

            </Element>
            <Element Type="Listing" Name="Configuring the Provider">

              &lt;sessionState
                 cookieless=&quot;true&quot;
                 regenerateExpiredSessionId=&quot;false&quot;
                 timeout=&quot;20&quot;
                 mode=&quot;Custom&quot;
                
              customProvider=&quot;FileSessionProvider&quot;
               
              sessionIDManagerType=&quot;Apress.SessionState.Code.SimpleSessionIDManager,
                                       Apress.SessionState&quot;&gt;
                 &lt;providers&gt;
                    &lt;add Name=&quot;FileSessionProvider&quot;
                         type=&quot;Apress.SessionState.Code.FileSessionStateStore,          
                               Apress.SessionState&quot;
                         basePath=&quot;c:\temp&quot;/&gt;                                                          
                 &lt;/providers&gt;                                     
              &lt;/sessionState&gt;

            </Element>
            <Element Type="Text">

              <p>
                There are at least three
                required settings. Firstly, the <code>mode</code> must be set to
                “Custom”. Secondly, the <code>customProvider</code>
                attribute must be set to the name of the provider. Finally, the provider itself
                must be configured as a sub-element of the <code>sessionState</code>
                element. The additional <code>basePath</code> attribute is a
                private configuration setting used in the code above.
              </p>
              <p>
                With these settings, all session
                data is written to and retrieved from the file system, using the path <i>C:\temp</i>
                for the default (root) application and <i>c:\ temp\&lt;appname&gt;</i> for any
                other application. 
              </p>

            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Summary" >
        Summary
        <Element Type="Text">

          <p>
            In this chapter, we examined several
            persistence techniques, and discovered that both page persisters and session
            state persisters exist in order to overcome the limitations of HTTP’s
            statelessness.
          </p>

          <p>
            Page persisters store page or
            form related data using control state and view state. The default storage location
            is a hidden field within the form. An alternative method is to store the data
            in local memory. The provider model is used to customize this storage, and the sample
            implementation demonstrates how to store data in the file system.
          </p>

          <p>
            Session state persisters,
            which are also based on the provider model, store session related data. The
            example above also shows how to replace the default storage with custom storage,
            and how to store the data in the file system.
          </p>

          <p>
            Extending persisters is a great
            way of improving performance, maintaining data within a web garden or farm, adding
            special features in order to handle specific environmental conditions, or better
            serving particular clients such as mobile devices.
          </p>

        </Element>
      </Element>
    </Element>
    <Element Type="Section" Name = "Security And User Management" >
      Security And User Management
      <Element Type="Text">
        <p>
          Most business applications include user
          management.  Such applications must therefore handle security and user
          settings. In ASP.NET, you’ll find a comprehensive collection of features,
          services, classes and controls to manage users, as well as their roles,
          settings, and access conditions.
        </p>
        <p>In this chapter, you’ll learn about: </p>
        <ul>
          <li>
            The components forming security
            and user management
          </li>
          <li>
            Extending the underlying providers,
            especially the Membership and Role providers
          </li>
          <li>
            Customizing and extending the
            profile provider
          </li>
        </ul>
        <p>
          All of these capabilities are based on
          the provider model introduced in chapter 4. (Of course, that is the resource
          for more about the basic design of providers and how to extend and configure
          them.)
        </p>
      </Element>
      <Element Type="Section" Name = "Built-In Capabilities">
        Built-In Capabilities
        <Element Type="Text">
          <p>
            Conceptually, ASP.NET employs the
            principle of “gate keepers”. A gate keeper is a module that sits on top of the
            pipeline observing every incoming request. Like any other module, its implementation
            is based on the IHttpModule interface.
            There are usually several such modules in a row, each of them handling a
            specific kind of access security or authorization. As we’ve learned in previous
            chapters, the provider and module models are highly extensible. This gives you
            the opportunity to add new modules specific to the needs of your application
            and your desired security levels.
          </p>
          <p>
            One of the basic concepts of web
            security is the statelessness of HTTP. Because the protocol essentially uses a “fire
            and forget” approach, the security aspects of every request must be checked. Since
            subsequent actions might require authorization or authentication, the security
            modules are positioned first in the line invoked by pipeline events.
          </p>
        </Element>
        <Element Type="Image" Name="The chain of authentication and authorization providers">
          images\19835f0701.tif
        </Element>
        <Element Type="Text">
          <p>
            The pipeline fires events in a specific
            order. Firstly, the user is authenticated via the AuthenticateRequest event. After establishing the user’s identity, authorization occurs,
            and the AuthorizeRequest event allows the user access to certain resources. The order in
            which these events are fired is crucial as the session state becomes available
            only after both events are handled (see Figure 7-2). This means that no session-related
            data can be stored to support the authentication and authorization modules.
          </p>
        </Element>
        <Element Type="Image" Name="Application events involved in the authentication and authorization cycle">
          images\19835f0702.tif
        </Element>
        <Element Type="Text">
          <p>
            After successful user identification, their
            credentials are stored as an object containing their information. These credentials
            consist of a username/password pair and, optionally, additional data such as roles
            or lifetime. Different authorization techniques, such as Windows authentication
            or Basic authentication, create different sets of credentials. Information which
            must be available during the whole processing cycle is bound to the current
            context, namely the HttpContext object. The
            user credentials are stored in the User
            property, and can be accessed in this manner:
          </p>
          <pre>
            System.Web.Security.IPrincipal user = Context.User;
          </pre>
          <p>
            Context is provided by
            the Page class. If you’re not using the Page class, HttpContext.Current.User retrieves the same object.
          </p>
          <p>
            The IPrincipal interface is a simple definition for a credential store. It
            contains the user identity (via an object that implements IIdentity) and the IsInRole method, to
            provide basic authorization support. However, this isn’t sufficient for typical
            applications. Several different implementations of these interfaces are
            available that fill in the gaps. IIdentity
            provides additional support properties, while AuthenticationType indicates which method was used to authenticate a user—such as “Forms”,
            “NTLM”, or “Custom”. IsAuthenticated reveals
            that one module of the chain of authentication modules (illustrated in Figure
            7-1) has identified the user. Each module can check whether the previous module
            has identified the user and, if so, create the appropriate identity object and
            skip the module’s own authentication process. Finally, the username is stored
            in the Name property of the IIdentity object as a
            unique key. There are several built-in implementations of the IIdentity interface:
          </p>
          <ul>
            <li>System.Web.Security.FormsIdentity</li>
            <li>System.Security.Principal.WindowsIdentity</li>
            <li>System.Security.Principal.GenericIdentity</li>
          </ul>
          <p>
            The namespaces reveal that the identity
            model is not limited to Web applications. Instead, the identity model is
            embedded within the framework’s security components, and as with most things in
            .NET, it is extensible.
          </p>
        </Element>
        <Element Type="Section" Name = "Authentication Modules" >
          Authentication Modules
          <Element Type="Text">
            <p>
              Several authentication modules are
              available in ASP.NET. Before building your own module, consider modifying an
              existing one. Identifying a module close to your requirements and customizing
              it is always a simpler solution than writing a new module from scratch. ASP.NET
              provides three core modules:
            </p>
            <ul>
              <li>FormsAuthenticationModule</li>
              <li>WindowsAuthenticationModule</li>
              <li>PassportAuthenticationModule</li>
            </ul>
            <p>
              The FormsAuthenticationModule provides a
              simple form-based technique which is highly compatible with most existing
              clients, but it is not the most secure. Unless the connection between the
              client and server uses SSL (secure socket layer), the username and password
              travel unencrypted at least once through the internet. For most applications,
              this isn’t acceptable. The WindowsAuthenticationModule, on the other hand,
              requires specific support from the client. Although most browsers handle it well,
              keep in mind that some devices (such as mobile gadgets) could fail. The
              PassportAuthenticationModule is listed simply for completeness—it isn’t a
              viable alternative. Microsoft’s Passport concept was discontinued and has now
              been replaced by Live ID, which has not yet attracted wide-spread client support.
            </p>
          </Element>
          <Element Type="Section" Name = "Set up the Authentication Module" >
            Set up the Authentication Module
            <Element Type="Text">
              <p>
                To set up an authentication module,
                you’ll need to make an entry in the <i>web.config</i> file. The element &lt;authentication&gt; is responsible for defining and configuring the appropriate module.
                As a module is responsible for handling all incoming requests, you can’t define
                the element in subfolders, and overriding the root settings would create a
                conflict within the pipeline. (However, this will be possible for the
                authorization method discussed later in the chapter.)
              </p>
              <p>
                The mode attribute
                has three commonly used values:
              </p>
              <pre>
                &lt;authentication mode=&quot;Forms&quot;
                /&gt;
                &lt;authentication mode=&quot;Windows&quot;
                /&gt;
                &lt;authentication mode=&quot;None&quot;
                /&gt;
              </pre>
              <p>
                As there is no “Custom” value, you’ll
                have to utilize one of the existing techniques when you add your own membership
                system. (The “Custom” value isn’t provided because you’d need to support
                existing clients, and writing custom clients isn’t feasible.) Web applications
                that deal with private data are usually protected by a form of transport layer
                security which allows the usage of forms authentication for publicly accessible
                sites and Windows authentication for intranet applications. For the
                configuration of forms authentication, the child element &lt;form&gt; provides the appropriate settings.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Authorization Modules" >
          Authorization Modules
          <Element Type="Text">
            <p>
              After authenticating the user, you need
              to determine what he or she is permitted to request. This is all about
              accessing resources. As there are two kinds of resources on a web server, files
              and URLs, there are two built-in authorization modules:
            </p>
            <ul>
              <li>FileAuthorization</li>
              <li>UrlAuthorization</li>
            </ul>
            <p>
              If you have already set up the
              membership system and not defined the authorization explicitly, you might
              wonder how it works as expected. This is because ASP.NET uses the FileAuthorization module if Windows authentication is set. No additional
              configuration step is required. Thus, if Window authentication is used, the
              NTFS file access security is employed, based on Windows ACLs (access control
              lists).
            </p>
          </Element>
          <Element Type="Section" Name = "Using Impersonation" >
            Using Impersonation
            <Element Type="Text">
              <p>
                In the context of Windows
                authentication, impersonation occurs when the identity of the logged-in user is
                changed and the new identity’s credentials are used to access resources. This
                is a common technique, but it’s dangerous. If the user base is large, and the roles
                and access policies grow, management becomes arduous. Furthermore, authentication
                mistakes create security holes, as parts of the application could run under an account
                other than that intended by the developer. 
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Set up Authorization" >
            Set up Authorization
            <Element Type="Text">
              <p>
                The URL authorization controls access to
                directories and files. It can be configured by setting the appropriate child
                elements of the current &lt;authorization&gt;
                element. Restrictions may be set based on both user and role. File
                authorization does not require any settings here.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "The User Management Interfaces" >
          The User Management Interfaces
          <Element Type="Text">
            <p>
              Included with ASP.NET are a number of
              tools to support user management, the details of which are beyond the scope of
              this book. However, I’ll give a general overview of the extensibility
              interfaces. There are three parts responsible for handling user management:
            </p>
            <ul>
              <li>Membership Service</li>
              <li>Role Service</li>
              <li>Profile Service</li>
            </ul>
            <p>
              “Membership” is about user
              identification and management. With the appropriate classes and controls, you
              can create, edit, and delete user accounts. This includes login and logout
              facilities based on controls, as well as several features which enhance user
              experience (such as password recovery or ability to view the current name and
              login status). ASP.NET includes several built-in management tools to assist administrators
              with handling users, based on a SQL Server database store.
            </p>
            <p>
              “Role” performs authorization
              tasks. Roles provide access to resources and can be assigned to many users. If
              the user becomes a member of a role, he or she gains access to the resources
              the role is permitted to retrieve. The built-in management tools support the
              role model.
            </p>
            <p>
              “Profile” complements the user
              management by adding a user-specific data store. This allows you to maintain
              per-user settings between visits. Profiles are not intended to support session-related
              processes. Instead, they allow a user to customize a site specifically for
              their own preferences—think of a “MySite” type of functionality. ASP.NET
              includes many features, services and object types to support profiles.
            </p>
          </Element>
          <Element Type="Section" Name = "Extensibility Issues" >
            Extensibility Issues
            <Element Type="Text">
              <p>
                The extensibility model is based on
                providers. The three services mentioned above use providers to save and retrieve
                their data. By default, data is stored in a SQL Server database. It’s often
                necessary to use alternative or existing storage, Active Directory, LDAP, or a
                custom solution. Several built-in providers are included with each service in
                order to support different stores.
              </p>
            </Element>
            <Element Type="Image" Name="The class hierarchy for built-in Membership and Role providers">
              images\19835f0700.tif
            </Element>
            <Element Type="Text">
              <p>
                The default providers use a SQL
                Server database. These are the SqlMembershipProvider
                and the SqlRoleProvider. ASP.NET also supports Active Directory (AD) out-of-the-box, via the
                ActiveDirectoryMembershipProvider.
              </p>
              <p>
                The following table shows all the
                basic members of the membership provider classes.
              </p>
              <Element Type="Table" Name="Members of the MembershipProvider classes*">
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>
                      <code>ChangePassword</code>
                    </td>
                    <td>
                      Changes the password.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ChangePasswordQuestionAndAnswer</code>
                    </td>
                    <td>
                      Changes
                      the password question and answer.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>CreateUser</code>
                    </td>
                    <td>
                      Creates
                      a new user.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>DecryptPassword</code>
                    </td>
                    <td>
                      Decrypts
                      the password.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>DeleteUser</code>
                    </td>
                    <td>
                      Deletes
                      a user.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>EncryptPassword</code>
                    </td>
                    <td>
                      Encrypts
                      the password.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>FindUsersByEmail</code>
                    </td>
                    <td>
                      Finds
                      a user using his or her email address.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>FindUsersByName</code>
                    </td>
                    <td>
                      Finds
                      a user using his or her name.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetAllUsers</code>
                    </td>
                    <td>
                      Retrieves
                      a list of all users.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetNumberOfUsersOnline</code>
                    </td>
                    <td>
                      Retrieves
                      a list of all currently logged-in users. The behavior depends on the provider
                      and does not necessarily report the exact value.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetPassword</code>
                    </td>
                    <td>
                      Retrieves
                      the password for a given name.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetUser</code>
                    </td>
                    <td>
                      Retrieves
                      a System.Web.Security.MembershipUser object based on the name.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetUserNameByEmail</code>
                    </td>
                    <td>
                      Retrieves
                      the name using an email address.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>Initialize</code>
                    </td>
                    <td>
                      Initializes
                      the provider. Inherited from ProviderBase.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ResetPassword</code>
                    </td>
                    <td>
                      Resets
                      the current password with an automatically generated one.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>UnlockUser</code>
                    </td>
                    <td>
                      Unlocks
                      a locked user.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>UpdateUser</code>
                    </td>
                    <td>
                      Updates
                      the user’s information in the data store.  
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ValidateUser</code>
                    </td>
                    <td>
                      Checks
                      whether the user with the provided password is a legitimate user.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ValidatingPassword</code>
                    </td>
                    <td>
                      An
                      event fired while the provider validates the password.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ApplicationName</code>
                    </td>
                    <td>
                      The
                      name of the application. A membership provider can support several applications
                      and supports different data storage for each application. Inherited from ProviderBase.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>EnablePasswordReset</code>
                    </td>
                    <td>
                      Defines
                      whether or not the user can reset their password.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>EnablePasswordRetrieval</code>
                    </td>
                    <td>
                      Defines
                      whether or not the user can retrieve their password.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>MaxInvalidPasswordAttempts</code>
                    </td>
                    <td>
                      Determines
                      the maximum number of false password attempts allowed before the account is locked.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>MinRequiredNonAlphanumericCharacters</code>
                    </td>
                    <td>
                      Minimum
                      number of non-alphanumeric characters a password must have.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>MinRequiredPasswordLength</code>
                    </td>
                    <td>
                      Minimum
                      password length.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>Name</code>
                    </td>
                    <td>
                      Name
                      of the provider. Inherited from ProviderBase.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>PasswordAttemptWindow</code>
                    </td>
                    <td>
                      Prevents
                      “brute force” attempts to guess a password. If the MaxInvalidPasswordAttempts occur within PasswordAttemptWindow
                      (in minutes), that user’s account is locked.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>PasswordFormat</code>
                    </td>
                    <td>
                      Format
                      in which the password is saved in the storage. This is a value from the
                      enumeration <code>MembershipPasswordFormat</code>, which provides
                      the values <code>Clear</code>, Hashed, or Encrypted. Hashes are unidirectional encryption methods. The default hash
                      format is SHA1.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>PasswordStrengthRegularExpression</code>
                    </td>
                    <td>
                      A
                      regular expression that is used to check whether or not the password meets the
                      minimum password strength required by your application.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>RequiresQuestionAndAnswer</code>
                    </td>
                    <td>
                      Determines
                      whether the provider supports the password retrieval using the question and
                      answer technique.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>
                        RequiresUniqueEmail
                      </code>
                    </td>
                    <td>
                      whether or not the email address
                      must be unique in the database.
                    </td>
                  </tr>
                </table>
              </Element>
              <Element Type="Text">
                <p>
                  * Covers both SqlMembershipProvider and
                  ActiveDirectoryMembershipProvider
                </p>
                <p>
                  For the role provider, things
                  look a little different. The AuthorizationStoreRoleProvider class
                  supports three kinds of role data storage: the Active Directory itself, an
                  Active Directory Application Mode server (ADAM), or an XML file. For these
                  three modes, a connection string defines the data source. The connection string
                  begins with
                  msxml:// for an XML
                  file, or with <code>msldap://</code> for Active Directory or ADAM .
                  The WindowsTokenRoleProvider uses the local Windows user database to retrieve the role
                  information. Don’t confuse this with Windows groups. Direct access to Windows
                  group information is not supported by this provider. While you can obtain membership
                  information about a group, you cannot write, delete, or change these memberships
                  even if management tools support this. From the perspective of ASP.NET, the  WindowsTokenRoleProvider provides read-only access.
                </p>
                <p>
                  None of these classes are sealed.
                  This means that you can inherit from each class and override methods and
                  properties to change behavior as desired.
                </p>
                <p>
                  The following table shows all
                  basic members of the role provider classes:
                </p>
              </Element>
              <Element Type="Table" Name="Members of the RoleProvider classes">
                <table>
                  <tr>
                    <th>Name</th>
                    <th>Description</th>
                    <th>Not supported</th>
                  </tr>
                  <tr>
                    <td>
                      <code>AddUsersToRoles</code>
                    </td>
                    <td>
                      Add
                      users to roles. Defined in RoleProvider.
                    </td>
                    <td>
                      W
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>CreateRole</code>
                    </td>
                    <td>
                      Create
                      a new role. Defined in RoleProvider.
                    </td>
                    <td>
                      W
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>DeleteRole</code>
                    </td>
                    <td>
                      Delete
                      a role. Defined in RoleProvider.
                    </td>
                    <td>
                      W
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>FindUsersInRole</code>
                    </td>
                    <td>
                      Find
                      all users within a role. Defined in RoleProvider.
                    </td>
                    <td>
                      W,
                      A
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetAllRoles</code>
                    </td>
                    <td>
                      Get
                      a list of all roles. Defined in RoleProvider. 
                    </td>
                    <td>
                      W
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetRolesForUser</code>
                    </td>
                    <td>
                      Get
                      all roles for a user. Defined in RoleProvider.
                    </td>
                    <td>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>GetUsersInRole</code>
                    </td>
                    <td>
                      Get
                      all users in a role. Defined in RoleProvider.
                    </td>
                    <td>
                      W
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>IsUserInRole</code>
                    </td>
                    <td>
                      Indicates
                      whether or not a user is in a role. Defined in RoleProvider.
                    </td>
                    <td>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>RemoveUsersFromRoles</code>
                    </td>
                    <td>
                      Remove
                      users from roles. Defined in RoleProvider.
                    </td>
                    <td>
                      W
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>RoleExists</code>
                    </td>
                    <td>
                      Indicates
                      whether the role exists. Defined in RoleProvider.
                    </td>
                    <td>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ApplicationName</code>
                    </td>
                    <td>
                      Name
                      of the application. A role provider can support several applications and
                      different data storage for each application. Defined in ProviderBase.
                    </td>
                    <td>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>Description</code>
                    </td>
                    <td>
                      Description
                      used in ProviderBase.
                    </td>
                    <td>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ScopeName</code>
                    </td>
                    <td>
                      Scope
                      for the authorization store.
                    </td>
                    <td>
                      W, S
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>CacheRefreshInterval</code>
                    </td>
                    <td>
                      Time
                      (in minutes) the provider caches role information
                    </td>
                    <td>
                      W, S
                    </td>
                  </tr>
                  <tr>
                    <td>
                      Name
                    </td>
                    <td>
                      Name
                      as used in <code>ProviderBase</code>.
                    </td>
                    <td></td>
                  </tr>
                </table>
              </Element>
              <Element Type="Text">
                <p>
                  * W = WindowsTokenRoleProvider, S =
                  SqlRoleProvider, A = AuthorizationStoreRoleProvider
                </p>
                <p>
                  With this overview of the capabilities
                  of different providers, we can now investigate how to extend them.
                </p>
              </Element>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Extending Membership and Role Providers" >
        Extending Membership and Role Providers
        <Element Type="Text">
          <p>
            The functionality of the built-in
            providers suits most common types of applications. Before constructing your own
            provider, let’s take a look at when and why it’s more practical to create or
            extend a built-in one.
          </p>
        </Element>
        <Element Type="Section" Name = "Why Create a Membership Provider?" >
          Why Create a Membership Provider?
          <Element Type="Text">
            <p>
              The purpose of a provider is to manage
              access to data storage. Extending the provider model is necessary if you want
              to use a different storage for your user database. The SqlMembershipProvider supports a SQL Server database, while the ActiveDirectoryMembershipProvider supports the Active Directory. Creating a service infrastructure
              following the principles of service oriented architectures (SOA) requires
              another method—Web services. One reason for creating a custom membership
              provider is the ability to use Web services. As shown in Table 7-1, the MembershipProvider base class supports an incredible number of features. Whether you
              require some or all of these depends on the needs of your application.
            </p>
            <p>
              In the following example, I’ll demonstrate
              the basic principles of a custom membership provider in the particular case of
              authenticating users against a Web service. The service provides a transparent
              tier against a data store. This means that the service can run anywhere in your
              organization as a central point of service, and the users of the service—the provider—knows
              nothing about the data storage behind the service. Security is enhanced by
              hiding all data storage implementation details behind the publicly visible web
              service methods. For simplicity and demonstration purposes only, the example service
              stores user information in a simple XML file. This allows you to observe the
              file and learn exactly how the provider behaves.
            </p>
            <p>
              In the following sections, I’ll show the
              sample code and explain the implementation details.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Solution Details" >
          Solution Details
          <Element Type="Text">
            <p>
              Developing a custom provider firstly requires
              a data source. In this example, I’ll use an XML file as storage and a WCF
              (Windows Communication Foundation) service to access the file remotely. This
              demonstrates that it’s possible to transparently access a remote data store
              using standard framework techniques.
            </p>
            <p>The solution consists of:</p>
            <ul>
              <li>
                A WCF service project with two
                services, one for Membership and the other for Roles
              </li>
              <li>
                A Web project configured to use the
                custom provider that has:
              </li>
              <li>
                <ul>
                  <li>
                    An implementation of a
                    custom Membership Provider
                  </li>
                  <li>
                    An implementation of a
                    custom Role Provider
                  </li>
                  <li>
                    A service reference to
                    use the WCF service
                  </li>
                </ul>
              </li>
            </ul>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Developing Membership and Role Providers" >
        Developing Membership and Role Providers
        <Element Type="Text">
          <p>
            Both Membership and Role providers
            support several features. Whether or not you implement all features, extend
            additional ones, or simply create a rudimentary service depends on your
            application and requirements. In this example, I’ll implement all the basic
            features via a simplified approach for the sake of brevity. 
          </p>
        </Element>
        <Element Type="Section" Name = "Create Web Service Driven Membership Provider">
          Create Web Service Driven Membership Provider
          <Element Type="Text">
            <p>
              The Web service driven membership
              provider consists of three parts:
            </p>
            <ol>
              <li>The user data store—an XML file</li>
              <li>The service tier—a Web service with several useful methods</li>
              <li>The Membership Provider implementation</li>
            </ol>
          </Element>
        </Element>
        <Element Type="Section" Name = "Create Web Service Driven Role Provider" >
          Create Web Service Driven Role Provider
          <Element Type="Text">
            <p>
              The Web service driven role provider also
              consists of three parts:
            </p>
            <ol>
              <li>The same XML file as used in the user data store, extended with role properties</li>
              <li>The service tier—a Web service with several useful methods</li>
              <li>The Role Provider implementation</li>
            </ol>
            <p>
              For both providers, we’ll need a simple
              test environment. Consider creating some pages using various Login controls, such
              as the CreateUserWizard. This functions well but requires additional work. To begin with, I
              recommend using the built-in ASP.NET configuration application. Launch it
              locally in Visual Studio from the <i>Project</i> and <i>ASP.NET configuration</i>
              menu items. Using the embedded Web server, Visual Studio starts a web
              application which allows you to manage users and roles with the current
              provider. Before doing so, you’ll need to configure the providers. However, we’ll
              begin by developing the entire application.
            </p>
          </Element>
          <Element Type="Section" Name = "Developing the Service Tier" >
            Developing the Service Tier
            <Element Type="Text">
              <p>
                The service tier uses WCF to create two
                Web services, one for Membership management and one for Role management. To
                create the service:
              </p>
              <ul>
                <li>
                  Within Visual Studio create a
                  new project via <i>File &gt; New &gt; Project &gt; WCF &gt; WCF Service Library</i>
                </li>
                <li>Name the project “Membership”</li>
                <li>
                  Add two services to the project using
                  <i>Add</i> from the context menu. Select <i>New Item</i> and in the following
                  dialog choose <i>WCF Service</i>.
                </li>
              </ul>
            </Element>
            <Element Type="Image" Name="Adding a new WCF service to the service library">
              images\19835f0703.tif
            </Element>
            <Element Type="Text">
              <p>
                The wizard creates a service interface (the
                contract for the service), the class with the implementation and the required
                entries in <i>web.config</i> file to define the service endpoint. The endpoint
                is a definition used later in the web application where you can access the
                service. The contract is usually an interface decorated with the [ServiceContract] attribute. Each method that is exposed as a service call is
                decorated with the [OperationContract]
                attribute. Both attributes support several settings for modifying behavior and
                appearance. However, this is beyond the scope of this book, and default
                settings can be used for this example as well.
              </p>
            </Element>
            <Element Type="SideBar" SidebarType="Tip">
              <header>Tip</header>
              <aside>
                If you want to learn
                more about professional WCF development, refer to the book “Pro WCF: Practical
                Microsoft SOA Implementation” from Apress, ISBN 978-1-59059-702-6.
              </aside>
            </Element>
            <Element Type="Section" Name = "Creating the Membership Service" >
              Creating the Membership Service
              <Element Type="Text">
                <p>
                  The Membership service consists of the
                  following interfaces and classes:
                </p>
                <ul>
                  <li>IMembershipService interface</li>
                  <li>MembershipService service</li>
                  <li>MembershipService class</li>
                  <li>UserData class</li>
                  <li>User class</li>
                  <li>FileManager class</li>
                </ul>
                <p>
                  All the code to build the service is shown
                  and explained below.
                </p>
              </Element>
              <Element Type="SideBar" SidebarType="Note">
                <header>Note</header>
                <aside>
                  For sake of brevity and
                  space, the following code lacks error handling, “using” statements, and
                  namespace definitions. Please refer to the sample code provided with the book for
                  the full implementation.
                </aside>
              </Element>
              <Element Type="Listing" Name="The IMembershipService interface defines the contract">
                [ServiceContract]
                public interface IMembershipService
                {
                    [OperationContract]
                    bool ChangePassword(string username, string
                oldPassword, string newPassword);

                    [OperationContract]

                    bool ChangePasswordQuestionAndAnswer(string
                username, string password,

                                                          string
                newPasswordQuestion,

                                                          string
                newPasswordAnswer);

                    [OperationContract]

                    User CreateUser(string username, string
                password, string email,

                                    string passwordQuestion,
                string passwordAnswer,

                                    bool isApproved, object
                providerUserKey,

                                    out MembershipCreateStatus
                status);

                    [OperationContract]

                    bool DeleteUser(string username, bool
                deleteAllRelatedData);

                    [OperationContract]

                    List&lt;User&gt; FindUsersByEmail(string
                emailToMatch, int pageIndex,

                                                 int pageSize,
                out int totalRecords);

                    [OperationContract]

                    List&lt;User&gt; FindUsersByName(string
                usernameToMatch, int pageIndex,

                                                int pageSize,
                out int totalRecords);

                    [OperationContract]

                    List&lt;User&gt; GetAllUsers(int pageIndex,
                int pageSize, out int totalRecords);

                    [OperationContract]

                    int GetNumberOfUsersOnline();

                    [OperationContract]

                    string GetPassword(string username, string
                answer);

                    [OperationContract(Name =
                &quot;GetUserbyName&quot;)]

                    User GetUser(string username, bool
                userIsOnline);

                    [OperationContract]

                    string GetUserNameByEmail(string email);

                    [OperationContract]

                    string ResetPassword(string username, string
                answer);

                    [OperationContract]

                    bool UnlockUser(string userName);

                    [OperationContract]

                    void UpdateUser(User user);

                    [OperationContract]

                    bool ValidateUser(string username, string
                password);

                }
              </Element>
              <Element Type="Text">
                <p>
                  The interface is not unusual. Each
                  method decorated with the OperationContract
                  attribute is exposed by the service. As shown in the listing for the GetUser method, the method’s name can be modified. This is necessary if you
                  wish to use overloaded methods (methods that have the same name, but a different
                  parameter list signature). The service lacks this capability and requires
                  unique names. The OperationContract
                  attribute’s <code>Name</code> property separates internal logic from
                  the external service façade.
                </p>

                <p>
                  Once the interface is completed,
                  it must be implemented. Begin with a service file that links to a code-behind
                  file.
                </p>
              </Element>
              <Element Type="Listing" Name="The MembershipService.svc file is required in order to publish the service">
                &lt;%@ ServiceHost Language=&quot;C#&quot;
                Debug=&quot;true&quot;
                    Service=&quot;Apress.Extensibility.Membership.MembershipService&quot;
                    CodeBehind=&quot;MembershipService.svc.cs&quot;
                %&gt;
              </Element>
              <Element Type="Text">
                <p>
                  The logic of the service is coded in the
                  code-behind file, shown in the next listing.
                </p>
              </Element>
              <Element Type="Listing" Name="The MembershipService class is the implementation">
                [FileIOPermission(SecurityAction.LinkDemand)]
                public class MembershipService : IMembershipService

                {

                    public bool ChangePassword(string username,
                string oldPassword,

                                                string
                newPassword)

                    {

                        throw new NotImplementedException();

                    }

                    public bool
                ChangePasswordQuestionAndAnswer(string username, string password,

                                                                 string
                newPasswordQuestion,

                                                                
                string newPasswordAnswer)

                    {

                        throw new NotImplementedException();

                    }

                    public User CreateUser(string username,
                string password, string email,

                                            string
                passwordQuestion, string passwordAnswer,

                                            bool isApproved,
                object providerUserKey,

                                            out
                System.Web.Security.MembershipCreateStatus status)

                    {

                        User user = null;

                        UserData ud = FileManager.Load();

                        // check users, consider adding more
                data here

                        var hasUser = from u in ud.Users where
                u.UserName.Equals(username) select u;

                        if (hasUser.Count() &gt; 0)

                        {

                            status =
                MembershipCreateStatus.DuplicateUserName;

                            return null;

                        }

                        var hasEmail = from u in ud.Users where
                u.Email.Equals(email) select u;

                        if (hasEmail.Count() &gt; 0)

                        {

                            status =
                MembershipCreateStatus.DuplicateEmail;

                            return null;

                        }

                        try

                        {

                            user = new User(

                                username,

                                email,

                                passwordQuestion,

                                &quot;&quot;,

                                isApproved,

                                false,

                                DateTime.Now,

                                DateTime.MinValue,

                                DateTime.MinValue,

                                DateTime.Now,

                                DateTime.MinValue);

                            // Store Hash Only

                            user.Password =
                FileManager.CalculateSHA1(password);

                            ud.Users.Add(user);

                            FileManager.Save(ud);

                            status =
                MembershipCreateStatus.Success;

                        }

                        catch

                        {

                            status =
                MembershipCreateStatus.ProviderError;

                        }

                        return user;

                    }

                    public bool DeleteUser(string username, bool deleteAllRelatedData )
                    {

                        UserData ud = FileManager.Load();

                        var user = (from u in ud.Users

                                    where
                u.UserName.Equals(username)

                                    select
                u).FirstOrDefault&lt;User&gt;();

                        if (user != null)

                        {

                            ud.Users.Remove(user);

                            FileManager.Save(ud);

                            return true;

                        }

                        return false;

                    }

                    public List&lt;User&gt;
                FindUsersByEmail(string emailToMatch, int pageIndex,

                                                        int
                pageSize, out int totalRecords)

                    {

                        UserData ud = FileManager.Load();

                        var users = (from u in ud.Users

                                     where
                u.Email.Equals(emailToMatch)

                                     select
                u).ToList&lt;User&gt;();

                        totalRecords = users.Count();

                        return GetPaged(users, pageIndex,
                pageSize);

                    }

                    public List&lt;User&gt;
                FindUsersByName(string usernameToMatch, int pageIndex,

                                                       int
                pageSize, out int totalRecords)

                    {

                        UserData ud = FileManager.Load();

                        var users = (from u in ud.Users

                                     where
                u.UserName.Equals(usernameToMatch)

                                     select
                u).ToList&lt;User&gt;();

                        totalRecords = users.Count();

                        return GetPaged(users, pageIndex,
                pageSize);

                    }

                    public List&lt;User&gt; GetAllUsers(int
                pageIndex, int pageSize, out int totalRecords)

                    {

                        UserData ud = FileManager.Load();

                        totalRecords = ud.Users.Count;

                        return GetPaged(ud.Users, pageIndex,
                pageSize);

                    }

                    private List&lt;User&gt; GetPaged(List&lt;User&gt;
                ud, int pageIndex, int pageSize)

                    {

                        pageSize = Math.Min(ud.Count, pageSize);

                        return ud.GetRange(pageIndex * pageSize,
                pageSize);

                    }

                    public int GetNumberOfUsersOnline()

                    {

                        // Users who logged in within the last
                15 mins

                        UserData ud = FileManager.Load();

                        var users = (from u in ud.Users

                                     where
                u.LastActivityDate.AddMinutes(15) &gt; DateTime.Now

                                     select u);

                        return users.Count();
                    }
                    public string GetPassword(string username, string answer)

                    {

                        UserData ud = FileManager.Load();

                        var user = (from u in ud.Users

                                    where
                u.UserName.Equals(username) &amp;&amp; 

                                          u.PasswordAnswer.Equals(answer)


                                    select
                u).First&lt;User&gt;();

                        if (user != null)

                        {

                            return user.Password;

                        }

                        return null;

                    }

                    public User GetUser(string username, bool
                userIsOnline)

                    {

                        UserData ud = FileManager.Load();

                        var user = (from u in ud.Users

                                    where
                u.UserName.Equals(username) &amp;&amp;

                                    (userIsOnline) ?

                                       
                u.LastActivityDate.AddMinutes(15) &gt; DateTime.Now :

                                        true // all users

                                    select
                u).FirstOrDefault&lt;User&gt;();

                        return user;

                    }

                    public string GetUserNameByEmail(string
                email)

                    {

                        UserData ud = FileManager.Load();

                        var user = (from u in ud.Users

                                    where u.Email.Equals(email)

                                    select
                u).FirstOrDefault&lt;User&gt;();

                        if (user != null)

                        {

                            return user.UserName;

                        }

                        return null;

                    }

                    public string ResetPassword(string username, string answer)

                    {

                        UserData ud = FileManager.Load();

                        var user = (from u in ud.Users

                                    where
                u.UserName.Equals(username) &amp;&amp;  

                                          u.PasswordAnswer.Equals(answer)

                                    select
                u).FirstOrDefault&lt;User&gt;();

                        if (user != null)

                        {

                            return user.Password;

                        }

                        return null;

                    }

                    public bool UnlockUser(string userName)

                    {

                        throw new NotImplementedException();

                    }

                    public void UpdateUser(User user)

                    {

                        UserData ud = FileManager.Load();

                        var userToUpdate = (from u in ud.Users

                                            where
                u.UserName.Equals(user.UserName)

                                            select
                u).FirstOrDefault&lt;User&gt;();

                        foreach (PropertyInfo pi in
                user.GetType().GetProperties(

                                 BindingFlags.Public |
                BindingFlags.Instance))

                        {

                            PropertyInfo piTarget = typeof(User).GetProperty(pi.Name);

                            if (piTarget != null)

                            {

                               piTarget.SetValue(userToUpdate,
                pi.GetValue(user, null), null);

                            }

                        }

                        FileManager.Save(ud);

                    }

                    public bool ValidateUser(string username,
                string password)

                    {

                        UserData ud = FileManager.Load();

                        string hash =
                FileManager.CalculateSHA1(password);

                        var user = (from u in ud.Users

                                    where
                u.UserName.Equals(username) &amp;&amp;

                                          u.Password.Equals(hash)

                                    select
                u).FirstOrDefault&lt;User&gt;();

                        return (user != null);

                    }

                }
              </Element>
              <Element Type="Text">
                <p>
                  Most of these methods follow the same code
                  pattern. The current content of the membership data store —an XML file—is
                  loaded by calling FileManager.Load  (see Listing 7-6). This ensures that changes
                  made by parallel calls are handled properly. Each method uses a LINQ query to obtain
                  the required data. If the method needs to persist changes, the updated UserData object is saved back to the storage file.
                </p>
              </Element>
              <Element Type="SideBar" SidebarType="Tip">
                <header>Tip</header>
                <aside>
                  If you want to learn
                  more about LINQ, I recommend “LINQ for Visual C# 2008”, published by Apress (ISBN
                  978-1-4302-1580-6).
                </aside>
              </Element>
              <Element Type="Text">
                <p>
                  Passwords require special
                  treatment. They aren’t usually stored in an unencrypted format, so you’ll need to
                  choose to either encrypt the password or store a hash of the password.
                </p>
                <p>
                  Hashes are a one-way
                  encryption technique. To validate a user logging in, you simply hash their
                  supplied password and compared the result with the stored hash value. Storing a
                  hash is good practice, because the hash algorithm was designed to make it
                  almost impossible to derive the original text from the hash value. On the other
                  hand, the hash doesn’t support password retrieval. Instead, the user receives a
                  new password when he or she requests a lost one. This requires more effort, as the
                  provider must create generic passwords, and the application must support
                  password change forms, and so forth. In the example code, the password is
                  stored as a hash, despite there being no password generator. The password is hashed
                  using the SHA1 hash algorithm. This is safe and easy to use. Listing 7-6 shows
                  the FileManager.CalculateSHA1 method. If you plan to implement the provider in an application,
                  consider using an encrypted password that you can decrypt on request.
                </p>
                <p>
                  The code also has a hard coded
                  setting for the calculation of the number of users online (the GetNumberOfUsersOnline method). Based on the time of last activity, all users that have
                  logged in within the last 15 minutes are counted as being online. This is an
                  extremely simplified algorithm, but it demonstrates one possible approach.
                </p>
                <p>
                  One significant method is CreateUser. It checks several conditions in order to avoid duplicate
                  usernames, email addresses, or other unwanted data. The example checks just two
                  of a wide range of possible conditions. First, it tests for duplicate user names.
                  If this occurs, the method sets the property status to MembershipCreateStatus.DuplicateUserName . Second, it checks for duplicate email addresses and sets the
                  status to MembershipCreateStatus.DuplicateEmail, if required. You can refer to the MembershipCreateStatus enumeration to find more return values and conditions to test. If everything
                  checks out, the MembershipCreateStatus.Success value is set. The MembershipCreateStatus.ProviderError condition is used if unexpected errors are caught by the try-<code>catch</code> statement.
                </p>
                <p>
                  The class uses the UserData class heavily. This class is straightforward, containing a
                  serializable collection of User and Role objects:
                </p>
              </Element>
              <Element Type="Listing" Name="The UserData class is the container for serializing users and roles">
                public class UserData
                {

                    public UserData()
                    {
                    }

                    [XmlElement]
                    public List&lt;User&gt; Users
                    {
                        get;
                        set;
                    }

                    [XmlElement]
                    public List&lt;string&gt; Roles
                    {

                        get;
                        set;

                    }
                }
              </Element>
              <Element Type="Text">
                <p>
                  Because the serialization uses the XmlSerializer (shown in Listing 7-6), all elements requiring serialization are
                  tagged with the XmlElement attribute.
                  The User object contains all data pertaining to a specific account. This
                  class is shown next.
                </p>
              </Element>
              <Element Type="Listing" Name="The User class serializes a single user">
                [Serializable]
                [DataContract]
                public class User
                {

                    public User()
                    {
                    }

                    public User(string name, string email, string passwordQuestion,
                                string comment, bool isApproved, bool isLockedOut,
                                DateTime creationDate, DateTime lastLoginDate,
                                DateTime lastActivityDate,DateTime lastPasswordChangedDate,
                                DateTime lastLockoutDate)

                    {

                        this.UserName = name;

                        this.Email = email;

                        this.Comment = comment;

                        this.IsApproved = isApproved;

                        this.IsLockedOut = isLockedOut;

                        this.CreationDate = creationDate;

                        this.LastLoginDate = lastLoginDate;

                    }

                    [DataMember]

                    [XmlElement]

                    public string Comment { get; set; }

                    [DataMember]

                    [XmlElement]

                    public DateTime CreationDate { get; set; }

                    [DataMember]

                    [XmlElement]

                    public string Email { get; set; }

                    [DataMember]

                    [XmlAttribute]

                    public bool IsApproved { get; set; }

                    [DataMember]

                    [XmlAttribute]

                    public bool IsLockedOut { get; set; }

                    [DataMember]

                    [XmlElement]

                    public DateTime LastActivityDate { get; set; }

                    [DataMember]

                    [XmlElement]

                    public DateTime LastLockoutDate { get; set; }

                    [DataMember]

                    [XmlElement]

                    public DateTime LastLoginDate { get; set; }

                    [DataMember]

                    [XmlElement]

                    public DateTime LastPasswordChangedDate {
                get; set; }

                    [DataMember]

                    [XmlElement]

                    public string PasswordQuestion { get; set; }

                    [DataMember]

                    [XmlElement]

                    public string PasswordAnswer { get; set; }

                    [DataMember]

                    [XmlElement]

                    public string UserName { get; set; }

                    [DataMember]

                    [XmlElement]

                    public string Password { get; set; }

                    [DataMember]

                    [XmlArray(ElementName=&quot;Roles&quot;),
                XmlArrayItem(ElementName=&quot;Role&quot;)]

                    public List&lt;string&gt; Roles

                    {

                        get;

                        set;

                    }
                    public bool ChangePassword(string
                oldPassword, string newPassword)

                    {

                        if (Password.Equals(oldPassword))

                        {

                            Password = newPassword;

                            return true;

                        }

                        return false;

                    }

                    public bool
                ChangePasswordQuestionAndAnswer(string password,

                                string newPasswordQuestion,
                string newPasswordAnswer)

                    {

                        if (Password.Equals(password))

                        {

                            PasswordQuestion =
                newPasswordQuestion;

                            PasswordAnswer = newPasswordAnswer;

                            return true;

                        }

                        return false;

                    }

                    public string GetPassword(string
                passwordAnswer)

                    {

                        return Password;

                    }

                    public string ResetPassword()

                    {

                        return Password;

                    }

                    public string ResetPassword(string
                passwordAnswer)

                    {

                        return Password;

                    }

                    public bool UnlockUser()

                    {

                        return IsLockedOut = false;

                    }

                }
              </Element>
              <Element Type="Text">
                <p>
                  This class supports two
                  features. It must be transferred via the service and it is part of the data
                  contract. A data contract in WCF defines the structure of complex data. Applying
                  the DataContract attribute to a class makes that class into a
                  data contract. Each serializable member in the data contract class is tagged
                  with the DataMemberAttribute. In our example the same class is used internally to serialize the
                  user objects to the XML file. The XmlElement
                  attributes mark the elements to be serialized.
                </p>

                <p>
                  Each user can be the member of
                  none, one, or many roles. The roles are simple strings stored in another
                  collection. To reference the roles in the user object, a copy of the role’s
                  name is stored. A List&lt;string&gt;
                  object is used internally. However, in XML, the format should be more readable.
                  The XmlArray and XmlArrayItem attributes
                  ensure that the element names are correct. Refer to Listing 7-7 to view the created
                  XML.
                </p>

                <p>
                  Finally, the helper class is
                  shown here to complete the code needed to build the service.
                </p>
              </Element>
              <Element Type="Listing" Name="A helper class that is used to access the data file">
                internal static class FileManager
                {

                    private const string DATAPATH = &quot;App_Data\\UserData.xml&quot;;
                    private static readonly string dataPath;
                    private static object locker = new object();
                    static FileManager()
                    {

                        Uri codeUri = new Uri(typeof(UserData).Assembly.CodeBase);

                        dataPath = Path.Combine(Directory.GetParent(

                                  
                Path.GetDirectoryName(codeUri.LocalPath)).FullName, DATAPATH);

                        // check file permissions

                        FileIOPermission permission = new
                FileIOPermission(

                                         FileIOPermissionAccess.AllAccess,
                dataPath);

                        permission.Demand();

                    }

                    internal static UserData Load()

                    {

                        lock (locker)

                        {

                            XmlSerializer xs = new
                XmlSerializer(typeof(UserData));

                            UserData ud = null;

                            try

                            {

                                using (FileStream fs = new
                FileStream(dataPath, FileMode.Open))

                                {

                                    ud = xs.Deserialize(fs) as
                UserData;

                                }

                            }

                            catch

                            {

                                // save rudimentary format

                                ud = new UserData();

                                Save(ud);

                            }

                            return ud;

                        }

                    }

                    internal static void Save(UserData ud)

                    {

                        lock (locker)

                        {

                            XmlSerializer xs = new
                XmlSerializer(typeof(UserData));

                            using (FileStream fs = new
                FileStream(dataPath, FileMode.Create))

                            {

                                xs.Serialize(fs, ud);

                            }

                        }

                    }

                    internal static string CalculateSHA1(string
                text)

                    {

                        byte[] buffer =
                Encoding.ASCII.GetBytes(text);

                        SHA1CryptoServiceProvider
                cryptoTransformSHA1 =

                                                  new
                SHA1CryptoServiceProvider();

                        string hash = BitConverter.ToString(

                                     
                cryptoTransformSHA1.ComputeHash(buffer));

                        return hash;

                    }

                }
              </Element>
              <Element Type="Text">
                <p>
                  The class is static and
                  provides three methods. With Load, the caller can
                  retrieve the current contents of the stored data. In Save, the data is written back to disk. Both methods block concurrent
                  threads because this is a multi-threaded environment. The thread handling is in
                  neither way optimized but gives you the idea what you should be aware of.
                </p>
                <p>
                  The CalculateSHA1 method creates the SHA1 hash of a given string. It’s used
                  internally to hash the password.
                </p>
                <p>
                  If everything works as intended,
                  the service creates a XML file similar to the one shown in the following code
                  listing.
                </p>
              </Element>
              <Element Type="Listing" Name="The data file filled with some users and roles">
                &lt;?xml version=&quot;1.0&quot;?&gt;

                &lt;UserData
                xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;

                  &lt;Users IsApproved=&quot;false&quot;
                IsLockedOut=&quot;false&quot;&gt;

                    &lt;Comment&gt;Test&lt;/Comment&gt;

                    &lt;CreationDate&gt;2009-04-30T13:12:23.6008895+02:00&lt;/CreationDate&gt;

                    &lt;Email&gt;krause@comzept.de&lt;/Email&gt;

                   
                &lt;LastActivityDate&gt;0001-01-01T01:00:00+01:00&lt;/LastActivityDate&gt;

                   
                &lt;LastLockoutDate&gt;0001-01-01T01:00:00+01:00&lt;/LastLockoutDate&gt;

                   
                &lt;LastLoginDate&gt;0001-01-01T01:00:00+01:00&lt;/LastLoginDate&gt;

                   
                &lt;LastPasswordChangedDate&gt;0001-01-01T01:00:00+01:00&lt;/LastPasswordChangedDate&gt;

                    &lt;UserName&gt;JoergKrause&lt;/UserName&gt;

                    &lt;Roles /&gt;

                  &lt;/Users&gt;

                  &lt;Users IsApproved=&quot;true&quot;
                IsLockedOut=&quot;false&quot;&gt;

                    &lt;Comment /&gt;

                    &lt;CreationDate&gt;2009-04-30T19:06:42.3928895+02:00&lt;/CreationDate&gt;

                    &lt;Email&gt;nissan@comzept.de&lt;/Email&gt;

                   
                &lt;LastActivityDate&gt;0001-01-01T00:00:00&lt;/LastActivityDate&gt;

                   
                &lt;LastLockoutDate&gt;0001-01-01T00:00:00&lt;/LastLockoutDate&gt;

                   
                &lt;LastLoginDate&gt;0001-01-01T00:00:00&lt;/LastLoginDate&gt;

                    &lt;LastPasswordChangedDate&gt;0001-01-01T00:00:00&lt;/LastPasswordChangedDate&gt;

                   
                &lt;UserName&gt;BerndAlbrecht&lt;/UserName&gt;

                   
                &lt;Password&gt;56-5E-E9-0F-A9-60-2C-0C-16-49-1A-7A-0F-3F-6C-70-D9-17-A3-2B&lt;/Password&gt;

                    &lt;Roles&gt;

                      &lt;Role&gt;User&lt;/Role&gt;

                      &lt;Role&gt;Contributor&lt;/Role&gt;

                    &lt;/Roles&gt;

                  &lt;/Users&gt;

                  &lt;Users IsApproved=&quot;true&quot;
                IsLockedOut=&quot;false&quot;&gt;

                    &lt;Comment /&gt;

                   
                &lt;CreationDate&gt;2009-04-30T19:39:44.1528895+02:00&lt;/CreationDate&gt;

                    &lt;Email&gt;joerg@krause.net&lt;/Email&gt;

                   
                &lt;LastActivityDate&gt;0001-01-01T00:00:00&lt;/LastActivityDate&gt;

                    &lt;LastLockoutDate&gt;0001-01-01T00:00:00&lt;/LastLockoutDate&gt;

                   
                &lt;LastLoginDate&gt;0001-01-01T00:00:00&lt;/LastLoginDate&gt;

                   
                &lt;LastPasswordChangedDate&gt;0001-01-01T00:00:00&lt;/LastPasswordChangedDate&gt;

                    &lt;UserName&gt;Joerg&lt;/UserName&gt;

                   
                &lt;Password&gt;4E-B8-C5-DE-4C-76-60-80-C5-91-C6-94-D5-47-5D-B8-E3-53-B0-F3&lt;/Password&gt;

                    &lt;Roles&gt;

                      &lt;Role&gt;Editor&lt;/Role&gt;

                    &lt;/Roles&gt;

                  &lt;/Users&gt;

                  &lt;Roles&gt;Admin&lt;/Roles&gt;

                  &lt;Roles&gt;User&lt;/Roles&gt;

                  &lt;Roles&gt;Contributor&lt;/Roles&gt;

                  &lt;Roles&gt;Editor&lt;/Roles&gt;

                &lt;/UserData&gt;

              </Element>
              <Element Type="Text">
                <p>
                  The collection of Roles elements at the end contains the list of roles used in the
                  provider. In the Users element, the Roles element contains the assigned roles for that user. The other
                  elements contain the properties. IsApproved
                  and IsLockedOut are stored as attributes because they only contain scalar values.
                  The Password element displays the hash in plain text format.
                </p>
                <p>
                  In this section, we’ve looked at
                  the basic operations of the Membership service and its storage classes. The
                  roles are already in this schema and the User object
                  accepts setting the assigned roles. All available roles are stored in separate Roles items at the end of the file—see the bold elements in Listing 7-7. From
                  where do the roles originate? In the next section, we’ll look at a Role service.
                  It requires less code, as it re-uses portions of the Membership service.
                </p>
              </Element>
            </Element>
            <Element Type="Section" Name = "Creating the Role Service" >
              Creating the Role Service
              <Element Type="Text">
                <p>
                  The role service is much simpler than
                  the Membership service. Instead of dealing with a “Role” object, we’ll simply
                  store roles as strings. The functions of the role service are to assign users
                  to existing roles, create or remove roles, and search for users that are
                  members of specific roles. The data storage is the same as for the Membership
                  service. Refer to the Membership classes to see how both parts operate together.
                </p>
                <p>The role service requires three components:</p>
                <ul>
                  <li>IRoleService interface</li>
                  <li>RoleService service</li>
                  <li>RoleService class</li>
                </ul>
                <p>
                  As before, the interface defines the
                  service contract, while the class implements the service. The service file is
                  the service exposed by WCF as the endpoint, and it refers to the class’s
                  implementation in a code-behind file.
                </p>
              </Element>
              <Element Type="Listing" Name="The contract defined by an interface">
                [ServiceContract]
                public interface IRoleService
                {

                    [OperationContract]

                    void AddUsersToRoles(string[] usernames,
                string[] roleNames);

                    [OperationContract]/p>

                    void CreateRole(string roleName);

                    [OperationContract]

                    bool DeleteRole(string roleName, bool
                throwOnPopulatedRole);

                    [OperationContract]

                    string[] FindUsersInRole(string roleName,
                string usernameToMatch);

                    [OperationContract]

                    string[] GetAllRoles();

                    [OperationContract]

                    string[] GetRolesForUser(string username);

                   

                    [OperationContract]

                    string[] GetUsersInRole(string roleName);

                    [OperationContract]

                    bool IsUserInRole(string username, string
                roleName);

                    [OperationContract]

                    void RemoveUsersFromRoles(string[]
                usernames, string[] roleNames);

                    [OperationContract]

                    bool RoleExists(string roleName);

                }
              </Element>
              <Element Type="Text">
                <p>
                  The service defines a direct mirror of
                  the RoleProvider class. This makes it easier to call the service’s methods from the
                  provider shown later. So far, this is very straightforward.
                </p>
              </Element>
              <Element Type="Listing" Name="The service class">
                &lt;%@ ServiceHost Language=&quot;C#&quot;
                Debug=&quot;true&quot;

                    Service=&quot;Apress.Extensibility.Membership.RoleService&quot;

                    CodeBehind=&quot;RoleService.svc.cs&quot;
                %&gt;
              </Element>
              <Element Type="Text">
                <p>
                  The service class (.svc file) points to the
                  code-behind file containing the implementation.
                </p>
                <Element Type="Listing" Name="The implementation of the service">
                  public class RoleService : IRoleService
                  {

                      public void AddUsersToRoles(string[] usernames, string[] roleNames)

                      {

                          UserData ud = FileManager.Load();

                          var users = (from u in ud.Users

                                       where
                  usernames.Contains(u.UserName)

                                       select u);

                          foreach (User user in users)

                          {

                              user.Roles.RemoveAll(role =&gt;
                  roleNames.Contains(role));

                              user.Roles.AddRange(roleNames);

                          }

                          FileManager.Save(ud);

                      }

                      public void CreateRole(string roleName)

                      {

                          UserData ud = FileManager.Load();

                          ud.Roles.Add(roleName);

                          FileManager.Save(ud);

                      }

                      public bool DeleteRole(string roleName, bool
                  throwOnPopulatedRole)

                      {

                          UserData ud = FileManager.Load();

                          var userInRole = from u in ud.Users

                                           where
                  u.Roles.Contains(roleName)

                                           select u;

                          if (userInRole.Count() &gt; 0 &amp;&amp;
                  throwOnPopulatedRole)

                          {

                              return false;

                          }

                          ud.Roles.Remove(roleName);

                          FileManager.Save(ud);

                          return true;

                      }

                      public string[] FindUsersInRole(string
                  roleName, string usernameToMatch)

                      {

                          UserData ud = FileManager.Load();

                          var userInRole = from u in ud.Users

                                           where
                  u.UserName.Contains(usernameToMatch) &amp;&amp;

                                                 u.Roles.Contains(roleName)

                                           select u.UserName;

                          return
                  userInRole.ToArray&lt;string&gt;();

                      }

                      public string[] GetAllRoles()

                      {

                          UserData ud = FileManager.Load();

                          var roles = from r in ud.Roles select r;

                          return roles.ToArray&lt;string&gt;();

                      }

                      public string[] GetRolesForUser(string
                  username)

                      {

                          UserData ud = FileManager.Load();

                          var roles = (from u in ud.Users

                                       where
                  u.UserName.Equals(username)

                                       select u.Roles).First();

                          return roles.ToArray();

                      }

                      public string[] GetUsersInRole(string
                  roleName)

                      {

                          UserData ud = FileManager.Load();

                          var roles = (from u in ud.Users

                                       where
                  u.Roles.Contains(roleName)

                                       select u.UserName);

                          return roles.ToArray();

                      }

                      public bool IsUserInRole(string username,
                  string roleName)

                      {

                          UserData ud = FileManager.Load();

                          var roles = (from u in ud.Users

                                       where u.UserName.Equals(username)
                  &amp;&amp; u.Roles.Contains(roleName)

                                       select u.UserName);

                          return roles.Count() &gt; 0;

                      }

                      public void RemoveUsersFromRoles(string[]
                  usernames, string[] roleNames)

                      {

                          UserData ud = FileManager.Load();

                          var roles = (from u in ud.Users

                                       where
                  usernames.Contains(u.UserName) &amp;&amp;

                                             roleNames.Intersect(u.Roles).Count()
                  &gt; 0

                                       select u.UserName);

                          FileManager.Save(ud);

                      }

                      public bool RoleExists(string roleName)

                      {

                          UserData ud = FileManager.Load();

                          var roles = (from r in ud.Roles

                                       where r.Equals(roleName)

                                       select r);

                          return roles.Count() &gt; 0;

                      }

                  }
                </Element>
                <Element Type="Text">
                  <p>
                    Again, LINQ is used to access the data
                    store. As the <code>UserData</code> class already covers the roles
                    by providing the Roles element, the
                    whole RoleService class doesn’t require its own data access. The FileManager.Save method is called for methods that persist roles data.
                  </p>
                </Element>
              </Element>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Configuring the Services" >
          Configuring the Services
          <Element Type="Text">
            <p>
              Once the services have been defined,
              they must be configured. WCF has its own definition language which extends the <i>web.config</i>
              file. The definition has three parts, but some settings can be omitted if the
              default values are suitable. WCF is based on the ABC mnemonic, which stands for
              Address, Binding, and Contract. Contract is defined by adding specific
              attributes to a class or interface definition, as shown earlier. The binding
              and address are defined in the configuration. The address defines where a
              client can reach the service. The binding defines the protocol used between
              client and service. A complete description consisting of address and binding is
              also called an endpoint.
            </p>
            <p>A sample XML configuration follows:</p>
          </Element>
          <Element Type="Listing" Name="The configuration of the service">
            &lt;system.serviceModel&gt;

                &lt;services&gt;

                    &lt;service
            behaviorConfiguration=&quot;MembershipServiceBehavior&quot;

                             name=&quot;Apress.Extensibility.Membership.MembershipService&quot;&gt;

                        &lt;endpoint address=&quot;&quot;
            binding=&quot;wsHttpBinding&quot;

                                  contract=&quot;Apress.Extensibility.Membership.IMembershipService&quot;&gt;

                            &lt;identity&gt;

                                &lt;dns
            value=&quot;localhost&quot; /&gt;

                            &lt;/identity&gt;

                        &lt;/endpoint&gt;

                        &lt;endpoint address=&quot;mex&quot;
            binding=&quot;mexHttpBinding&quot;

                                  contract=&quot;IMetadataExchange&quot;
            /&gt;

                        &lt;host&gt;

                            &lt;baseAddresses&gt;

                                &lt;add
            baseAddress=&quot;http://localhost/service&quot; /&gt;

                            &lt;/baseAddresses&gt;

                        &lt;/host&gt;

                    &lt;/service&gt;

                    &lt;service
            behaviorConfiguration=&quot;RoleServiceBehavior&quot;

                             name=&quot;Apress.Extensibility.Membership.RoleService&quot;&gt;

                        &lt;endpoint address=&quot;&quot;
            binding=&quot;wsHttpBinding&quot;

                                  contract=&quot;Apress.Extensibility.Membership.IRoleService&quot;&gt;

                            &lt;identity&gt;

                                &lt;dns
            value=&quot;localhost&quot; /&gt;

                            &lt;/identity&gt;

                        &lt;/endpoint&gt;

                        &lt;endpoint address=&quot;mex&quot;
            binding=&quot;mexHttpBinding&quot;

                                  contract=&quot;IMetadataExchange&quot;
            /&gt;

                    &lt;/service&gt;

                &lt;/services&gt;

                &lt;behaviors&gt;

                    &lt;serviceBehaviors&gt;

                        &lt;behavior
            name=&quot;MembershipServiceBehavior&quot;&gt;

                            &lt;serviceMetadata
            httpGetEnabled=&quot;true&quot; /&gt;

                            &lt;serviceDebug
            includeExceptionDetailInFaults=&quot;true&quot; /&gt;

                        &lt;/behavior&gt;

                        &lt;behavior
            name=&quot;RoleServiceBehavior&quot;&gt;

                            &lt;serviceMetadata
            httpGetEnabled=&quot;true&quot; /&gt;

                            &lt;serviceDebug includeExceptionDetailInFaults=&quot;false&quot;
            /&gt;

                        &lt;/behavior&gt;

                    &lt;/serviceBehaviors&gt;

                &lt;/behaviors&gt;

            &lt;/system.serviceModel&gt;
          </Element>
          <Element Type="Text">
            <p>
              The system.serviceModel section contains all the settings required by our WCF services. Its
              definition consists of two services and two corresponding behaviors. Because we
              require a regular web service, the wsHttpBinding is used. An additional endpoint is defined for meta data exchange, using
              the mexHttpBinding. This allows the client to create a proxy which talks to the
              service. (The client is technically created when you reference the service in
              Visual Studio.) When this occurs, the meta data endpoint is called to retrieve
              the service’s description. This includes all methods, signatures, and data
              objects used by the service, as well as the endpoint configuration.
            </p>
            <p>
              If you use and debug the whole
              solution you might encounter an exception. For security reasons, the details of
              an exception are not transferred to the client, as intruders could try to
              provoke an error by attacking the service. If the internally thrown exception
              exposes details, the hackers will receive information with which they can
              refine their attack. During the development cycle, however, you’ll need as much
              information as possible in order to troubleshoot errors. Set the includeExceptionDetailInFaults attribute to “true” while debugging and change it to “false” before
              publishing the service.
            </p>
            <p>
              Now the service is up and
              running. You can check this by launching the .svc endpoints in the browser.
              Just right click the service and choose <i>View in browser</i>. You should see a
              service description similar to that shown in Figure 7-5.
            </p>
          </Element>
          <Element Type="Image" Name="The service is up and running">
            images\19835f0704.tif
          </Element>
          <Element Type="Text">
            <p>
              Use the same procedure to check the
              RoleService.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Implementing the Provider" >
          Implementing the Provider
          <Element Type="Text">
            <p>The provider requires a few more steps:</p>
            <ul>
              <li>Referencing the services</li>
              <li>Implementing the Membership provider</li>
              <li>Implementing the Role provider</li>
              <li>
                Configuring the Web project so
                that it accepts the providers
              </li>
            </ul>
            <p>
              The reference is easy. Simply choose <i>Add service reference</i>
              from the context menu of your project. Then click on <i>Discover</i> and <i>
                Services
                in Solution
              </i>.
            </p>
          </Element>
          <Element Type="Image" Name="Adding the service references">
            images\19835f0706.tif
          </Element>
          <Element Type="Text">
            <p>
              Open the service in the tree view to the
              left and choose the contract. Give the service a suitable name. In the example,
              I’ve used MembershipService and RoleService respectively.
              Repeat the steps for the other service. You now have two service references in
              your project.
            </p>
          </Element>
          <Element Type="Section" Name = "Provider Specific Configuration" >
            Provider Specific Configuration
            <Element Type="Text">
              <p>
                The provider can be combined with its
                own configuration to support specific settings. Refer to chapter 4  for more information
                about the basic steps of provider implementation. For the sake of brevity, I
                have removed from the example any code not required for basic tasks.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Create the Membership Provider" >
            Create the Membership Provider
            <Element Type="Text">
              <p>The Membership provider implements the MembershipProvider base class. To avoid confusion I named the class WSMembershipProvider, where the WS prefix reminds us that it’s based on a Web service. </p>
            </Element>
            <Element Type="Listing" Name="The WSMembershipProvider">
              public class WSMembershipProvider : MembershipProvider

              {

                  private MembershipServiceClient client;

                  private bool _enablePasswordReset;

                  public override void Initialize(string name,

                         System.Collections.Specialized.NameValueCollection
              config)

                  {

                      if (config == null)

                          throw new
              ArgumentNullException(&quot;config&quot;);

                      if (String.IsNullOrEmpty(name))

                      {

                          name = this.GetType().Name;

                      }

                      if
              (String.IsNullOrEmpty(config[&quot;description&quot;]))

                      {

                         
              config.Remove(&quot;description&quot;);

                          config.Add(&quot;description&quot;,
              &quot;WS Based Membership Provider&quot;);

                      }

                      base.Initialize(name, config);

                      client = new MembershipServiceClient();

                      // optional parameters

                      if (!String.IsNullOrEmpty(config[&quot;EnablePasswordReset&quot;]))

                      {

                          _enablePasswordReset =
              Boolean.Parse(config[&quot;EnablePasswordReset&quot;]);

                         
              config.Remove(&quot;EnablePasswordReset&quot;);

                      }

                      // mandatory parameters

                      ApplicationName =
              config[&quot;ApplicationName&quot;];

                  }

                  public override string ApplicationName

                  {

                      get;

                      set;

                  }

                  public override bool ChangePassword(string
              username, string oldPassword,

                                                       string
              newPassword)

                  {

                      return client.ChangePassword(username,
              oldPassword, newPassword);

                  }

                  public override bool
              ChangePasswordQuestionAndAnswer(string username,

                                                                      
              string password,

                                                                      
              string newPasswordQuestion,

                                                                      
              string newPasswordAnswer)

                  {

                      return
              client.ChangePasswordQuestionAndAnswer(username, password,

                                                                     newPasswordQuestion,


                                                                    
              newPasswordAnswer);

                  }

                  public override MembershipUser
              CreateUser(string username,

                                                            string
              password,

                                                            string
              email,

                                                            string
              passwordQuestion,

                                                            string
              passwordAnswer,

                                                            bool
              isApproved,

                                                            object
              providerUserKey,

                                                            out
              MembershipCreateStatus status)

                  {

                      User user = client.CreateUser(out
              status, username, password, email,

                                                     passwordQuestion,
              passwordAnswer,

                                                     isApproved,
              providerUserKey);

                      if (user == null) return null;

                      MembershipUser mu = new MembershipUser(this.GetType().Name,

                          user.UserName,

                          providerUserKey,

                          user.Email,

                          user.PasswordQuestion,

                          &quot;&quot;,

                          user.IsApproved,

                          user.IsLockedOut,

                          user.CreationDate,

                          user.LastLoginDate,

                          user.LastActivityDate,

                          user.LastPasswordChangedDate,

                          user.LastLockoutDate

                          );

                      return mu;

                  }

                  public override bool DeleteUser(string
              username, bool deleteAllRelatedData)

                  {

                      return client.DeleteUser(username,
              deleteAllRelatedData);

                  }

                  public override bool EnablePasswordReset

                  {

                      get { return _enablePasswordReset; }

                  }

                  public override bool EnablePasswordRetrieval

                  {

                      get { throw new
              NotImplementedException(); }

                  }

                  public override MembershipUserCollection
              FindUsersByEmail(string emailToMatch,

                                               int pageIndex,
              int pageSize, out int totalRecords)

                  {

                      return
              CopyToMembershipCollection(client.FindUsersByEmail(out totalRecords,

                                                         emailToMatch,
              pageIndex, pageSize));

                  }

                  public override MembershipUserCollection
              FindUsersByName(string usernameToMatch,

                                                int pageIndex,
              int pageSize, out int totalRecords)

                  {

                      return
              CopyToMembershipCollection(client.FindUsersByName(out totalRecords,

                                                         usernameToMatch,
              pageIndex, pageSize));

                  }

                  public override MembershipUserCollection
              GetAllUsers(int pageIndex,

                                                           int
              pageSize, out int totalRecords)

                  {

                      return
              CopyToMembershipCollection(client.GetAllUsers(out totalRecords,

                                                                       
               pageIndex, pageSize));

                  }

                  private MembershipUserCollection CopyToMembershipCollection(User[] users)
                  {

                      MembershipUserCollection muc = new
              MembershipUserCollection();

                      foreach (User user in users)

                      {

                          muc.Add(CopyToMembershipUser(user));

                      }

                      return muc;

                  }

                  private MembershipUser
              CopyToMembershipUser(User user)

                  {

                      MembershipUser mu = new
              MembershipUser(this.GetType().Name,

                              user.UserName,

                              &quot;&quot;,

                              user.Email,

                              user.PasswordQuestion,

                              user.Comment,

                              user.IsApproved,

                              user.IsLockedOut,

                              user.CreationDate,

                              user.LastLoginDate,

                              user.LastActivityDate,

                              user.LastPasswordChangedDate,

                              user.LastLockoutDate);

                      return mu;

                  }

                  public override int GetNumberOfUsersOnline()

                  {

                      return client.GetNumberOfUsersOnline();

                  }

                  public override string GetPassword(string
              username, string answer)

                  {

                      return client.GetPassword(username,
              answer);

                  }

                  public override MembershipUser
              GetUser(string username, bool userIsOnline)

                  {

                      return
              CopyToMembershipUser(client.GetUserbyName(username, userIsOnline));

                  }

                  public override MembershipUser
              GetUser(object providerUserKey,

                                                          bool
              userIsOnline)

                  {

                      throw new NotImplementedException();

                  }

                  public override string
              GetUserNameByEmail(string email)

                  {

                      return client.GetUserNameByEmail(email);

                  }

                  public override int
              MaxInvalidPasswordAttempts

                  {

                      get { return 5; }

                  }

                  public override int
              MinRequiredNonAlphanumericCharacters

                  {

                      get { return 1; }

                  }

                  public override int
              MinRequiredPasswordLength

                  {

                      get { return 6; }

                  }

                  public override int PasswordAttemptWindow

                  {

                      get { return 10; }

                  }

                  public override MembershipPasswordFormat
              PasswordFormat

                  {

                      get { return
              MembershipPasswordFormat.Clear; }

                  }

                  public override string
              PasswordStrengthRegularExpression

                  {

                      get { return &quot;&quot;; }

                  }

                  public override bool RequiresQuestionAndAnswer

                  {

                      get { return false; }

                  }

                  public override bool RequiresUniqueEmail

                  {

                      get { return false; }

                  }

                  public override string ResetPassword(string
              username, string answer)

                  {

                      return client.ResetPassword(username,
              answer);

                  }

                  public override bool UnlockUser(string
              userName)

                  {

                      throw new NotImplementedException();

                  }

                  public override void
              UpdateUser(MembershipUser user)

                  {

                      User u = new User();

                      foreach (PropertyInfo pi in
              u.GetType().GetProperties())

                      {

                          PropertyInfo piTarget =
              user.GetType().GetProperty(pi.Name);

                          if (piTarget != null)

                          {

                              pi.SetValue(u,
              piTarget.GetValue(user, null), null);

                          }

                      }

                      client.UpdateUser(u);

                  }

                  public override bool ValidateUser(string
              username, string password)

                  {

                      return client.ValidateUser(username,
              password);

                  }

              }
            </Element>
            <Element Type="Text">
              <p>
                The client is instantiated in the Initialize method. The provider’s methods subsequently use the client to call
                the appropriate functions remotely. The only issue requiring more work is the
                fact that the <code>MembershipUser</code> class cannot be used
                directly by the service. The internally employed User class
                has a similar structure but no dependencies on the underlying provider. In the
                example, I use reflection to iterate over the properties and, where a property
                is both public and available in the target class, copy the value from the MembershipUser class to the User class. This is in
                the UpdateUser method. The provider also has several hard coded settings. In a
                fully fledged application, these would be obtained from <i>web.config</i>.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Create the Role Provider" >
            Create the Role Provider
            <Element Type="Text">
              <p>The Role Provider implements the RoleProvider base class. Again, to avoid confusion, our new class is named WSRoleProvider, where the WS reminds us that it’s based on a Web service.</p>
            </Element>
            <Element Type="Listing" Name="The WSRoleProvider">
              public class WSRoleProvider : RoleProvider

              {

                  private RoleServiceClient client;

                  public override void Initialize(string name,

                         System.Collections.Specialized.NameValueCollection
              config)

                  {

                      if (config == null)

                          throw new
              ArgumentNullException(&quot;config&quot;);

                      if (String.IsNullOrEmpty(name))

                      {

                          name = this.GetType().Name;

                      }

                      if
              (String.IsNullOrEmpty(config[&quot;description&quot;]))

                      {

                         
              config.Remove(&quot;description&quot;);

                          config.Add(&quot;description&quot;,
              &quot;WS Based Membership Provider&quot;);

                      }

                      base.Initialize(name, config);

                      client = new RoleServiceClient();

                      // mandatory parameters

                      ApplicationName =
              config[&quot;ApplicationName&quot;];

                  }

                  public override void
              AddUsersToRoles(string[] usernames, string[] roleNames)

                  {

                      client.AddUsersToRoles(usernames,
              roleNames);

                  }

                  public override string ApplicationName

                  {

                      get;

                      set;

                  }

                  public override void CreateRole(string
              roleName)

                  {

                      client.CreateRole(roleName);

                  }

                  public override bool DeleteRole(string
              roleName, bool throwOnPopulatedRole)

                  {

                      return client.DeleteRole(roleName,
              throwOnPopulatedRole);

                  }

                  public override string[]
              FindUsersInRole(string roleName,

                                                            string
              usernameToMatch)

                  {

                      return client.FindUsersInRole(roleName,
              usernameToMatch);

                  }

                  public override string[] GetAllRoles()

                  {

                      return client.GetAllRoles();

                  }

                  public override string[]
              GetRolesForUser(string username)

                  {/p>

                      return client.GetRolesForUser(username);

                  }

                  public override string[]
              GetUsersInRole(string roleName)

                  {

                      return client.GetUsersInRole(roleName);

                  }

                  public override bool IsUserInRole(string
              username, string roleName)

                  {

                      return client.IsUserInRole(username,
              roleName);

                  }

                  public override void
              RemoveUsersFromRoles(string[] usernames,

                                                            string[]
              roleNames)

                  {

                      client.RemoveUsersFromRoles(usernames,
              roleNames);

                  }

                  public override bool RoleExists(string
              roleName)

                  {

                      return client.RoleExists(roleName);

                  }

              }
            </Element>
            <Element Type="Text">
              <p>
                As you can see in the example code the WSRoleProvider class is simpler than the provider shown before. The methods
                predominantly call the corresponding service methods and do not add additional
                logic. Again, the Initialize method
                contains the instantiation of the RoleServiceClient class.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Configuring the Provider" >
          Configuring the Provider
          <Element Type="Text">
            <p>
              After the provider is implemented, it must
              be configured. As for any other provider, this is achieved within the <i>web.config</i>
              file:
            </p>
          </Element>
          <Element Type="Listing" Name="Configuring the providers">
            Configuring the providers
            &lt;system.web&gt;

            &lt;membership
            defaultProvider=&quot;WSMembershipProvider&quot;&gt;

               &lt;providers&gt;

                  &lt;add
            name=&quot;WSMembershipProvider&quot;

                      
            type=&quot;Apress.Extensibility.Membership.WSMembershipProvider,

                            
            Apress.Extensibility.Membership&quot;

                       EnablePasswordReset=&quot;True&quot;

                   /&gt;

                &lt;/providers&gt;

            &lt;/membership&gt;

            &lt;roleManager
            defaultProvider=&quot;WSRoleProvider&quot; enabled=&quot;true&quot; &gt;

                &lt;providers&gt;

                    &lt;clear/&gt;

                    &lt;add name=&quot;WSRoleProvider&quot;

                        
            type=&quot;Apress.Extensibility.Membership.WSRoleProvider,

                              
            Apress.Extensibility.Membership&quot; /&gt;

                &lt;/providers&gt;

            &lt;/roleManager&gt;
          </Element>
          <Element Type="Text">
            <p>
              The provider’s add element requires the name, the type and optionally the parameters defined in the configuration. The type is the full class name including the assembly name. In this case, I’ve
              used a regular Visual Studio 2008 project which compiles into a DLL. The name
              and namespace of the DLL are specified here.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Testing the Providers" >
          Testing the Providers
          <Element Type="Text">
            <p>
              You can now use the providers. However,
              you’ll need several additional pages in order to add users or roles, retrieve
              data, check users, assign roles, etc. Fortunately, Visual Studio contains an
              embedded tool which allows you to manage users and roles.
            </p>
            <p>
              This tool is available from the <i>Project</i>
              menu and is called <i>ASP.NET configuration</i>. You can add and change users,
              add and assign roles, and test all common settings of the new providers without
              writing a single line of code. On the start page, choose the Security tab to view
              the current state of the providers. If you have already defined some users and
              roles, their quantities are displayed:
            </p>
          </Element>
          <Element Type="Image" Name="The security tabs uses the custom provider if properly configured">
            images\19835f0707.tif
          </Element>
          <Element Type="Text">
            <p>
              You can use the tool to create or modify
              users and add or assign roles. If the tool does not work as expected, check
              whether or not the custom providers are properly registered. Open the Provider
              tab and click on <i>Select a different provider for each feature (advanced)</i>.
              Your custom providers (WSMembershipProvider and WSRoleProvider) should be
              selected, as shown in the next figure:
            </p>
          </Element>
          <Element Type="Image" Name="The security tabs use the custom provider
if properly configured">
            images\19835f0708.tif
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Extending Profile Providers" >
        Extending Profile Providers
        <Element Type="Text">
          <p>
            The Profile service is an integrated
            module for storing and retrieving user settings. Settings are not limited to
            ASP.NET but are widely used in distributed multi-user environments; even for
            Win Forms application exist a similar concept. The Profile service employs a
            Profile provider to read data from, and save data to, a storage device. By
            default, the data store is a SQL Server or SQL Server Express instance, and the
            provider class is System.Web.Profile.SqlProfileProvider. This provider is also responsible for allowing users to update
            their settings. Common management functions, such as deleting a Profile after a
            period of inactivity, are located here as well.
          </p>
        </Element>
        <Element Type="SideBar" SidebarType="Note">
          <header>Note</header>
          <aside>
            Profile providers are part
            of the provider model. It is described in detail in chapter 4.
          </aside>
        </Element>
        <Element Type="Section" Name = "The Profile Service" >
          The Profile Service
          <Element Type="Text">
            <p>
              The purpose of the Profile service is to
              store and retrieve user settings. With these settings, users can personalize
              their web pages. Typical information stored here includes:
            </p>
            <ul>
              <li>
                User information, such as city
                and phone number
              </li>
              <li>
                Preferences for accessibility,
                colors, and font size
              </li>
              <li>
                Data related to the current session,
                such as the contents of a shopping basket
              </li>
              <li>
                Individual selections of
                services, such as news feeds or newsletter topics
              </li>
            </ul>
            <p>
              The personalization
              possibilities are limitless. Instead of building custom database modules from
              scratch to store the users’ settings, this is where the Profile service excels.
            </p>
            <p>
              The services’ definition
              consists of two parts—Profile properties and related user. The Profile service
              retrieves properties for the current user from the underlying provider. In
              order to use Profiles, you must first activate this feature by define the
              Provider in the <i>web.config</i> file. By default, the SqlProfileProvider
              stores properties in the local SQL
              Server database. The properties are defined in the <i>web.config</i> file, too.
              Unlike application settings, where key/value pairs are stored in <i>web.config</i>,
              the Profile property definition consists of the property definition only.
              Actual values are stored in the Profile provider’s data store.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Understanding the Profile Provider" >
          Understanding the Profile Provider
          <Element Type="Text">
            <p>
              Before you consider extending the
              Profile provider, let’s look at the features that the provider supports. The ProfileProvider class implements the ProviderBase
              base class and the System.Configuration.SettingsProvider. As the namespace implies, the concepts are not limited to ASP.NET.
              The Profile provider extends the settings concept with some features that allow
              for the management of user Profiles, such as deleting of Profiles and activity
              monitoring.
            </p>
          </Element>
          <Element Type="Table" Name="Methods defined by the ProfileProvider class">
            <table>
              <tr>
                <th>Method</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>Initialize</code>
                </td>
                <td>
                  Derived from ProviderBase. Contains the code for setting up the provider and reading the settings.
                </td>
              </tr>
              <tr>
                <td>
                  <code>ApplicationName</code>
                </td>
                <td>
                  Derived from SettingsProvider. Name of the current application. The data store can use this to
                  handle multiple applications that use the same database.
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetPropertyValues</code>
                </td>
                <td>
                  Derived from
                  SettingsProvider. Retrieves a list of properties using a SettingsContext object containing information about the user. You could use this to
                  retrieve Profile information for a user. The context provides information about
                  authenticated or anonymous users. The method returns an object of type SettingsPropertyCollection., which is a collection of SettingsProperty objects, each containing the name and type of a property, as well
                  as additional information such as default settings and read-only state. Using
                  this method updates the LastActivityDate value
                  that is used to track activity (and thus monitor logged on or inactive users).
                </td>
              </tr>
              <tr>
                <td>
                  <code>SetPropertyValues</code>
                </td>
                <td>
                  Derived
                  from SettingsProvider. Uses a SettingsContext object and
                  a SettingsPropertyValueCollection object to write property values back to the data store. Using this
                  method also updates the LastActivityDate.
                </td>
              </tr>
              <tr>
                <td>
                  <code>DeleteProfiles</code>
                </td>
                <td>
                  Using an array of
                  usernames, this method deletes the related Profiles. An overloaded version of
                  the same method accepts ProfileInfo objects.
                </td>
              </tr>
              <tr>
                <td>
                  <code>DeleteInactiveProfiles</code>
                </td>
                <td>
                  Accepts a ProfileAuthenticationOption value and a DateTime object in
                  order to delete inactive Profiles. The Profiles should be deleted if the
                  supplied date and time value is equal to or less than the Profile’s LastActivityDate.
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetAllProfiles</code>
                </td>
                <td>
                  Retrieves all
                  available Profile objects using a ProfileAuthenticationOption value and an integer value for the page and the maximum number of
                  Profiles. The page index allows a paged retrieval. The method returns a ProfileInfoCollection with ProfileInfo objects.
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetAllInactiveProfiles</code>
                </td>
                <td>
                  Using the
                  same conditions as GetAllProfiles, this
                  method returns only Profiles that have not been used for a given time.
                </td>
              </tr>
              <tr>
                <td>
                  <code>FindProfilesByUserName</code>
                </td>
                <td>
                  Retrieves Profiles
                  via their usernames. In derived classes, this method might accept wildcards,
                  regular expressions, or any other kind of search pattern in order to retrieve
                  multiple values matching the search string. This method behaves similarly to GetAllProfiles.
                </td>
              </tr>
              <tr>
                <td>
                  <code>FindInactiveProfilesByUserName</code>
                </td>
                <td>
                  Retrieves
                  inactive Profiles via their usernames. In derived classes, this method might
                  accept wildcards, regular expressions, or any other kind of search pattern in
                  order to retrieve multiple values matching the search string. This method
                  behaves similarly to GetAllProfiles.
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetNumberOfInactiveProfiles</code>
                </td>
                <td>
                  Retrieves the number of inactive Profiles.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              When implementing a custom
              Profile provider, it must support as a minimum the above methods in order to be
              used transparently in applications.
            </p>
            <p>
              The Profile data always has a
              specific scope, which is usually the current user’s username. However, the
              Profile provider also supports anonymous users. This means that a user not
              currently logged in gets a Profile as a non-authenticated user.
            </p>
            <p>
              Consider a visitor who selects
              several items to purchase at a website, but they have not yet logged in. Their
              Profile contains several items in their shopping basket. It is therefore
              important to keep their Profile (containing their selections) separate from the
              Profiles of other non-authenticated users. To accomplish this, the Profile provider
              assigns each anonymous user an ID that is used as a key, in the absence of a
              username.
            </p>
            <p>
              When the user leaves the
              session, the Profile becomes obsolete. This is why the last activity date is
              important. If you specify  a minimum inactivity time period, the provider is
              able to delete expired Profiles. The ProfileAuthenticationOption parameter determines which of anonymous or authenticated Profiles
              are to be deleted. You can use a different time span for each type.
            </p>
            <p>
              The data store itself is data
              agnostic—any properties can be stored there. The definition of acceptable
              values is set in the <i>web.config</i> file for all users.
            </p>
          </Element>
          <Element Type="Section" Name = "Serializing and Deserializing" >
            Serializing and Deserializing
            <Element Type="Text">
              <p>
                Values for custom settings can support
                several data types. Most storage systems require serialized values instead of
                .NET objects. Fortunately, the base class provides the code for serializing and
                deserializing objects. However, when retrieving values, this code is not called
                automatically. Consider the case where you have several settings, and
                deserializing them takes some time. If the calling party requires only one or
                two of these values, deserializing all of them will waste resources. To improve
                performance, you can call the base methods to deserialize the desired properties
                and ignore all the others. This method is known as “lazy deserialization”.
              </p>
            </Element>
            <Element Type="Listing" Name="Typical strategy for retrieving and deserializing values">
              SettingsPropertyValueCollection settings = new SettingsPropertyValueCollection ();

              foreach (SettingsProperty property in
              properties)

              {

                SettingsPropertyValue pp = new
              SettingsPropertyValue (property);

                object val = GetPropertyValueFromDataSource
              (property.Name);

                if (val == null) 

                {

                  pp.PropertyValue = null;

                  pp.Deserialized = true;

                  pp.IsDirty = false;

                }

                else

                {

                  pp.PropertyValue = Deserialize(val);

                  pp.Deserialized = true;

                  pp.IsDirty = false;

                }

                settings.Add (pp);

              }

              return settings;
            </Element>
          </Element>
          <Element Type="Section" Name = "Defining Profile settings" >
            Defining Profile settings
            <Element Type="Text">
              <p>
                A typical setting definition looks
                like:
              </p>
            </Element>
            <Element Type="Listing" Name="Define available properties">
              &lt;profile&gt;
                &lt;properties&gt;
                  &lt;add name=&quot;Greeting&quot;
              type=&quot;String&quot; /&gt;
                  &lt;add name=&quot;Count&quot;
              type=&quot;Int32&quot; defaultValue=&quot;0&quot; /&gt;
                &lt;/properties&gt;
              &lt;/profile&gt;
            </Element>
            <Element Type="Text">
              <p>
                The name of the property and the type
                are required. A default value can also be specified, which the provider will
                use if the data store does not retrieve one.
              </p>
              <p>
                The serialization can be refined by adding
                the serializeAs attribute to the Profile property definition shown in the next
                section. This attribute allows the pre-selection of a predefined serializer:
              </p>
              <ul>
                <li>String</li>
                <li>Binary</li>
                <li>Xml</li>
                <li>ProviderSpecific</li>
              </ul>
              <p>
                The provider can also be
                selected on a per-property basis. This allows for different data stores for
                different types of data.
              </p>
              <p>
                Each property can be limited
                to authenticated users only by setting the attribute allowAnonymous to <code>false</code>.
              </p>
              <p>
                For more complex scenarios, you
                can group settings with the &lt;group&gt; tag. If
                you plan on supporting hundreds of settings, groups can help you to manage your
                settings.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Using the Profile Data" >
            Using the Profile Data
            <Element Type="Text">
              <p>
                There are two ways of reaching Profile
                data from within your code. In a web application project (as opposed to a web
                site project), the Profile class is not
                auto-generated from the current configuration. You will need to use the following
                two techniques to manage your Profile settings. To retrieve values, use the
                following pattern:
              </p>
              <pre>
                string myValue = (string)
                Context.Profile.GetPropertyValue(&quot;MyValue&quot;);
              </pre>
              <p>
                Setting values is similarly
                straightforward:
              </p>
              <pre>
                if (Context.Profile.UserName != null) {
                Context.Profile.SetPropertyValue(&quot;MyValue&quot;, &quot;something&quot;);
                  Context.Profile.Save();
                }
              </pre>
              <p>
                In a web site project, Visual Studio
                generates a <code>Profile</code> class from the configuration
                settings, which exposes the Profile properties as typed properties:
              </p>
              <pre>
                string myValue = Profile.MyValue;"
              </pre>
              <p>
                Several free tools are available for
                overcoming the limitation of Web site projects that doesn’t support Profile
                creation. The Web Profile Builder found at <i>http://code.msdn.microsoft.com/WebProfileBuilder</i>
                is a good starting point. However, digging deeper into the build techniques
                used in Visual Studio is beyond the scope of this book.
              </p>
            </Element>
            <Element Type="SideBar" SidebarType="Note">
              <header>Note</header>
              <aside>
                To overcome the
                limitations of web application projects, in this chapter I use the web site
                project template—This is the opposite of what I recommend in other parts of the
                book. As long as you’re not using Profiles, you should stay with web
                application projects. If you do use Profiles, it depends on whether strongly
                typed access is important.
              </aside>
            </Element>
            <Element Type="Section" Name = "Configuring Custom Profile Providers" >
              Configuring Custom Profile Providers
              <Element Type="Text">
                <p>
                  The Profile settings use the embedded
                  provider if no other is specified. The settings follow the schema for providers
                  explained in chapter 4. The following code listing shows how to define settings
                  for the example shown below, and how to configure the provider.
                </p>
              </Element>
              <Element Type="Listing" Name="Define available properties">
                &lt;profile
                defaultProvider=&quot;MyProfileProvider&quot;&gt;

                   &lt;properties&gt;

                       &lt;add name=&quot;FirstName&quot;
                type=&quot;System.String&quot; /&gt;

                       &lt;add name=&quot;LastName&quot;
                type=&quot;System.String&quot; /&gt;

                       &lt;add name=&quot;EmailAddress&quot;
                type=&quot;System.String&quot; /&gt;

                       &lt;add name=&quot;MakeNamePublic&quot;
                type=&quot;System.Boolean&quot; /&gt;

                       &lt;add name=&quot;NewsFeed&quot;
                type=&quot;System.String&quot; /&gt;

                   &lt;/properties&gt;

                   &lt;providers&gt;

                       &lt;add
                name=&quot;MyProfileProvider&quot;

                           type=&quot;Apress.Extensibility.XmlProfileProvider&quot;
                /&gt;

                   &lt;/providers&gt;

                &lt;/profile&gt;
              </Element>
              <Element Type="Text">
                <p>
                  To implement the custom Profile
                  provider, select the preferred data access method. 
                </p>
              </Element>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Implementing a Custom Profile Provider" >
        Implementing a Custom Profile Provider
        <Element Type="Text">
          <p>
            The custom Profile provider shown in
            the following example uses an XML file to store all users’ data. It does not
            implement usage functions such as checking inactivity or deleting Profiles.
            However, it does implement the save and load functions as well as the
            underlying serialization and deserialization methods.
          </p>
          <p>
            A Profile provider requires several
            steps to run properly. Even if only one provider class is necessary for
            retrieving the code, you need several users and authentication capabilities in
            order to check the provider.
          </p>
        </Element>
        <Element Type="Section" Name = "Preparation Steps" >
          Preparation Steps
          <Element Type="Text">
            <p>
              To test a custom provider, which
              requires the ability to login and logout of different user accounts, I set up
              Forms Authentication in <i>web.config</i>. Furthermore, I defined the users’
              credentials directly in <i>web.config </i>and force the Membership provider to use data from that file instead of from the default SQL
              Server. This is accomplished by handling the authentication event manually. The
              <i>web.config</i> section defining the users looks like this:
            </p>
          </Element>
          <Element Type="Listing" Name="Define several users to test the application">
            &lt;authorization&gt;

               &lt;deny users=&quot;?&quot;/&gt;                                           

            &lt;/authorization&gt;

            &lt;authentication mode=&quot;Forms&quot;&gt;

               &lt;forms&gt;

                  &lt;credentials
            passwordFormat=&quot;Clear&quot;&gt;

                     &lt;user name=&quot;User1&quot;
            password=&quot;User1&quot;/&gt;

                     &lt;user name=&quot;User2&quot;
            password=&quot;User2&quot;/&gt;

                     &lt;user name=&quot;User3&quot;
            password=&quot;User3&quot;/&gt;

                  &lt;/credentials&gt;                                                

               &lt;/forms&gt;

            &lt;/authentication&gt;
          </Element>
          <Element Type="SideBar" SidebarType="Warning">
            <header>Warning</header>
            <aside>
              : Storing user credentials in
              clear text format in web.config is not intended to run in a production
              environment. It is here only in order to rapidly set up a test environment.
            </aside>
          </Element>
          <Element Type="Text">
            <p>
              Next, the application requires at least
              one page for changing and using Profile settings, plus a login page. The login
              page consists of a single Login control and an
              event handler.
            </p>
          </Element>
          <Element Type="Listing" Name="The “core” component of the login page">
            &lt;body&gt;
                &lt;form id=&quot;form1&quot;
            runat=&quot;server&quot;&gt;

                &lt;div&gt;

                    &lt;asp:Login ID=&quot;Login1&quot;
            runat=&quot;server&quot; onauthenticate=&quot;Login1_Authenticate&quot;&gt;

                    &lt;/asp:Login&gt;

                    &lt;br /&gt;

                    Not yet registered? Create new account
            &lt;asp:HyperLink ID=&quot;HyperLink1&quot;

                    runat=&quot;server&quot;
            NavigateUrl=&quot;~/CreateUser.aspx&quot;&gt;here&lt;/asp:HyperLink&gt;.

                &lt;/div&gt;

                &lt;/form&gt;

            &lt;/body&gt;

            &lt;/html&gt;
          </Element>
          <Element Type="Listing" Name="An event handler forces the login control to use the configured user names">
            public partial class Login : System.Web.UI.Page
            {

                protected void Page_Load(object sender,
            EventArgs e)

                {

                }

                protected void Login1_Authenticate(object
            sender, AuthenticateEventArgs e)

                {

                    e.Authenticated =
            FormsAuthentication.Authenticate(Login1.UserName,

                                                                       
            Login1.Password);

                }

            }
          </Element>
          <Element Type="Text">
            <p>
              The next page is also for testing
              purposes. It contains a simple form to save new Profile settings, display
              current settings, and change accounts.
            </p>
          </Element>
          <Element Type="Listing" Name="ASPX page used to test the Profile provider">
            &lt;body&gt;

                &lt;form id=&quot;form1&quot;
            runat=&quot;server&quot;&gt;

                &lt;br /&gt;Set your Profile data,

                    &lt;asp:LoginName
            ID=&quot;LoginName1&quot; runat=&quot;server&quot; /&gt;

                    :&lt;br /&gt;

                &lt;br /&gt;E-Mail:

                    &lt;asp:TextBox runat=&quot;server&quot;
            ID=&quot;txtEmail&quot;&gt;&lt;/asp:TextBox&gt;

                &lt;br /&gt;Fore Color:

                    &lt;asp:DropDownList
            ID=&quot;drpForeColor&quot; runat=&quot;server&quot;&gt;

                       
            &lt;asp:ListItem&gt;Red&lt;/asp:ListItem&gt;

                       
            &lt;asp:ListItem&gt;Green&lt;/asp:ListItem&gt;

                        &lt;asp:ListItem&gt;Blue&lt;/asp:ListItem&gt;

                       
            &lt;asp:ListItem&gt;&lt;/asp:ListItem&gt;

                &lt;/asp:DropDownList&gt;

                &lt;br /&gt;Back Color:&lt;asp:DropDownList
            ID=&quot;drpBackColor&quot; runat=&quot;server&quot;&gt;

                   
            &lt;asp:ListItem&gt;White&lt;/asp:ListItem&gt;

                   
            &lt;asp:ListItem&gt;Beige&lt;/asp:ListItem&gt;

                    &lt;asp:ListItem&gt;Yellow&lt;/asp:ListItem&gt;

                &lt;/asp:DropDownList&gt;

                &lt;br /&gt;

                &lt;br /&gt;

                &lt;asp:Button ID=&quot;btnSend&quot;
            runat=&quot;server&quot; onclick=&quot;btnSend_Click&quot;

                        Text=&quot;Set Profile Data&quot;
            /&gt;

                &lt;br /&gt;

                &lt;br /&gt;

                Logout to use anonymous mode, login as different
            user to test different

                settings:

                &lt;asp:LoginStatus
            ID=&quot;LoginStatus1&quot; runat=&quot;server&quot; /&gt;

            &amp;nbsp;(Predefined: &lt;i&gt;User1&lt;/i&gt;,
            &lt;i&gt;User2&lt;/i&gt;, &lt;i&gt;User3&lt;/i&gt;, in each case use the

                name as password, too)&lt;br /&gt;

                &lt;br /&gt;Result of your current settings:&lt;br
            /&gt;

                &lt;div&gt;

                    &lt;asp:Panel
            ID=&quot;PanelSettings&quot; runat=&quot;server&quot;&gt;

                        This panel&amp;#39;s design is read
            from current user&amp;#39;s Profile.

                    &lt;/asp:Panel&gt;

                &lt;/div&gt;

                &lt;/form&gt;

            &lt;/body&gt;
          </Element>
          <Element Type="Text">
            <p>
              The page allows you to set an email
              address and a color. The color type is used here to demonstrate serialization
              of non-scalar values.
            </p>
          </Element>
          <Element Type="Image" Name="A simple form to set and retrieve Profile data">
            images\19835f0709.tif
          </Element>
          <Element Type="Text">
            <p>
              The page shows the currently logged-in
              user and the settings that format a Panel control. The code-behind section
              shows how the Profile provider is invoked.
            </p>
          </Element>
          <Element Type="Listing" Name="Direct calls to the Profile provider and typed access">
            public partial class _Default : System.Web.UI.Page
            {

                protected void Page_Load(object sender, EventArgs e)
                {
                    SetProfileData();
                }

                protected void btnSend_Click(object sender, EventArgs e)
                {
                    Profile.ForeColor = Color.FromName(drpForeColor.SelectedValue);
                    Profile.BackColor = Color.FromName(drpBackColor.SelectedValue);
                    Profile.User.Email = txtEmail.Text;
                    SetProfileData();
                }

                private void SetProfileData()
                {

                    PanelSettings.BackColor = Profile.BackColor;
                    PanelSettings.ForeColor = Profile.ForeColor;
                    Label l = new Label();
                    l.Text = Profile.User.Email;
                    PanelSettings.Controls.Add(l);
                }
            }
          </Element>
          <Element Type="Text">
            <p>
              The Profile
              class shown in the next code listing is auto-generated and derives from the ProfileBase. It provides typed access to properties. The Profile provider
              returns settings of type object and the access
              layer casts these types to the final values.
            </p>
          </Element>
          <Element Type="Listing" Name="An auto-generated Profile class">
            //------------------------------------------------------------------------------

            // &lt;auto-generated&gt;

            //     This code was generated by a tool.

            //     Runtime Version:2.0.50727.3074

            //

            //     Changes to this file may cause incorrect
            behavior and will be lost if

            //     the code is regenerated.

            // &lt;/auto-generated&gt;

            //------------------------------------------------------------------------------

            using System;

            using System.Web;

            using System.Web.Profile;

            public class ProfileGroupUser :
            System.Web.Profile.ProfileGroupBase {

                public virtual string Name {

                    get {

                        return
            ((string)(this.GetPropertyValue(&quot;Name&quot;)));

                    }

                    set {

                       
            this.SetPropertyValue(&quot;Name&quot;, value);

                    }

                }

               

                public virtual string Email {

                    get {

                        return
            ((string)(this.GetPropertyValue(&quot;Email&quot;)));

                    }

                    set {

                       
            this.SetPropertyValue(&quot;Email&quot;, value);

                    }

                }

            }

            public class ProfileCommon :
            System.Web.Profile.ProfileBase {

                public virtual int Size {

                    get {

                        return
            ((int)(this.GetPropertyValue(&quot;Size&quot;)));

                    }

                    set {

                       
            this.SetPropertyValue(&quot;Size&quot;, value);

                    }

                }

                public virtual System.Drawing.Color
            ForeColor {

                    get {

                        return
            ((System.Drawing.Color)(this.GetPropertyValue(&quot;ForeColor&quot;)));

                    }

                    set {

                       
            this.SetPropertyValue(&quot;ForeColor&quot;, value);

                    }

                }

                public virtual System.Drawing.Color
            BackColor {

                    get {

                        return
            ((System.Drawing.Color)(this.GetPropertyValue(&quot;BackColor&quot;)));

                    }

                    set {

                       
            this.SetPropertyValue(&quot;BackColor&quot;, value);

                    }

                }

                public virtual ProfileGroupUser User {

                    get {

                        return ((ProfileGroupUser)(this.GetProfileGroup(&quot;User&quot;)));

                    }

                }

                public virtual ProfileCommon
            GetProfile(string username) {

                    return
            ((ProfileCommon)(ProfileBase.Create(username)));

                }

            }
          </Element>
          <Element Type="Text">
            <p>
              To understand these settings, take a
              look at the <i>web.config</i> file where the properties are defined.
            </p>
          </Element>
          <Element Type="Listing" Name="Definition of Profile properties">
            &lt;profile
            automaticSaveEnabled=&quot;true&quot;
            defaultProvider=&quot;XmlProfileProvider&quot;&gt;

             &lt;properties&gt;

              &lt;group name=&quot;User&quot;&gt;

               &lt;add name=&quot;Name&quot; type=&quot;System.String&quot;
            /&gt;

               &lt;add name=&quot;Email&quot;
            type=&quot;System.String&quot; /&gt;

              &lt;/group&gt;

              &lt;add name=&quot;Size&quot;
            type=&quot;System.Int32&quot;/&gt;

              &lt;add name=&quot;ForeColor&quot;
            type=&quot;System.Drawing.Color&quot;/&gt;

              &lt;add name=&quot;BackColor&quot;
            type=&quot;System.Drawing.Color&quot;/&gt;

             &lt;/properties&gt;

             &lt;providers&gt;

              &lt;clear/&gt;

              &lt;add name=&quot;XmlProfileProvider&quot;

                  
            type=&quot;Apress.Extensibility.ProfileProvider.XmlProfileProvider&quot;/&gt;

             &lt;/providers&gt;

            &lt;/profile&gt;
          </Element>
          <Element Type="Text">
            <p>
              The settings for username and email are
              grouped by the “User” group element. This is merely for organizational purposes,
              and has no direct influence on the behavior of the provider. The &lt;providers&gt; section contains the definition of the provider’s type. The name is
              used to set this provider as the default one.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Implementing the Provider" >
          Implementing the Provider
          <Element Type="Text">
            <p>
              We now have the requisite components.
              The last step is to construct the custom Profile provider itself, shown in the
              next listing. An explanation follows the code.
            </p>
          </Element>
          <Element Type="Listing" Name="A custom Profile provider which can save and retrieve settings">
            using System;
            using System.Collections.Generic;
            using System.ComponentModel;
            using System.Configuration;
            using System.Configuration.Provider;
            using System.IO;
            using System.Linq;
            using System.Security.Permissions;
            using System.Text;
            using System.Web;
            using System.Web.Profile;
            using System.Xml.Linq;
            namespace Apress.Extensibility.ProfileProvider
            {

              [SecurityPermission(SecurityAction.Assert,

              Flags =
            SecurityPermissionFlag.SerializationFormatter)]

              public class XmlProfileProvider :
            System.Web.Profile.ProfileProvider

              {

                private const string DATAPATH =
            &quot;~/App_Data/Profile_Data&quot;;

                public override string ApplicationName

                {

                  get { throw new NotSupportedException(); }

                  set { throw new NotSupportedException(); }

                }

                public override void Initialize(string name,

                    
            System.Collections.Specialized.NameValueCollection config)

                {

                  base.Initialize(name, config);

                  if (config.Count &gt; 0)

                    throw new
            ProviderException(&quot;Unrecognized attribute: &quot; +

                                    config.GetKey(0));

                }

                public override
            System.Configuration.SettingsPropertyValueCollection

                
            GetPropertyValues(System.Configuration.SettingsContext context,

                        
            System.Configuration.SettingsPropertyCollection collection)

                {

                  SettingsPropertyValueCollection settings =

                         new
            SettingsPropertyValueCollection();

                  // Make sure we have an entry for this
            username in the XML data

                  string username =
            context[&quot;UserName&quot;] as string;

                  if (!string.IsNullOrEmpty(username))

                  {

                    // Get the profile values for the
            user

                    Dictionary&lt;string, object&gt;
            usersProperties = GetUserProfile(username);

                    foreach (SettingsProperty property in
            collection)

                    {

                        if (property.PropertyType.IsPrimitive
            ||

                            property.PropertyType ==
            typeof(String))

                          property.SerializeAs =
            SettingsSerializeAs.String;

                        else

                          property.SerializeAs =
            SettingsSerializeAs.Xml;

                      SettingsPropertyValue setting = new
            SettingsPropertyValue(property);

                      if (usersProperties != null)

                      {

                        setting.IsDirty = false;

                        if
            (usersProperties.ContainsKey(property.Name))

                        {

                          setting.SerializedValue =
            usersProperties[property.Name];

                          setting.Deserialized = false;

                        }

                      }

                      settings.Add(setting);    // Add the
            settings value to the collection

                    }

                  }

                  return settings;  // Return the settings
            collection

                }

                protected virtual Dictionary&lt;string,
            object&gt; GetUserProfile(string username)

                {

                  Dictionary&lt;string, object&gt;
            propertyValues = new Dictionary&lt;string, object&gt;();

                  XDocument xProfiles = XDocument.Load(ProfileFilePath);

                 
            var xProf = (from p in xProfiles.Root.Elements()

                               where
            p.Attribute(&quot;UserName&quot;).Value.Equals(username)

                               select p);

                  foreach (XElement xmlProperty in
            xProf.Elements())

                  {

                    SettingsSerializeAs ss =
            (SettingsSerializeAs)

                                            
            Enum.Parse(typeof(SettingsSerializeAs),

                                             xmlProperty.Attribute(&quot;serializedAs&quot;).Value);

                    switch (ss)

                    {

                      case SettingsSerializeAs.Binary:

                        propertyValues.Add(

                          xmlProperty.Name.LocalName,

                          Encoding.ASCII.GetString(

                          
            Convert.FromBase64String((((XCData) xmlProperty.FirstNode).Value))));

                        break;

                      case SettingsSerializeAs.String:

                        propertyValues.Add(

                          xmlProperty.Name.LocalName,

                          xmlProperty.Value);

                        break;

                      case SettingsSerializeAs.Xml:

                        if
            (xmlProperty.Attribute(&quot;typeConverter&quot;) != null)

                        {

                          TypeConverter converter =
            (TypeConverter)         

                                  Activator.CreateInstance(

                                 
            Type.GetType(xmlProperty.Attribute(&quot;typeConverter&quot;).Value));

                          propertyValues.Add(

                            xmlProperty.Name.LocalName,

                           
            converter.ConvertFromString(xmlProperty.Value));

                        }

                        break;

                      case
            SettingsSerializeAs.ProviderSpecific:

                        throw new NotSupportedException();

                    }

                  }

                  return propertyValues;

                }

                public override void SetPropertyValues(

                       System.Configuration.SettingsContext
            context,

                      
            System.Configuration.SettingsPropertyValueCollection collection)

                {

                  string username = context[&quot;UserName&quot;]
            as string;

                  bool userIsAuthenticated =
            (bool)context[&quot;IsAuthenticated&quot;];

                  // If no username is specified, or if no
            properties are to be saved, exit

                  if (string.IsNullOrEmpty(username) ||
            collection.Count == 0)

                    return;

                  if (!ExistsDirtyProperty(collection))

                    return;

                  XDocument xProfiles =
            XDocument.Load(ProfileFilePath);

                 
            // check elements

                  var xProf = (from p in
            xProfiles.Root.Elements()

                               where
            p.Attribute(&quot;UserName&quot;).Value.Equals(username)

                               select p).FirstOrDefault();

                  if (xProf == null)

                  {

                    // Add a default empty profile

                    xProf = new
            XElement(&quot;Profile&quot;, new XAttribute(&quot;UserName&quot;, username));

                    xProfiles.Root.Add(xProf);

                    xProfiles.Save(ProfileFilePath);

                  }

                  // assure empty element as write
            everything back

                  xProf.RemoveNodes();

                  foreach (SettingsPropertyValue setting in
            collection)

                  {

                    // If the user is not authenticated and
            the property does

                    // not allow anonymous access, skip
            serializing it

                    if (!userIsAuthenticated &amp;&amp;

                       
            !(bool)setting.Property.Attributes[&quot;AllowAnonymous&quot;])

                      continue;

                    // Skip the current property if it's not
            dirty and is currently

                    // assigned its default value

                    if (!setting.IsDirty &amp;&amp;
            setting.UsingDefaultValue)

                      continue;

                    // Serialize data based on property's
            SerializeAs type

                    switch (setting.Property.SerializeAs)

                    {

                      case SettingsSerializeAs.String:

                        xProf.Add(new XElement(

                          setting.Name,

                         
            Convert.ToString(setting.SerializedValue),

                          new
            XAttribute(&quot;serializedAs&quot;, setting.Property.SerializeAs)));

                        break;

                      case SettingsSerializeAs.Xml:

                        // instead of XML we ask the default
            converter

                        TypeConverter converter =
            TypeDescriptor.GetConverter(

                                                 
            setting.Property.PropertyType);           

                        string data =
            converter.ConvertToString(setting.PropertyValue);

                        xProf.Add(new XElement(

                          setting.Name,

                          data,

                          new
            XAttribute(&quot;serializedAs&quot;, setting.Property.SerializeAs),

                          new
            XAttribute(&quot;typeConverter&quot;,
            converter.GetType().AssemblyQualifiedName)));

                        break;

                      case SettingsSerializeAs.Binary:

                        // encode the binary data using
            base64 encoding

                        string encodedBinaryData =
            Convert.ToBase64String(setting.SerializedValue as byte[]);

                        xProf.Add(new XElement(

                          setting.Name,

                          new XCData(encodedBinaryData),

                          new
            XAttribute(&quot;serializedAs&quot;, setting.Property.SerializeAs)));

                        break;

                      default:

                        // unknown serialize type!

                        throw new
            ProviderException(string.Format(&quot;Invalid value for SerializeAs; expected
            String, Xml, or Binary, received {0}&quot;,
            System.Enum.GetName(setting.Property.SerializeAs.GetType(),
            setting.Property.SerializeAs)));

                    }

                  }

                  xProfiles.Save(ProfileFilePath);

                }

                protected virtual string ProfileFilePath

                {

                  get

                  {

                    return
            Path.Combine(HttpContext.Current.Server.MapPath(DATAPATH),

                                       
            &quot;Profiles.xml&quot;);

                  }

                }

                protected virtual bool ExistsDirtyProperty(

                    
            System.Configuration.SettingsPropertyValueCollection collection)

                {

                  foreach (SettingsPropertyValue setting in
            collection)

                    if (setting.IsDirty)

                      return true;

                  // If we reach here, none are dirty

                  return false;

                }

                public override int DeleteInactiveProfiles(

                        ProfileAuthenticationOption
            authenticationOption,

                        DateTime userInactiveSinceDate)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

                public override int DeleteProfiles(string[]
            usernames)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

                public override int
            DeleteProfiles(ProfileInfoCollection profiles)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

                public override ProfileInfoCollection
            FindInactiveProfilesByUserName(

                     ProfileAuthenticationOption
            authenticationOption,

                     string usernameToMatch,

                     DateTime userInactiveSinceDate,

                     int pageIndex, int pageSize, out int
            totalRecords)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

                public override ProfileInfoCollection
            FindProfilesByUserName(

                     ProfileAuthenticationOption
            authenticationOption,

                     string usernameToMatch, int pageIndex,
            int pageSize, out int totalRecords)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

                public override ProfileInfoCollection
            GetAllInactiveProfiles(

                     ProfileAuthenticationOption
            authenticationOption,

                     DateTime userInactiveSinceDate, int
            pageIndex,

                     int pageSize, out int totalRecords)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

                public override ProfileInfoCollection
            GetAllProfiles(

                     ProfileAuthenticationOption
            authenticationOption,

                     int pageIndex, int pageSize, out int
            totalRecords)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

                public override int GetNumberOfInactiveProfiles(

                    ProfileAuthenticationOption
            authenticationOption,

                    DateTime userInactiveSinceDate)

                {

                  throw new Exception(&quot;The method or
            operation is not implemented.&quot;);

                }

              }

            }
          </Element>
          <Element Type="Text">
            <p>
              The class has two principal
              methods, GetPropertyValues and SetPropertyValues, for
              retrieving and saving Profile settings. The GetPropertyValues method is called to obtain data from the Profile class. It then
              calls GetUserProfile to read the specific Profile from the XML file. Within the GetUserProfile method, a LINQ query retrieves the Profile. A loop reads each value
              and deserializes it depending on its settings. Binary data is saved in Base64
              encoded format and protected within the &lt;!CDATA&gt; section. The content node is cast to Xcdata and
              string values are read directly. More complex types are treated as ProviderSpecific, which means that the provider is responsible for finding the right
              serialization. To support typical .NET types like System.Drawing.Color, without writing type specific code, the internal use type
              converter is used. This type converter usually supports the design time
              experience. For instance, to show colors within the PropertyGrid control, a type converter is used. In this example, the type
              converter’s type is saved into the document and retrieved from the typeConverter attribute. In the XML file, the fully qualified name is stored and
              used to create an instance of the converter. The converter provides a ConvertFromString method, which converts from string format to the specified object.
            </p>
            <p>
              The SetPropertyValues method reverses the whole process. Firstly, the same LINQ statement
              is used to retrieve the specific user’s section. If it doesn’t exist, an empty
              section is added. The collection of settings defined in the <i>web.config</i>
              file is used to assemble the current user’s Profile. Each setting’s “type” (as
              defined in the <i>web.</i>config) is used to obtain the associated TypeConverter object, whose ConvertToString method
              serializes the setting’s value. If everything goes correctly, the XML fragment
              is saved in the XML file.
            </p>
          </Element>
          <Element Type="SideBar" SidebarType="Note">
            <header>Note</header>
            <aside>
              This is a simplified
              scenario lacking error handling and multiuser support. It is only intended to
              show the construction of a custom provider and how to change the way the data
              is persisted.
            </aside>
          </Element>
          <Element Type="Text">
            <p>
              The XML written using this code looks very
              simple:
            </p>
          </Element>
          <Element Type="Listing" Name="XML that stores user Profile settings">
            &lt;?xml version=&quot;1.0&quot;
            encoding=&quot;utf-8&quot;?&gt;

            &lt;Profiles&gt;

              &lt;Profile UserName=&quot;User1&quot;&gt;

                &lt;BackColor
            serializedAs=&quot;ProviderSpecific&quot;

                          
            typeConverter=&quot;System.Drawing.ColorConverter, System.Drawing,

                                           Version=2.0.0.0,
            Culture=neutral,

                                          
            PublicKeyToken=b03f5f7f11d50a3a&quot;&gt;Red/BackColor&gt;

                &lt;User.Email serializedAs=&quot;String&quot;&gt;joerg@krause.net&lt;/User.Email&gt;

                &lt;ForeColor
            serializedAs=&quot;ProviderSpecific&quot;

                          
            typeConverter=&quot;System.Drawing.ColorConverter, System.Drawing,

                                           Version=2.0.0.0,
            Culture=neutral,

                                           PublicKeyToken=b03f5f7f11d50a3a&quot;&gt;White&lt;/ForeColor&gt;

              &lt;/Profile&gt;

              &lt;Profile UserName=&quot;User2&quot;&gt;

                &lt;BackColor
            serializedAs=&quot;ProviderSpecific&quot;

                          
            typeConverter=&quot;System.Drawing.ColorConverter, System.Drawing,

                                           Version=2.0.0.0,
            Culture=neutral,

                                          
            PublicKeyToken=b03f5f7f11d50a3a&quot;&gt;Blue&lt;/BackColor&gt;

                &lt;User.Email
            serializedAs=&quot;String&quot;&gt;User3@user.de&lt;/User.Email&gt;

                &lt;ForeColor
            serializedAs=&quot;ProviderSpecific&quot;

                           typeConverter=&quot;System.Drawing.ColorConverter,
            System.Drawing,

                                           Version=2.0.0.0,
            Culture=neutral,

                                          
            PublicKeyToken=b03f5f7f11d50a3a&quot;&gt;Red&lt;/ForeColor&gt;

              &lt;/Profile&gt;

            &lt;/Profiles&gt;
          </Element>
          <Element Type="Text">
            <p>
              Each Profile consists of a &lt;Profile&gt; element. This element has a UserName
              attribute which associates the settings with a particular user. The content
              depends on the property definition, as shown in code listing 7-10. Each element
              has the serializedAs attribute to  indicate the serializer used. In the case of
              “ProviderSpecific” serializers, the typeConverter attribute defines how a value is converted into a string and back.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "A Client Side Driven Profile Provider" >
          A Client Side Driven Profile Provider
          <Element Type="Text">
            <p>
              With AJAX (Asynchronous JavaScript and
              XML), you can also work with the custom Profile technology directly from your
              client-side script. This section is slightly different, as most of the code is
              JavaScript, instead of C#. The code extends the profile usage to the client and
              empowers script developers predominantly.
            </p>
          </Element>
          <Element Type="Section" Name = "Exposing Profile Settings to AJAX using Web.config" >
            Exposing Profile Settings to AJAX using Web.config
            <Element Type="Text">
              <p>
                There’s a minor addition required to
                the <i>web.config</i> file to enable AJAX to manage Profiles (Listing 7-12).
                You need to specify which properties in the Profile can be read from and which
                ones can be changed. The Profiles settings we saw in Listing 7-10 are
                unchanged.
              </p>
            </Element>
            <Element Type="Listing" Name="Web.config settings to configure AJAX access to user Profile properties">
              &lt;system.web.extensions&gt;
              ;&lt;scripting&gt;
              &lt;webServices&gt;
              &lt;profileService enabled=&quot;true&quot;
              ;readAccessProperties=&quot;User.Name,
              User.Email,Size,ForeColor,BackColor&quot;
              writeAccessProperties=&quot;User.Email,ForeColor,BackColor&quot; /&gt;
              &lt;/webServices&gt;
              &lt;/scripting&gt;
              &lt;/system.web.extensions&gt;
            </Element>
            <Element Type="Text">
              <p>
                All you need to do now is write the
                appropriate client code.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Creating the User Interface" >
            Creating the User Interface
            <Element Type="Text">
              <p>
                Because we’ll use pure AJAX to
                communicate with the server, we don’t need server side controls. The form shown
                below uses basic HTML to build the UI. There are a few HTML input controls with
                an ID attribute assigned to each one:
              </p>
            </Element>
            <Element Type="Listing" Name="Client side part of the solution—the HTML form">
              &lt;form runat=&quot;server&quot;&gt;

              &lt;asp:ScriptManager
              ID=&quot;ScriptManager&quot; runat=&quot;server&quot; /&gt;

              &lt;fieldset id=&quot;ContactFieldset&quot;&gt;

                  &lt;label&gt;

                      E-Mail

                      &lt;input type=&quot;text&quot;
              id=&quot;eMail&quot; /&gt;&lt;/label&gt;&lt;br /&gt;

                  &lt;label&gt;

                      User Name

                      &lt;input type=&quot;text&quot;
              id=&quot;userName&quot; disabled=&quot;disabled&quot; /&gt;&lt;/label&gt;

                  &lt;label&gt;

                      &lt;br /&gt;

                      Fore Color:

                      &lt;br /&gt;

                      Red

                      &lt;input type=&quot;radio&quot;
              name=&quot;ForeColor&quot; id=&quot;fc1&quot; value=&quot;Red&quot; /&gt;

                      Blue

                      &lt;input type=&quot;radio&quot;
              name=&quot;ForeColor&quot; id=&quot;fc2&quot; value=&quot;Blue&quot; /&gt;

                      Green

                      &lt;input type=&quot;radio&quot;
              name=&quot;ForeColor&quot; id=&quot;fc3&quot; value=&quot;Green&quot; /&gt;

                  &lt;/label&gt;

                  &lt;br /&gt;

                  &lt;label&gt;

                      Back Color:

                      &lt;br /&gt;

                      White

                      &lt;input type=&quot;radio&quot;
              name=&quot;BackColor&quot; id=&quot;bc1&quot; value=&quot;White&quot; /&gt;

                      Beige

                      &lt;input type=&quot;radio&quot;
              name=&quot;BackColor&quot; id=&quot;bc2&quot; value=&quot;Beige&quot; /&gt;

                      Yellow

                      &lt;input type=&quot;radio&quot;
              name=&quot;BackColor&quot; id=&quot;bc3&quot; value=&quot;Yellow&quot; /&gt;

                  &lt;/label&gt;

                  &lt;br /&gt;

                  &lt;button
              onclick=&quot;SaveProperties();&quot;&gt;

                      Save&lt;/button&gt;

              &lt;/fieldset&gt;

              &lt;hr /&gt;

              &lt;p id=&quot;Status&quot;&gt;

              &lt;/p&gt;

              &lt;/form&gt;
            </Element>
            <Element Type="Text">
              <p>The form above will appear like this:</p>
            </Element>
            <Element Type="Image" Name="The form with simple HTML form controls">
              images\19835f0710.tif
            </Element>
          </Element>
          <Element Type="Section" Name = "The JavaScript to Tie It Together" >
            The JavaScript to Tie It Together
            <Element Type="Text">
              <p>
                The final step is to add the JavaScript
                code which will communicate between the client and the server. Firstly, we’ll
                bring up the Profile for the current user and populate the form when the page
                loads. Then we’ll expose a “Save” button so that the user can update their
                Profile. The final step is to inform the user that their Profile has been
                saved. We'll accomplish this with a status label which will hide itself after 5
                seconds.
              </p>
              <p>
                Breaking this down into steps, we’ll
                firstly load the Profile for the authenticated user by calling the Load method of the Sys.Services.ProfileService object. If this call is successful, we’ll populate the form. If
                there was an error, we’ll alert the user. The callback methods are used to
                check success and error conditions. If successful, the values are read directly
                from the generic JavaScript class, using the same syntax for properties as the
                server.
              </p>
            </Element>
            <Element Type="Listing" Name="JavaScript that stores user Profile settings">
              window.onload = function() {
                  Sys.Services.ProfileService.load(null, onLoadSuccess, onError);
              }

              function onLoadSuccess(obj) {

                  $get(&quot;eMail&quot;).value =
              Sys.Services.ProfileService.properties.User.Email;

                  $get(&quot;userName&quot;).value =
              Sys.Services.ProfileService.properties.User.Name;

                  var fc =
              Sys.Services.ProfileService.properties.ForeColor.Name;

                  $get(&quot;fc1&quot;).checked = (fc ==
              'Red');

                  $get(&quot;fc2&quot;).checked = (fc ==
              'Blue');

                  $get(&quot;fc3&quot;).checked = (fc ==
              'Green');

                  var bc =
              Sys.Services.ProfileService.properties.BackColor.Name;

                  $get(&quot;bc1&quot;).checked = (bc ==
              'White');

                  $get(&quot;bc2&quot;).checked = (bc ==
              'Beige');

                  $get(&quot;cc3&quot;).checked = (bc ==
              'Yellow');

              }

              function onError(error) {

                  $get(&quot;Status&quot;).innerHTML =
              error.get_message();

              }
            </Element>
            <Element Type="Text">
              <p>
                The above code will attempt to
                load the Profile for the current user when the page loads. If this is
                successful, the onLoadSuccess function
                will fire and we can populate the form. If there was an error, the onError function will fire and an error message will be displayed to the
                user.
              </p>
              <p>
                The final step is to build the
                “Save Profile” function. This is similar to the Load method
                that is called above. Assign the new values to the Profile object in JavaScript
                and then call <code>Save</code> on the Sys.Services.ProfileService object. Again, the callback methods are used to check for success
                (and errors).
              </p>
            </Element>
            <Element Type="Listing" Name="Script code that stores user Profile settings">
              function SaveProperties() {

              Sys.Services.ProfileService.properties.User.Email = $get(&quot;eMail&quot;).value;
              Sys.Services.ProfileService.properties.User.Name = $get(&quot;username&quot;).value;

                  var fc = '';

                  fc += ($get(&quot;fc1&quot;).checked) ?
              'Red' : '';

                  fc += ($get(&quot;fc2&quot;).checked) ? 'Blue'
              : '';

                  fc += ($get(&quot;fc3&quot;).checked) ?
              'Green' : '';

                 
              Sys.Services.ProfileService.properties.ForeColor = fc;

                  var bc = '';

                  bc += ($get(&quot;fc1&quot;).checked) ?
              'White' : '';

                  bc += ($get(&quot;fc2&quot;).checked) ?
              'Beige' : '';

                  bc += ($get(&quot;fc3&quot;).checked) ?
              'Yellow' : '';

                 
              Sys.Services.ProfileService.properties.BackColor = bc;

                  Sys.Services.ProfileService.save(null,
              onSaveSuccess, onError);

              }

              function onSaveSuccess() {

                  clearTimeout();

                  // Display the success message to the user.

                  $get(&quot;Status&quot;).innerHTML =
              &quot;Your profile has been saved.&quot;;

                  // Reset the display after 5 seconds have
              passed.

                  setTimeout(function() {
              $get(&quot;Status&quot;).innerHTML = &quot;&quot;; }, 5000);

              }
            </Element>
            <Element Type="Text">
              <p>
                If all goes well, you should see a
                message when you click the “Save” button:
              </p>
            </Element>
            <Element Type="Image" Name="The form response when the Profile access was successful">
              images\19835f0711.tif
            </Element>
            <Element Type="Text">
              <p>
                This is a very simple example which
                demonstrates how to access the Profile using the AJAX library. Its power comes
                from the library and its close relation to basic ASP.NET features. If you’re
                not confident using the ASP.NET AJAX libraries because of their size or
                performance, keep in mind that they support larger parts of ASP.NET out of the
                box. This is very useful for smaller projects, as well as for constructing
                complex features quickly. However, in large projects with heavy access you
                might consider different ways, like other third party libraries which support
                the specific parts required for Profiles only.
              </p>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Extending Web Parts Personalization Providers" >
        Extending Web Parts Personalization Providers
        <Element Type="Text">
          <p>
            Web Parts are specialized user controls
            that have extensive client support. Web Parts make up portions of a web page,
            and allow users to change the page design. For example, users can move Web
            Parts around, hide or close them, and change their behavior. Web Parts are
            typically used to create portal pages that users can personalize. ASP.NET comes
            with all the pieces needed to construct a completely personalizable page. The
            framework includes components which perform the following tasks:
          </p>
          <ul>
            <li>
              Define and handle customizable
              sections through zones
            </li>
            <li>Pull Web Parts from a catalogue</li>
            <li>
              Export and import Web Parts so that
              users can share them like gadgets
            </li>
            <li>
              Save the user’s preferences to a
              permanent data store
            </li>
          </ul>
          <p>
            By now it should be clear that a
            provider plays a role in this. Web Parts’ settings, locations and properties
            must be stored and retrieved when the user revisits the site. This implies that
            the user must be authenticated. There is an indirect relationship between the
            membership and role providers, and the Web Part personalization provider. There
            is no dependency on the profile provider, as explained in the previous section.
          </p>
        </Element>
        <Element Type="Section" Name = "Understanding the Web Parts Personalization Provider" >
          Understanding the Web Parts Personalization Provider
          <Element Type="Text">
            <p>
              Before you start working with the
              personalization provider and planning a custom implementation, you should
              understand the default provider and how it behaves. The default provider is System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider, and it accesses the same SQL Server database used to support
              membership, roles and profiles internally. The prime job of the personalization
              provider is to store the state of Web Parts, which consists of Web Parts
              content and the layout of Web Parts pages. The state is held in a container of
              type System.Web.UI.WebControls.WebParts.PersonalizationState. The personalization service using the provider serializes the data
              and sends it to the provider as a stream of bytes to store. Conversely, it
              retrieves and deserializes data to restore the state of Web Parts.
            </p>
            <p>
              Because the SqlPersonalizationProvider is a final implementation, there exists an abstract base class for
              such personalization providers—the PersonalizationProvider class.
            </p>
            <pre>
              public abstract class PersonalizationProvider
              : ProviderBase

              {

                  protected PersonalizationProvider();

                  public abstract string ApplicationName {
              get; set; }

                  protected virtual IList
              CreateSupportedUserCapabilities();

                  public virtual PersonalizationScope
              DetermineInitialScope(

                         WebPartManager webPartManager,
              PersonalizationState loadedState);

                  public virtual IDictionary
              DetermineUserCapabilities(

                         WebPartManager webPartManager);

                  public abstract
              PersonalizationStateInfoCollection FindState(

                         PersonalizationScope scope,
              PersonalizationStateQuery query,

                         int pageIndex, int pageSize, out int
              totalRecords);

                  public abstract int
              GetCountOfState(PersonalizationScope scope,

                                                     
              PersonalizationStateQuery query);

                  protected abstract void
              LoadPersonalizationBlobs(WebPartManager webPartManager,

                            string path, string userName,

                            ref byte[] sharedDataBlob, ref
              byte[] userDataBlob);

                  public virtual PersonalizationState
              LoadPersonalizationState(

                                 WebPartManager
              webPartManager, bool ignoreCurrentUser);

                  protected abstract void
              ResetPersonalizationBlob(

                                 WebPartManager
              webPartManager, string path, string userName);

                  public virtual void
              ResetPersonalizationState(WebPartManager webPartManager);

                  public abstract int
              ResetState(PersonalizationScope scope,

                                                  string[]
              paths,

                                                  string[]
              usernames);

                  public abstract int ResetUserState(string
              path, DateTime userInactiveSinceDate);

                  protected abstract void
              SavePersonalizationBlob(WebPartManager webPartManager,

                                          string path, string
              userName, byte[] dataBlob);

                  public virtual void
              SavePersonalizationState(PersonalizationState state);

              }
            </pre>
            <p>
              The following table explains the methods
              and properties. The various abstract and virtual keywords indicate that only a few methods need to be
              implemented—the other methods are optional. As a result, this base class is a
              better starting point for a custom implementation than the ProviderBase base class.
            </p>
          </Element>
          <Element Type="Table" Name="Members of the PersonalizationProvider base class">
            <table>
              <tr>
                <th>
                  Member
                </th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>ApplicationName</code>
                </td>
                <td>
                  Gets or sets
                  the name of the application.
                </td>
              </tr>
              <tr>
                <td>
                  CreateSupportedUserCapabilities
                </td>
                <td>
                  Returns a
                  list of System.Web.UI.WebControls.WebParts.WebPartUserCapability objects that represent the set of known capabilities.
                </td>
              </tr>
              <tr>
                <td>
                  DetermineInitialScope
                </td>
                <td>
                  Determines whether
                  the initial personalization scope should be Shared or User (from PersonalizationScope enum). Takes a WebPartManager object that manages the
                  personalization information and the personalization state information. The
                  method returns a PersonalizationScope enum
                  value.
                </td>
              </tr>
              <tr>
                <td>
                  DetermineUserCapabilities
                </td>
                <td>
                  Returns
                  a dictionary containing WebPartUserCapability instances
                  that represent the personalization-related capabilities of the currently
                  executing user account.
                </td>
              </tr>
              <tr>
                <td>
                  FindState
                </td>
                <td>
                  Returns a collection
                  containing zero or more PersonalizationStateInfo objects based on scope and specific query parameters. Depends on
                  scope, query, and paging information.
                </td>
              </tr>
              <tr>
                <td>
                  GetCountOfState
                </td>
                <td>
                  Returns the
                  number of rows in the underlying data store that exist within the specified
                  scope. Depends on query and scope.
                </td>
              </tr>
              <tr>
                <td>
                  LoadPersonalizationBlobs
                </td>
                <td>
                  Loads
                  raw personalization data from the underlying data store. Takes a reference to
                  the WebPartManager object managing the personalization data, a path as key, the user’s
                  name and the blob data for shared and user part.
                </td>
              </tr>
              <tr>
                <td>
                  LoadPersonalizationState
                </td>
                <td>
                  Loads
                  the raw data from the underlying data store and converts it into a PersonalizationState object.
                </td>
              </tr>
              <tr>
                <td>
                  ResetPersonalizationBlob
                </td>
                <td>
                  Deletes
                  raw personalization data from the underlying data store.
                </td>
              </tr>
              <tr>
                <td>
                  ResetPersonalizationState
                </td>
                <td>
                  Resets
                  personalization data to the underlying data store.
                </td>
              </tr>
              <tr>
                <td>
                  ResetState
                </td>
                <td>
                  Deletes personalization
                  state from the underlying data store based on the specified parameters. Returns
                  the number of rows deleted.
                </td>
              </tr>
              <tr>
                <td>
                  ResetUserState
                </td>
                <td>
                  Deletes Web Parts
                  personalization data from the underlying data store based on the specified
                  parameters.
                </td>
              </tr>
              <tr>
                <td>
                  SavePersonalizationBlob
                </td>
                <td>
                  Saves
                  raw personalization data to the underlying data store.
                </td>
              </tr>
              <tr>
                <td>
                  SavePersonalizationState
                </td>
                <td>
                  Saves
                  personalization data to a data store.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              Implementing this is not
              difficult. The <code>Load</code>, Save, and Reset methods are the core parts of this class.
            </p>
            <p>
              One crucial aspect is the
              scope of the personalization data. Web Parts personalization has two scopes: by
              user and by path. This allows you to personalize the behavior either for each
              individual user or by each page’s path. Scoping by request path is called
              “shared” in the method names used by the provider. In these cases, the user
              name is set to null and all settings apply to all users. The provider must take
              care of such data and store it separately from the users’ storage. 
            </p>

            <p>
              The provider support is optional
              for multiple applications based on the ApplicationName property, but recommended. If you use a local store, such as an XML
              file (as shown in the example below), the application name can be ignored.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Implementing a Custom Personalization Provider" >
          Implementing a Custom Personalization Provider
          <Element Type="Text">
            <p>
              A custom personalization provider has
              several prerequisites:
            </p>
            <ul>
              <li>
                A portal page must exist that
                handles several Web Parts
              </li>
              <li>
                The site must support Authentication
                and user membership
              </li>
              <li>
                The custom Web Part personalization
                provider and its store must exist
              </li>
              <li>
                The <i>web.config</i> file must
                be properly configured to support Web Part personalization
              </li>
            </ul>
            <p>
              The next sections explain the required
              steps one by one.
            </p>
          </Element>
          <Element Type="Section" Name = "Creating a Portal Page" >
            Creating a Portal Page
            <Element Type="Text">
              <p>
                Our Portal page to test the solution is
                a simple Web Part page as shown below.
              </p>
            </Element>
            <Element Type="Listing" Name="The “portal” page to test the solution">
              &lt;form id=&quot;form1&quot;
              runat=&quot;server&quot;&gt;

              &lt;div&gt;

                  &lt;asp:WebPartManager
              ID=&quot;WebPartManager1&quot; runat=&quot;server&quot;&gt;

                      &lt;Personalization
              Enabled=&quot;true&quot; ProviderName=&quot;XmlPersonalizationProvider&quot;
              /&gt;

                  &lt;/asp:WebPartManager&gt;

                  &lt;table style=&quot;width: 100%&quot;&gt;

                      &lt;tr valign=&quot;middle&quot;
              style=&quot;background: #dddddd&quot;&gt;

                          &lt;td colspan=&quot;2&quot;&gt;

                              &lt;h2&gt;

                                  Welcome to our Portal,

                                  &lt;asp:LoginName
              ID=&quot;LoginName1&quot; runat=&quot;server&quot; /&gt;

                              &lt;/h2&gt;                   

                          &lt;/td&gt;

                          &lt;td&gt;

                              &lt;asp:Menu
              ID=&quot;Menu1&quot; runat=&quot;server&quot;

                                        OnMenuItemClick=&quot;Menu1_MenuItemClick&quot;&gt;

                              &lt;/asp:Menu&gt;

                          &lt;/td&gt;

                      &lt;/tr&gt;

                      &lt;tr valign=&quot;top&quot;&gt;

                          &lt;td style=&quot;width:
              20%&quot;&gt;

                              &lt;asp:CatalogZone
              ID=&quot;CatalogZone1&quot; runat=&quot;server&quot;&gt;

                                  &lt;ZoneTemplate&gt;

                                      &lt;asp:PageCatalogPart
              ID=&quot;PageCatalogPart1&quot; runat=&quot;server&quot; /&gt;

                                  &lt;/ZoneTemplate&gt;

                              &lt;/asp:CatalogZone&gt;

                                      &lt;asp:EditorZone
              ID=&quot;EditorZone1&quot; runat=&quot;server&quot;&gt;

                                      &lt;/asp:EditorZone&gt;

                          &lt;/td&gt;

                          &lt;td style=&quot;width:
              60%&quot;&gt;

                              &lt;asp:WebPartZone
              ID=&quot;WebPartZone1&quot; runat=&quot;server&quot;&gt;

                              &lt;/asp:WebPartZone&gt;

                          &lt;/td&gt;

                          &lt;td style=&quot;width:
              20%&quot;&gt;

                              &lt;asp:WebPartZone
              ID=&quot;WebPartZone2&quot; runat=&quot;server&quot;&gt;

                              &lt;TitleBarVerbStyle
              BackColor=&quot;ActiveBorder&quot; /&gt;

                                  &lt;ZoneTemplate&gt;

                                      &lt;asp:Calendar
              ID=&quot;Calendar1&quot; runat=&quot;server&quot;&gt;&lt;/asp:Calendar&gt;

                                      &lt;asp:FileUpload
              ID=&quot;FileUpload1&quot; runat=&quot;server&quot; /&gt;

                                  &lt;/ZoneTemplate&gt;

                              &lt;/asp:WebPartZone&gt;

                          &lt;/td&gt;

                      &lt;/tr&gt;

                      &lt;tr&gt;

                          &lt;td colspan=&quot;3&quot;&gt;

                              &lt;asp:LoginStatus
              ID=&quot;LoginStatus1&quot; runat=&quot;server&quot; /&gt;

                          &lt;/td&gt;

                      &lt;/tr&gt;

                  &lt;/table&gt;

              &lt;/div&gt;

              &lt;/form&gt;
            </Element>
            <Element Type="Text">
              <p>
                The only dependency on other code parts is
                the selection of the current provider:
              </p>
              <pre>
                &lt;Personalization Enabled=&quot;true&quot;
                ProviderName=&quot;XmlPersonalizationProvider&quot; /&gt;
              </pre>
              <p>
                As shown above, the
                personalization must be turned on in order to activate the provider using the Enabled attribute. The name of the provider is defined in <i>web.config</i>.
                (See the section “Configure the Provider” for more details.)
              </p>
              <p>
                To force the page to change the
                settings and invoke the provider, the user must enter the Edit mode of the Web
                Part page. To do this easily, the following code-behind code is used:
              </p>
              <pre>
                public partial class _Default : System.Web.UI.Page

                {

                    protected void Page_Load(object sender,
                EventArgs e)

                    {

                        if (!IsPostBack)

                        {

                            // Create a menu of web part modes

                            MenuItem rootItem = new
                MenuItem(&quot;Select Web Part Mode&quot;);

                            foreach (WebPartDisplayMode mode in
                WebPartManager1.DisplayModes)

                            {

                                rootItem.ChildItems.Add(new
                MenuItem(mode.Name));

                            }

                            Menu1.Items.Add(rootItem);

                        }

                    }

                    protected void Menu1_MenuItemClick(object
                sender, MenuEventArgs e)

                    {

                        WebPartManager1.DisplayMode =
                WebPartManager1.DisplayModes[e.Item.Text];

                    }

                }
              </pre>
              <p>
                The menu is filled with items from the
                collection of acceptable modes. In the MenuItemClick event handler, the same value is used to set the current mode.
              </p>
            </Element>
            <Element Type="Image" Name="The Web Part page">
              images\19835f0712.tif
            </Element>
          </Element>
          <Element Type="Section" Name = "Prepare Authentication" >
            Prepare Authentication
            <Element Type="Text">
              <p>
                For a simple scenario to login and
                logout users, I set up Forms authentication in <i>web.config</i>. Furthermore,
                I store the users’ credentials directly in <i>web.config</i> and configure the Membership provider to use that data instead of data from the default provider
                (SQL Server). This can be accomplished by handling the authentication event
                manually. The <i>web.config</i> section that defines the users looks like this:
              </p>
            </Element>
            <Element Type="Listing" Name="Define some users quickly to test the application">
              &lt;authorization&gt;
                 &lt;deny users=&quot;?&quot;/&gt;                                           
              &lt;/authorization&gt;
              &lt;authentication mode=&quot;Forms&quot;&gt;
                 &lt;forms&gt;
                    &lt;credentials passwordFormat=&quot;Clear&quot;&gt;
                       &lt;user name=&quot;User1&quot; password=&quot;User1&quot;/&gt;
                       &lt;user name=&quot;User2&quot; password=&quot;User2&quot;/&gt;
                       &lt;user name=&quot;User3&quot; password=&quot;User3&quot;/&gt;
                    &lt;/credentials&gt;                                                
                 &lt;/forms&gt;
              &lt;/authentication&gt;
            </Element>
            <Element Type="Text">
              <p>
                The application then requires at least
                one page in order to change and use the profile settings, as well as a login
                page. The login page consists of a single Login
                control and an event handler.
              </p>
            </Element>
            <Element Type="Listing" Name="The login page in its simplest form">
              &lt;body&gt;
                  &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
                  &lt;div&gt;
                      &lt;asp:Login ID=&quot;Login1&quot; runat=&quot;server&quot; onauthenticate=&quot;Login1_Authenticate&quot;&gt;
                      &lt;/asp:Login&gt;
                      &lt;br /&gt;
                  &lt;/div&gt;
                  &lt;/form&gt;
              &lt;/body&gt;
              &lt;/html&gt;
            </Element>
            <Element Type="Listing" Name="An event handler forces the login control to use the configured user names">
              public partial class Login : System.Web.UI.Page

              {

                  protected void Page_Load(object sender,
              EventArgs e)

                  {

                  }

                  protected void Login1_Authenticate(object
              sender, AuthenticateEventArgs e)

                  {

                      e.Authenticated =
              FormsAuthentication.Authenticate(Login1.UserName,

                                                                         
              Login1.Password);

                  }

              }
            </Element>
            <Element Type="Text">
              <p>
                The next page is also for testing
                purposes. It contains a simple form to save new profile settings, show current
                settings, and change accounts.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Create the Provider" >
            Create the Provider
            <Element Type="Text">
              <p>
                The following implementation uses XML
                to store data. It renders the application independent of a SQL Server database.
                The implementation is as simple as possible—only the basic methods for loading
                and saving data are fully implemented.
              </p>
            </Element>
            <Element Type="Listing" Name="A Web Part Personalization Provider using XML">
              using System;
              using System.Collections.Generic;
              using System.Linq;
              using System.Web;
              using System.Web.UI.WebControls.WebParts;
              using System.IO;
              using System.Web.Hosting;
              using System.Data;
              using System.Xml.Linq;
              using System.Xml.XPath;
              namespace Apress.Extensibility.WebPartProvider
              {

                  public class XmlPersonalizationProvider : PersonalizationProvider
                  {

                      private const string SETTINGSNAME =
              &quot;WPSettings.xml&quot;;

                      private const string SETTINGSTAG =
              &quot;WPSettings&quot;;

                      private string configFile;

                      public override void Initialize(string
              name, System.Collections.Specialized.NameValueCollection config)

                      {

                          base.Initialize(name, config);

                          configFile =
              HttpContext.Current.Request.MapPath(Path.Combine(&quot;~/App_Data/&quot;,
              SETTINGSNAME));

                          // XML

                          if (!File.Exists(configFile))

                          {

                              XDocument cfgDoc = new
              XDocument(

                                  new
              XElement(&quot;WebPartData&quot;, new XAttribute(&quot;Created&quot;,
              DateTime.Now.ToShortDateString()),

                                      new
              XElement(&quot;UserScope&quot;),

                                      new XElement(&quot;SharedScope&quot;)));

                              cfgDoc.Declaration = new
              XDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, &quot;true&quot;);

                              cfgDoc.Save(configFile);

                          }

                      }

                      // NOTE: only Shared-scope
              personalization is loaded

                      protected override void
              LoadPersonalizationBlobs(

                        WebPartManager webPartManager,

                        string path,

                        string userName,

                        ref byte[] sharedDataBlob,

                        ref byte[] userDataBlob)

                      {

                          string fullPath =
              HttpContext.Current.Request.MapPath(path);

                         XDocument
              cfgDoc = XDocument.Load(configFile);

                          var root =
              cfgDoc.Element(&quot;WebPartData&quot;);

                          if (userName == null)

                          {

                              object cachedPageSettings =
              HttpContext.Current.Cache[SETTINGSTAG + &quot;:&quot; + path];

                              if (cachedPageSettings != null)

                              {

                                  sharedDataBlob =
              (byte[])cachedPageSettings;

                              }

                              else

                              {

                                  var shared =
              root.Element(&quot;SharedScope&quot;)

                                              
              .Elements(&quot;Page&quot;)

                                               .Single(n =&gt;
              n.Attribute(&quot;name&quot;).Value.Equals(userName));

                                  if (shared == null)

                                  {

                                      sharedDataBlob = null;

                                  }

                                  else

                                  {

                                      sharedDataBlob =
              Convert.FromBase64String(shared.Value);

                                      // cache shared settings

                                     
              webPartManager.Page.Cache.Insert(SETTINGSTAG + &quot;:&quot; + path,
              sharedDataBlob, new System.Web.Caching.CacheDependency(configFile));

                                  }

                              }

                          }

                          else

                          {

                              var pageElement =
              root.XPathSelectElement(

                                 
              String.Format(&quot;//UserScope/User[@name='{0}']/Page[@name='{1}']&quot;,

                                  userName,

                                  path));                   

                              if (pageElement != null)

                              {

                                  userDataBlob =
              Convert.FromBase64String(pageElement.Value);

                              }

                          }

                      }

                      protected override void
              ResetPersonalizationBlob(

                        WebPartManager webPartManager,

                        string path,

                        string userName)

                      {

                      }

                      protected override void
              SavePersonalizationBlob(

                        WebPartManager webPartManager,

                        string path,

                        string userName,

                        byte[] dataBlob)

                      {

                          string fullPath =
              HttpContext.Current.Request.MapPath(path);

                          string sBlob =
              Convert.ToBase64String(dataBlob);

                          lock (this)

                          {

                              XDocument cfgDoc = XDocument.Load(configFile);

                              var root =
              cfgDoc.Element(&quot;WebPartData&quot;);

                              if
              (!String.IsNullOrEmpty(userName))

                              {

                                  // Scope: user

                                  var userElement =
              root.XPathSelectElement(

                                          String.Format(&quot;//UserScope/User[@name='{0}']&quot;,

                                          userName));

                                  if (userElement == null)

                                  {

                                      userElement =
              root.Element(&quot;UserScope&quot;);

                                      // no user, add complete
              tree

                                      userElement.Add(

                                          new
              XElement(&quot;User&quot;, new XAttribute(&quot;name&quot;, userName),

                                              new
              XElement(&quot;Page&quot;, new XAttribute(&quot;name&quot;, path),

                                                  sBlob)));

                                  }

                                  else

                                  {

                                      // with user, check page

                                      var pageElement =
              userElement.Elements(&quot;Page&quot;)

                                                       
              .Single(n =&gt; n.Attribute(&quot;name&quot;).Value.Equals(path));

                                      if (pageElement == null)

                                      {

                                          // no page

                                          userElement.Add(new
              XElement(&quot;Page&quot;,

                                              new
              XAttribute(&quot;name&quot;, path),

                                                  sBlob));

                                      }

                                      else

                                      {

                                          // new data for page

                                          pageElement.Value =
              sBlob;

                                      }

                                  }

                              }

                              else

                              {

                                  // Scope: Shared

                                  var sharedElement =
              root.Elements(&quot;SharedScope&quot;)

                                                     
              .Elements(&quot;Page&quot;)

                                                     
              .Single(p =&gt; p.Attribute(&quot;Name&quot;).Value.Equals(path));

                                  if (sharedElement == null)

                                  {

                                      sharedElement.Add(new
              XElement(&quot;Page&quot;,

                                          new
              XAttribute(&quot;name&quot;, path),

                                          sBlob));

                                  }

                                  else

                                  {

                                      sharedElement.Value =
              sBlob;

                                  }

                              }

                              cfgDoc.Save(configFile);

                          }

                      }

                      public override string ApplicationName

                      {

                          get;

                          set;

                      }

                      public override int GetCountOfState(

                        PersonalizationScope scope,

                        PersonalizationStateQuery query)

                      {

                          return 0;

                      }

                      public override
              PersonalizationStateInfoCollection FindState(

                        PersonalizationScope scope,

                        PersonalizationStateQuery query,

                        int pageIndex,

                        int pageSize,

                        out int totalRecords)

                      {

                          totalRecords = 0;

                          return null;

                      }

                      public override int ResetState(

                        PersonalizationScope scope,

                        string[] paths,

                        string[] usernames)

                      {

                          return 0;

                      }

                      public override int ResetUserState(

                        string path,

                        DateTime userInactiveSinceDate)

                      {

                          return 0;

                      }

                  }

              }
            </Element>
            <Element Type="Text">
              <p>
                During the call to Initialize, a data store in the form of an XML file will be created, if there
                isn’t one already. When the user changes properties of Web Parts, the SavePersonalizationBlob method is called. The approach used is to search for the userName, and if it is null, meaning the user
                is not authenticated, assume that it’s a shared scope setting. Otherwise, it’s
                a personal setting, and the user element is retrieved. We also assume that data
                for this user does not already exist. (This is why XPath expressions are used
                instead of XLinq expression chains.) If the &lt;User&gt;
                element does not exist, it’s created using the current data. The data is passed
                to the provider as a byte array, and stored as a Base64 encoded string in the
                XML element. If the &lt;User&gt; element
                exists, the <code>&lt;Page&gt;</code> element is retrieved. Each
                personalized page has its own XML element. If this element does not exist, it’s
                created and the encoded string is used as its value. If it does exist, the
                current contents are replaced with the Value
                property.
              </p>
              <p>
                A similar technique is used to
                retrieve the data. Every time the page refreshes, the provider is called to
                return the data as a byte array. If there is no data, we can safely return null. While the shared data is stored in a cache, the data for each user
                is retrieved directly from the XML file. There is plenty of scope for improving
                the file handling and caching, but that’s beyond the scope of this chapter. To
                locate the data again, an XPath expression is used. If a value is present, the FromBase64String method converts the string into a byte array.
              </p>
              <p>
                This code produces an XML file
                in the App_Data folder in this manner:
              </p>
              <pre>
                &lt;?xml version=&quot;1.0&quot;
                encoding=&quot;utf-8&quot;?&gt;

                &lt;WebPartData Created=&quot;5/16/2009&quot;&gt;

                  &lt;UserScope&gt;

                    &lt;User name=&quot;User1&quot;&gt;

                      &lt;Page
                name=&quot;~/Default.aspx&quot;&gt;/wEUKwAKAgICARkqMVN5c3RlbS5XZWIuVUkuV2ViQ29udHJvbHMuV2ViUGFydHMuV2ViUGFydE1hbmFnZXIFBV9fd3BtZgIBHhBXZWJQYXJ0U3RhdGVVc2VyFCsACAUMZ3dwQ2FsZW5kYXIxBQxXZWJQYXJ0Wm9uZTJmaAUOZ3dwRmlsZVVwbG9hZDEFDFdlYlBhcnRab25lMWZoaGg=&lt;/Page&gt;

                    &lt;/User&gt;

                    &lt;User name=&quot;User2&quot;&gt;

                      &lt;Page
                name=&quot;~/Default.aspx&quot;&gt;/wEUKwAKAgICARkqMVN5c3RlbS5XZWIuVUkuV2ViQ29udHJvbHMuV2ViUGFydHMuV2ViUGFydE1hbmFnZXIFBV9fd3BtZgIBHhBXZWJQYXJ0U3RhdGVVc2VyFCsACAUMZ3dwQ2FsZW5kYXIxBQxXZWJQYXJ0Wm9uZTFmaAUOZ3dwRmlsZVVwbG9hZDEFDFdlYlBhcnRab25lMmZoaGg=&lt;/Page&gt;

                    &lt;/User&gt;

                  &lt;/UserScope&gt;

                  &lt;SharedScope /&gt;

                &lt;/WebPartData&gt;
              </pre>
              <p>
                Although its format is not impressive,
                this has everything we need in order to store data for any number of users and
                any number of personalized pages. The number of pages is usually low—for a
                customizable portal page it’s one—and the number of active users depends on
                your application. For an intranet with up to several hundred users, the XML
                file storage solution is easy to implement and sufficiently fast.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Configure the Provider" >
            Configure the Provider
            <Element Type="Text">
              <p>
                Having built the provider, it needs to
                be configured for use. I use Forms Authentication in the example and store the
                users’ data in <i>web.config</i>, as shown below. This is not meant to be used
                as production code, but it simplifies development by making user management
                very easy.
              </p>
              <pre>
                &lt;system.web&gt;

                   &lt;webParts&gt;

                     &lt;personalization
                defaultProvider=&quot;XmlPersonalizationProvider&quot;&gt;

                        &lt;providers&gt;

                          &lt;add
                name=&quot;XmlPersonalizationProvider&quot;                        

                      
                type=&quot;Apress.Extensibility.WebPartProvider.XmlPersonalizationProvider&quot;/&gt;

                        &lt;/providers&gt;

                     &lt;/personalization&gt;

                   &lt;/webParts&gt;

                   &lt;authentication mode=&quot;Forms&quot;&gt;

                    &lt;forms&gt;

                     &lt;credentials
                passwordFormat=&quot;Clear&quot;&gt;

                        &lt;user name=&quot;User1&quot;
                password=&quot;user1&quot;/&gt;

                        &lt;user name=&quot;User2&quot;
                password=&quot;user2&quot;/&gt;

                        &lt;user name=&quot;User3&quot;
                password=&quot;user3&quot;/&gt;

                     &lt;/credentials&gt;

                    &lt;/forms&gt;

                   &lt;/authentication&gt;

                   &lt;authorization&gt;

                     &lt;deny users=&quot;?&quot;/&gt;

                   &lt;/authorization&gt;
              </pre>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Testing the Custom Web Part Personalization Provider" >
          Testing the Custom Web Part Personalization Provider
          <Element Type="Text">
            <p>
              You can use the three prepared user
              accounts to test the provider. Simply launch the application and log on using
              one of the above credentials. Switch to “Edit” mode with the menu. Move the web
              parts around and re-arrange the page. The data is saved immediately. Logout and
              log back in as a different user. Create another page layout. Logout again and
              login with the account you used first. The page layout for the first user
              should re-appear. Other than the provider, there is no other custom code
              enabling this feature. The Web Part Personalization infrastructure is already
              available in ASP.NET and Web Parts used here are oblivious to the custom
              provider.
            </p>

            <Element Type="SideBar" SidebarType="Warning">
              <header>Warning</header>
              <aside>
                The sample provider lacks
                error handling and testing, and does not fully implement all the features of
                Web Parts providers. Before using as production code, more development is
                required.
              </aside>
            </Element>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Summary" >
        Summary
        <Element Type="Text">
          <p>
            In this chapter, we looked at security
            and Profile features. The user-driven security model is covered by the
            Membership and Role services, both of which use providers to access a data
            store. Creating customized providers significantly extends the built-in role
            and membership models.
          </p>
          <p>
            Once a user is authenticated,
            you can associate data with his or her Profile. The Profile service uses a
            provider that can be extended—or rewritten using a completely customized version.
            A Profile provider can also be reached by a client using pure AJAX, enabling
            you to save values to and retrieve values from the server without invoking
            server side code.
          </p>
          <p>
            Both extension models provide
            a transparent and simple way of extending and customizing behavior, while
            allowing the existing controls to function as they would with default
            providers.
          </p>
          <p>
            The Web Part Personalization
            Provider is an integrated technique which stores settings of Web Part pages for
            an authenticated user in a custom data store. In this chapter, you learned
            which base class to implement in order to change the default behavior and
            storage medium.
          </p>
          <p>
            I see 2 typos in this graphic: <b>Populate</b> Security Context, and
            <b>Corresponding</b> Action. Also, it be a little clearer if the right hand set
            of 6 boxes were all slightly smaller – then it would be easier to see the
            paths.
          </p>
        </Element>
      </Element>
    </Element>
    <Element Type="Section" Name = "Site Management" >
      Site Management
      <Element Type="Text">
        <p>
          In this chapter, I’ll look at site-specific
          extensibility features such as the site map provider, which is based on the
          extensible provider model that we’ve already learned about. A site map defines the
          navigation structure of a web site. By default, the data store is the <i>web.sitemap</i>
          XML file. Although it’s easy to change the default setting, you’ll need a
          custom site map provider in order to store data anywhere other than in an XML file.
        </p>
        <p>
          The navigation depends usually on
          the web pages on disc. If you wish to hide the internal physical structure of
          your site or to serve pages that do not originate from disk files, the <code>VirtualPathProvider</code> can accomplish this. Using this you can create a virtual site
          structure.
        </p>
        <p>
          In this chapter, you’ll learn
          how to implement and modify the behavior of the <code>SiteMapProvider</code> and <code>VirtualPathProvider</code>.
        </p>
      </Element>
      <Element Type="Section" Name = "Site Map Providers" >
        Site Map Providers
        <Element Type="Text">
          <p>
            ASP.NET features a data driven
            navigation system that uses hierarchical data sources and associated controls. It’s
            much easier to create a site navigational system and track the current position
            of the user if you use the <code>Menu</code> control, <code>TreeView</code> control or <code>SiteMapPath</code> control.
          </p>
          <p>
            As is common in ASP.NET, these controls
            use a provider to obtain data from a specific data source.
          </p>
        </Element>
        <Element Type="Section" Name = "Internal Site Map Provider" >
          Internal Site Map Provider
          <Element Type="Text">
            <p>
              Before you start writing your own
              provider, let’s look at how the internal one is implemented and how it works. The
              <code>XmlSiteMapProvider</code> provider reads an XML file containing the site structure as a
              hierarchy of <code>SiteMapNode</code> elements. The file itself looks like this:
            </p>
            <pre>
              &lt;siteMap&gt;

                &lt;siteMapNode title=&quot;Home&quot;
              description=&quot;Home&quot; url=&quot;~/default.aspx&quot; &gt;

                  &lt;siteMapNode title=&quot;Services&quot;
              description=&quot;Services we offer&quot;

                              
              url=&quot;~/Services.aspx&quot;&gt;

                  &lt;siteMapNode title=&quot;Training&quot;
              description=&quot;Training classes&quot; 

                               url=&quot;~/Training.aspx&quot;
              /&gt;

                  &lt;siteMapNode title=&quot;Consulting&quot;
              description=&quot;Consulting services&quot; 

                               url=&quot;~/Consulting.aspx&quot;
              /&gt;

                  &lt;/siteMapNode&gt;

                &lt;/siteMapNode&gt;

              &lt;/siteMap&gt;
            </pre>
            <p>
              The file is named <i>web.sitemap</i> by
              default. However, you can configure the provider to accept any filename. The
              best way is to use the <code>SiteMapDataSource</code>
              control. A page using these controls could look like this:
            </p>
            <pre>
              &lt;body&gt;

                &lt;form id=&quot;form1&quot;
              runat=&quot;server&quot;&gt;

                &lt;div&gt;

                &lt;h2&gt;Using SiteMapPath&lt;/h2&gt;

                &lt;asp:SiteMapPath
              ID=&quot;SiteMapPath1&quot;
              Runat=&quot;server&quot;&gt;&lt;/asp:SiteMapPath&gt;

                &lt;asp:SiteMapDataSource
              ID=&quot;SiteMapDataSource1&quot; Runat=&quot;server&quot; /&gt;

                &lt;h2&gt;Using TreeView&lt;/h2&gt;

                &lt;asp:TreeView ID=&quot;TreeView1&quot;
              Runat=&quot;Server&quot; DataSourceID=&quot;SiteMapDataSource1&quot;&gt;

                &lt;/asp:TreeView&gt;

                &lt;h2&gt;Using Menu&lt;/h2&gt;

                &lt;asp:Menu ID=&quot;Menu2&quot;
              Runat=&quot;server&quot; DataSourceID=&quot;SiteMapDataSource1&quot;&gt;

                &lt;/asp:Menu&gt;

                &lt;h2&gt;Using a Horizontal Menu&lt;/h2&gt;

                &lt;asp:Menu ID=&quot;Menu1&quot;
              Runat=&quot;server&quot; DataSourceID=&quot;SiteMapDataSource1&quot;

                  Orientation=&quot;Horizontal&quot;

                  StaticDisplayLevels=&quot;2&quot; &gt;

                &lt;/asp:Menu&gt;

                &lt;/div&gt;

                &lt;/form&gt;

              &lt;/body&gt;
            </pre>
            <p>
              This web page already has a complete
              navigation structure. The <code>SiteMapPath</code> control
              indicates your current position in the site structure via a “breadcrumb” style
              display. The <code>TreeView</code> and <code>Menu</code> controls create a tree of all pages. The <code>Menu</code> control provides additionally a JavaScript-driven drop-down menu.
              Both include plenty of features and assistance for creating sophisticated
              menus. As shown in the example, the controls can appear several times to create
              top level, side level, or other kinds of menu. You can even use several <code>SiteMapDataSource</code> controls to define different entry points in the site structure or
              prepare submenus and partial menus.
            </p>
          </Element>
          <Element Type="Sidebar" SidebarType="Tip">
            <header>Tip</header>
            <aside>
              If you have not yet used
              these controls intensively, the following web address is one entry point into
              the documentation: <a href="http://msdn.microsoft.com/en-us/library/ms178423.aspx">http://msdn.microsoft.com/en-us/library/ms178423.aspx</a>.
            </aside>
          </Element>
          <Element Type="Text">
            <p>
              This model has several advantages—as
              well as disadvantages. On the positive side, it’s easy and fast to use, and the
              structure of the content relates directly to the navigation. Navigation is usually
              structured hierarchically, and XML represents this perfectly.
            </p>
            <p>
              There are also some negatives.
              Firstly, the URL is used internally as a key, which means that you cannot use
              the same URL twice to point to a page from different locations in the
              hierarchy. It’s possible to work around this—you could add a dummy querystring
              parameter, or use the UrlMappings defined in the <i>web.config</i>, but this
              isn’t ideal. Furthermore, the default provider reads the definition file once
              the application starts, and holds the whole content in memory. Large structures
              operating on several levels for submenus consume a lot of memory.
            </p>
            <p>
              The internal provider is defined
              in the <i>web.config</i> file like any other:
            </p>

            <Element Type="Listing" Name="">
              <Element Type="Text">
                <![CDATA[
&lt;system.web&gt;

  &lt;siteMap
defaultProvider=&quot;XmlSiteMapProvider&quot; enabled=&quot;true&quot;&gt;

    &lt;providers&gt;

      &lt;add
name=&quot;XmlSiteMapProvider&quot;

        description=&quot;Default SiteMap
provider.&quot;

        type=&quot;System.Web.XmlSiteMapProvider&quot;

        siteMapFile=&quot;Web.sitemap&quot; /&gt;

    &lt;/providers&gt;

  &lt;/siteMap&gt;

&lt;/system.web&gt;
]]>
              </Element>
            </Element>
            <p>
              The
              configuration, the sitemap file, and the appropriate controls are everything
              you need for complete site navigation.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Localization" >
          Localization
          <Element Type="Text">
            <p>
              The embedded sitemap provider supports
              full localization. The resource provider (demonstrated in chapter 4) is aware
              of the encoded resource keys and can obtain the content from a resource file.
              When providing different resource files for languages or cultures, you only
              need one sitemap definition for each different language. It is, however, not
              possible to have different site structures for each culture.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Security Issues" >
          Security Issues
          <Element Type="Text">
            <p>
              The sitemap provider model does support
              a security concept. If you define the roles for each node, the provider will display
              only those nodes the user is permitted to view. Security trimming can be switched
              on and off. Microsoft states that using more than 150 nodes will have a serious
              performance impact. When using the sitemap programmatically, the provider will
              return <code>null</code> if the current user has no access rights, and an exception will
              occur if the user is not permitted to read the root node.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Reasons to Write a Custom Sitemap Provider" >
          Reasons to Write a Custom Sitemap Provider
          <Element Type="Text">
            <p>
              There are several reasons why you might
              consider creating a custom provider:
            </p>
            <ul>
              <li>
                You support localization and need
                a different site structure for each culture
              </li>
              <li>
                You have hundreds of nodes and need
                security trimming
              </li>
              <li>You have limited memory but a large structure</li>
              <li>
                You want to support the same nodes
                several times in the hierarchy
              </li>
              <li>
                You want to allow users to add/remove
                nodes
              </li>
              <li>
                You want to persist the structure
                in an alternative data store
              </li>
            </ul>
            <p>
              There are two ways of customizing the
              provider’s behavior: either extending the default provider, or writing your
              own. Extending the default provider lets you keep the XML file, but allows
              different behavior when retrieving nodes or adding security features. Using
              your own provider gives you the ability to use a different data source.
            </p>
          </Element>
          <Element Type="Sidebar" SidebarType="Tip">
            <header>Tip</header>
            <aside>
              You can use XmlDocument
              or XDocument classes to retrieve and change nodes directly in the <i>web.sitemap</i>
              file in order to edit the site structure on the fly. This does not require a
              new provider, but extends the behavior of the site navigation universe. Consider
              this before writing a lot of code just to get read-write access.
            </aside>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Writing a Custom Sitemap Provider" >
        Writing a Custom Sitemap Provider
        <Element Type="Text">
          <p>
            The purpose of the provider shown here is
            to access another data source. For web farm or web garden scenarios, or
            flexible access to the site structure definition, a SQL Server database is the best
            choice. The amount of data is relatively small, and SQL Server retains it in
            memory, resulting in fast access.
          </p>
        </Element>
        <Element Type="Section" Name = "Prerequisites" >
          Prerequisites
          <Element Type="Text">
            <p>
              A custom provider inherits from a base
              class (as we’ve seen many times). For the sitemap provider, you have a choice
              between the <code>System.Web.StaticSiteMapProvider</code> class and
              its base class, <code>System.Web.SiteMapProvider</code>.  These greatly simplify things, because they come with several
              basic methods already implemented.
            </p>
            <p>
              You can use the <code>StaticSiteMapProvider</code> if:
            </p>
            <ul>
              <li>You read nodes either once or rarely</li>
              <li>
                All information is cached through
                the lifetime of the provider
              </li>
            </ul>
            <p>
              The lifetime of the provider is
              usually the lifetime of the application. Changing the sitemap requires a
              restart.
            </p>
            <p>
              If any one of the following
              conditions is met, the <code>SiteMapProvider</code> type is
              a better choice: 
            </p>
            <ul>
              <li>
                The data is stored in a database
              </li>
              <li>
                The data changes frequently throughout
                the application’s lifetime
              </li>
              <li>
                The user can change the structure
                and personalize the menu
              </li>
            </ul>
          </Element>
        </Element>
        <Element Type="Section" Name = "Learning About the Base Classes" >
          Learning About the Base Classes
          <Element Type="Text">
            <p>
              Before you start implementing, you’ll
              need to know which methods you’ll be dealing with. Firstly, take a look at the <code>SiteMapProvider</code> class:
            </p>
            <pre>
              public abstract class SiteMapProvider :
              ProviderBase

              {

                  protected SiteMapProvider();

                  public virtual SiteMapNode CurrentNode {
              get; }

                  public bool EnableLocalization { get; set; }

                  public virtual SiteMapProvider
              ParentProvider { get; set; }

                  public string ResourceKey { get; set; }

                  public virtual SiteMapNode RootNode { get; }

                  public virtual SiteMapProvider RootProvider
              { get; }

                  public bool SecurityTrimmingEnabled { get; }

                  public event SiteMapResolveEventHandler
              SiteMapResolve;

                  protected virtual void AddNode(SiteMapNode
              node);

                  protected internal virtual void
              AddNode(SiteMapNode node,

                                                          SiteMapNode
              parentNode);

                  public virtual SiteMapNode
              FindSiteMapNode(HttpContext context);

                  public abstract SiteMapNode
              FindSiteMapNode(string rawUrl);

                  public virtual SiteMapNode
              FindSiteMapNodeFromKey(string key);

                  public abstract SiteMapNodeCollection
              GetChildNodes(SiteMapNode node);

                  public virtual SiteMapNode
              GetCurrentNodeAndHintAncestorNodes(int upLevel);

                  public virtual SiteMapNode GetCurrentNodeAndHintNeighborhoodNodes(int
              upLevel,

                                                                                
               int downLevel);

                  public abstract SiteMapNode
              GetParentNode(SiteMapNode node);

                  public virtual SiteMapNode 

                           GetParentNodeRelativeToCurrentNodeAndHintDownFromParent(

                                                                 
              int walkupLevels,

                                                                 
              int relativeDepthFromWalkup);

                  public virtual SiteMapNode
              GetParentNodeRelativeToNodeAndHintDownFromParent(

                              SiteMapNode node, int
              walkupLevels, int relativeDepthFromWalkup);

                  protected internal abstract SiteMapNode
              GetRootNodeCore();

                  protected static SiteMapNode
              GetRootNodeCoreFromProvider(

                              SiteMapProvider provider);

                  public virtual void
              HintAncestorNodes(SiteMapNode node, int upLevel);

                  public virtual void
              HintNeighborhoodNodes(SiteMapNode node, int upLevel,

                                                            int
              downLevel);

                  public override void Initialize(string name,
              NameValueCollection attributes);

                  public virtual bool
              IsAccessibleToUser(HttpContext context, SiteMapNode node);

                  protected internal virtual void
              RemoveNode(SiteMapNode node);

                  protected SiteMapNode ResolveSiteMapNode(HttpContext
              context);

              }
            </pre>
            <p>
              The following tables explain
              the methods, events and properties, as we need to know what to implement and
              the intended behavior. The only unusual thing is the length of some method
              names, but this clarifies their usage.
            </p>
            <p>
              Because the provider is
              transparent, controls such as <code>Menu</code> or <code>TreeView</code> must work with a custom implementation, too. Firstly, the
              properties defined by the provider:
            </p>
          </Element>
          <Element Type="Table" Name="Properties defined in SiteMapProvider">
            <table>
              <tr>
                <th>Property</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>CurrentNode</code>
                </td>
                <td>Reference to the current node (and therefore the related page)</td>
              </tr>
              <tr>
                <td>
                  <code>EnableLocalization</code>
                </td>
                <td>Indicates whether the provider supports localization using resources</td>
              </tr>
              <tr>
                <td>
                  <code>ParentProvider</code>
                </td>
                <td>The parent provider, if the provider supports a hierarchy of providers</td>
              </tr>
              <tr>
                <td>
                  <code>ResourceKey</code>
                </td>
                <td>The root name of the resources used to localize content</td>
              </tr>
              <tr>
                <td>
                  <code>RootNode</code>
                </td>
                <td>The root node</td>
              </tr>
              <tr>
                <td>
                  <code>RootProvider</code>
                </td>
                <td>The root provider, if a hierarchy of providers is used</td>
              </tr>
              <tr>
                <td>
                  <code>SecurityTrimmingEnabled</code>
                </td>
                <td>
                  Indicates whether or not the provider supports security settings. If
                  supported, the provider doesn’t return nodes that don’t match the security
                  level.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              Second, an event that the provider should
              support:
            </p>
          </Element>
          <Element Type="Table" Name="Events defined in SiteMapProvider">
            <table>
              <tr>
                <th>Event</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>SiteMapResolve</code>
                </td>
                <td>Event raised when data requested from data sources is ready</td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              Third, the methods that build most features:
            </p>
          </Element>
          <Element Type="Table" Name="Methods defined in SiteMapProvider">
            <table>
              <tr>
                <th>Method</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>AddNode</code>
                </td>
                <td>
                  Adds either the root
                  node or another node
                </td>
              </tr>
              <tr>
                <td>
                  <code>FindSiteMapNode</code>
                </td>
                <td>Finds a node</td>
              </tr>
              <tr>
                <td>
                  <code>FindSiteMapNodeFromKey</code>
                </td>
                <td>
                  Finds a
                  node using a key
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetChildNodes</code>
                </td>
                <td>
                  Gets all child nodes of
                  the specified node
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetCurrentNodeAndHintAncestorNodes</code>
                </td>
                <td>
                  Gets
                  the current node and pre-loads the ancestors
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetCurrentNodeAndHintNeighborhoodNodes</code>
                </td>
                <td>
                  Gets
                  the current node and pre-loads the neighbors
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetParentNode</code>
                </td>
                <td>
                  Gets the parent node
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetParentNodeRelativeToCurrentNodeAndHintDownFromParent</code>
                </td>
                <td>
                  Gets the current node’s parent node and pre-loads all
                  ancestors for the provided number of levels
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetParentNodeRelativeToNodeAndHintDownFromParent</code>
                </td>
                <td>
                  Gets the given node’s parent and pre-loads all ancestors for
                  the provided number of levels
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetRootNodeCore</code>
                </td>
                <td>
                  Gets the
                  parent regardless of the provider if a hierarchy of providers is used
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetRootNodeCoreFromProvider</code>
                </td>
                <td>
                  Gets the
                  parent of the specified provider if a hierarchy of providers is used
                </td>
              </tr>
              <tr>
                <td>
                  <code>HintNeighborhoodNodes</code>
                </td>
                <td>
                  Pre-loads a
                  number of levels down or up the hierarchy from the given node
                </td>
              </tr>
              <tr>
                <td>Initialize </td>
                <td>
                  Initializes the
                  provider (inherited from base class)
                </td>
              </tr>
              <tr>
                <td>
                  <code>RemoveNode</code>
                </td>
                <td>Removes a node</td>
              </tr>
              <tr>
                <td>
                  <code>ResolveSiteMapNode</code>
                </td>
                <td>
                  Fires the <code>SiteMapResolved</code> event
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              Several methods include “Hint” in their
              name. Use these methods to handle data in huge hierarchies, as they allow you
              to deal with large amounts of data and they avoid holding the whole tree in
              memory. Consider implementations such as SharePoint, which could create deep
              hierarchies of site collections, sites, pages, and subpages that might have
              their own navigation systems. Using the “Hint” methods, you can define the
              depth that is populated from the tree. This limits the data handled by the
              provider to an amount that makes sense for the specific action taken by the
              user. It also assumes that nobody wants to see the whole hierarchy at once.
            </p>
          </Element>
          <Element Type="Section" Name = "Sitemap Nodes in Code" >
            Sitemap Nodes in Code
            <Element Type="Text">
              <p>
                The provider transforms the data from the
                data source into a hierarchy of <code>SiteMapNode</code> objects.
                The base class implements three interfaces, <code>ICloneable</code>, <code>IHierarchyData</code>, and <code>INavigateUIData</code>. This indicates
                the true nature of the object hierarchy, as well as how to deal with the nodes.
              </p>
            </Element>
            <Element Type="Table" Name="Members defined in SiteMapNode">
              <table>
                <tr>
                  <th>Member</th>
                  <th>Description</th>
                </tr>

                <tr>
                  <td>
                    <code>GetAllNodes</code>
                  </td>
                  <td>
                    Gets a read-only list of
                    all nodes beginning from the current node
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetDataSourceView</code>
                  </td>
                  <td>
                    Gets the <code>SiteMapDataSourceView</code> object that represents the underlying data source
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetHierarchicalDataSourceView</code>
                  </td>
                  <td>
                    Gets the <code>SiteMapHierarchicalDataSourceView</code> object that represents the underlying hierarchical data source
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>IsAccessibleToUser</code>
                  </td>
                  <td>
                    Determines whether
                    the node is accessible according to current security context
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>IsDescendantOf</code>
                  </td>
                  <td>
                    Determines whether the
                    current node is a descendant of the given node
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetExplicitResourceString</code>
                  </td>
                  <td>
                    Gets the localized string to retrieve the explicit resource definition
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetImplicitResourceString</code>
                  </td>
                  <td>
                    Gets the localized string to retrieve the implicit resource definition
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetChildren</code>
                  </td>
                  <td>Gets all child nodes</td>
                </tr>
                <tr>
                  <td>
                    <code>GetParent</code>
                  </td>
                  <td>Gets the parent node</td>
                </tr>
                <tr>
                  <td>
                    <code>HasChildren</code>
                  </td>
                  <td>
                    Indicates whether a
                    node has children
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>Item</code>
                  </td>
                  <td>Gets the current node</td>
                </tr>
                <tr>
                  <td>
                    <code>Path</code>
                  </td>
                  <td>
                    Gets the path that describes the
                    node
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>Type</code>
                  </td>
                  <td>Gets the node’s type</td>
                </tr>
                <tr>
                  <td>
                    <code>Description</code>
                  </td>
                  <td>Gets the node’s description</td>
                </tr>
                <tr>
                  <td>
                    <code>Name</code>
                  </td>
                  <td>Gets the node’s name</td>
                </tr>
                <tr>
                  <td>
                    <code>NavigateUrl</code>
                  </td>
                  <td>Gets the node’s URL</td>
                </tr>
                <tr>
                  <td>
                    <code>Value</code>
                  </td>
                  <td>
                    Gets the node’s title
                  </td>
                </tr>
              </table>
            </Element>
          </Element>
          <Element Type="Section" Name = "Implementing Security" >
            Implementing Security
            <Element Type="Text">
              <p>
                The <code>SecurityTrimmingEnabled</code> property indicates if the nodes are limited for the current user.
                It can be set in <i>web.config</i>:
              </p>
              <pre>
                &lt;siteMap defaultProvider=&quot;XmlSiteMapProvider&quot;
                enabled=&quot;true&quot;&gt;

                    &lt;providers&gt;

                      &lt;add
                name=&quot;XmlSiteMapProvider&quot;

                        description=&quot;Default SiteMap
                provider.&quot;

                        type=&quot;System.Web.XmlSiteMapProvider
                &quot;

                        siteMapFile=&quot;Web.sitemap&quot;

                       
                securityTrimmingEnabled=&quot;true&quot; /&gt;

                    &lt;/providers&gt;

                &lt;/siteMap&gt;
              </pre>
            </Element>
            <Element Type="Text">
              <p>
                The default implementation used in <code>XmlSiteMapProvider</code> resolves the <code>roles</code> attributes
                defined in the <code>siteMapNode</code> elements in the <i>web.sitemap</i>
                file. If the current user is in the role, and the <code>RoleProvider</code> is activated, the <code>XmlSiteMapProvider</code>
                limits visibility to the correct nodes. If used programmatically, the <code>IsAccessibleToUser</code> property possessed by each <code>SiteMapNode</code>
                instance indicates the same thing. The list of available roles is also available
                in the <code>Roles</code> property. A query can use either the <code>IList</code> type
                directly or “*” for all. The programmatic access uses a simple fall back
                strategy:
              </p>
              <ul>
                <li>
                  If the role was found or the
                  query consists of “*”, return the node
                </li>
                <li>
                  If the role was not found, attempt to
                  authenticate the URL defined by the node
                </li>
                <li>
                  If Windows authentication is used,
                  attempt to authenticate again using the credentials of the current user and the
                  ACL (access control list) of the target file for the URL
                </li>
              </ul>
              <p>
                If everything fails, the provider does
                not return the node and assumes that the user does not have sufficient authority.
                Note that this is not an inheritance strategy. If a user has the right to read
                a specific node, it does not follow that he or she has the right to read any
                subsequent node. This allows different security settings for each level.
                However, if the right to access a specific node is denied, the strategy stops
                and all child nodes are blocked. This ensures that there are no isolated child
                nodes accessible from any places other than the sitemap hierarchy.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Implementing a SQL Server Based Navigation" >
          Implementing a SQL Server Based Navigation
          <Element Type="Text">
            <p>
              SQL Server 2008 includes a new data
              type, <code>HierarchyId</code>. This can be used to implement a custom database-driven sitemap
              provider.
            </p>
          </Element>
          <Element Type="Section" Name = "Preparing the Database" >
            Preparing the Database
            <Element Type="Text">
              <p>
                First, a database is required. In this example, I use the common <i>aspnetdb.mdf</i> database created for the
                role and membership provider, if default providers are used. Listing 8-1 defines an additional table named <i>aspnet_Navigation</i>:
              </p>
              <Element Type="Listing" Name="The table definition using the HierarchyId data type">
                CREATE TABLE aspnet_Navigation
                (
                   SiteMapNode  hierarchyid         NOT NULL,
                   Title        varchar(100)        NOT NULL,
                   Description  varchar(200)        NULL,
                   Url          varchar(200)        NULL,
                   Roles        varchar(200)        NULL
                )
              </Element>
            </Element>
            <Element Type="Text">
              <p>
                Let’s proceed by filling in some data,
                as shown in the next image:
              </p>
              <Element Type="Image" Name="Table with some test values in Visual Studio Professional">
                images\19835f0800.tif
              </Element>
              <Element Type="Text">
                <p>
                  The <code>HierarchyId</code>
                  column contains the node definition as a path beginning with a slash. The
                  internal format is binary and must be transformed using the <code>ToString</code> method SQL provides for this type. This is what Visual Studio does
                  when presenting the table data in edit mode.
                </p>
              </Element>
            </Element>
            <Element Type="Section" Name = "Creating the Provider" >
              Creating the Provider
              <Element Type="Text">
                <p>
                  Now that we have everything, we can
                  create the custom provider. Listing 8-2 shows the final result. You can create
                  it in the current Web project or in a separate project. Using it in a Web
                  project will change the configuration slightly. The big advantage of building a
                  custom sitemap provider in its own project is to be able to re-use it with
                  other web applications.
                </p>
              </Element>
              <Element Type="Listing" Name="The SqlSiteMapProvider using the HierarchyId data type">
                using System;
                using System.Collections.Generic;
                using System.Collections.Specialized;
                using System.Configuration.Provider;
                using System.Data;
                using System.Data.Common;
                using System.Data.SqlClient;
                using System.Linq;
                using System.Security.Permissions;
                using System.Web;
                using System.Web.Configuration;
                namespace Apress.Extensibility.SqlSiteMap
                {

                    [SqlClientPermission(SecurityAction.Demand, Unrestricted = true)]
                    public class SqlSiteMapProvider : StaticSiteMapProvider
                    {

                        private string _connect;
                        private int _indexNode;
                        private int _indexTitle;
                        private int _indexUrl;
                        private int _indexDesc;
                        private int _indexRoles;
                        private int _indexParent;
                        private int _indexRoot;
                        private SiteMapNode _root;
                        private Dictionary&lt;string, SiteMapNode&gt; _nodes =
                            new Dictionary&lt;string, SiteMapNode&gt;(16);
                        public override void Initialize(string name, NameValueCollection config)
                        {

                            if (config == null)
                                throw new ArgumentNullException(&quot;config&quot;);
                            if (String.IsNullOrEmpty(name))
                                name = &quot;SqlSiteMapProvider&quot;;
                            base.Initialize(name, config);
                            string connect = &quot;siteMap&quot;;
                            if (WebConfigurationManager.ConnectionStrings[connect] == null)
                                throw new ProviderException(&quot;No connection&quot;);
                            _connect = WebConfigurationManager.ConnectionStrings[connect].
                                       ConnectionString;
                            if (String.IsNullOrEmpty(_connect))
                                throw new ProviderException(&quot;no connection string&quot;);
                        }

                        public override SiteMapNode BuildSiteMap()
                        {
                            lock (this)
                            {
                                if (_root != null)
                                    return _root;
                                SqlConnection connection = new SqlConnection(_connect);
                                try
                                {
                                    connection.Open();
                                    SqlCommand command;
                                    command = new SqlCommand(
                                       @&quot;SELECT *, SiteMapNode.ToString() AS SiteMapNodeString,  SiteMapNode.GetAncestor(1).ToString() AS Parent, hierarchyid::GetRoot().ToString() AS Root
                                   FROM aspnet_Navigation&quot;,
                connection);

                                    command.CommandType =
                CommandType.Text;

                                    SqlDataReader reader =
                command.ExecuteReader();

                                    _indexNode =
                reader.GetOrdinal(&quot;SiteMapNodeString&quot;);

                                    _indexUrl =
                reader.GetOrdinal(&quot;Url&quot;);

                                    _indexTitle =
                reader.GetOrdinal(&quot;Title&quot;);

                                    _indexDesc =
                reader.GetOrdinal(&quot;Description&quot;);

                                    _indexRoles =
                reader.GetOrdinal(&quot;Roles&quot;);

                                    _indexParent =
                reader.GetOrdinal(&quot;Parent&quot;);

                                    _indexRoot =
                reader.GetOrdinal(&quot;Root&quot;);

                                    string parentKey;

                                    if (reader.Read())

                                    {

                                        _root =
                CreateSiteMapNode(reader, true, out parentKey);

                                        AddNode(_root, null);

                                        while (reader.Read())

                                        {

                                            SiteMapNode node =
                CreateSiteMapNode(reader, false,

                                                                                
                 out parentKey);

                                            SiteMapNode parent =
                GetParentSiteMapNode(parentKey);

                                            AddNode(node,
                parent);
                                        }
                                    }
                                }
                                finally
                                {
                                    connection.Close();
                                }
                                return _root;
                            }
                        }
                        protected override SiteMapNode GetRootNodeCore()
                        {
                            BuildSiteMap();
                            return _root;
                        }
                        private SiteMapNode CreateSiteMapNode(DbDataReader reader, bool forRoot,
                                                               out string parentKey)
                        {
                            string nodeString = reader.GetString(forRoot ? _indexRoot : _indexNode);
                            string title = reader.IsDBNull(_indexTitle) ? null :
                                          reader.GetString(_indexTitle).Trim();
                            string url = reader.IsDBNull(_indexUrl)
                ? null :
                                          reader.GetString(_indexUrl).Trim();
                            string description = reader.IsDBNull(_indexDesc) ? null :
                                          reader.GetString(_indexDesc).Trim();
                            string roles = reader.IsDBNull(_indexRoles) ? null :
                                           reader.GetString(_indexRoles).Trim();
                            string[] rolelist = null;
                            if (!String.IsNullOrEmpty(roles))
                                rolelist = roles.Split(new char[] { ',', ';' }, 512);
                            SiteMapNode node = new SiteMapNode(this, nodeString,
                url,
                title,
                description,
                rolelist, null, null, null);
                            parentKey = reader.IsDBNull(_indexParent) ? null :
                                        reader.GetString(_indexParent);  
                            _nodes.Add(nodeString, node);
                            return node;
                        }
                         private SiteMapNode GetParentSiteMapNode(string parentKey)
                        {
                            var parent = from n in _nodes
                                         where n.Key.Equals(parentKey)
                                         select n.Value;
                            return
                parent.FirstOrDefault&lt;SiteMapNode&gt;();
                        }
                    }
                }
              </Element>
            </Element>
            <Element Type="Text">
              <p>
                The implementation is intentionally brief.
                The <code>HierarchyId</code> datatype makes it much easier to fetch a hierarchy. The heart is this
                SQL query, which retrieves all the needed data in one query:
              </p>
              <pre>
                SELECT *, SiteMapNode.ToString() AS
                SiteMapNodeString,

                          SiteMapNode.GetAncestor(1).ToString()
                AS Parent,

                          hierarchyid::GetRoot().ToString() AS
                Root

                FROM aspnet_Navigation
              </pre>
              <p>
                A great attribute of SQL Server
                is the ability to provide additional methods for data types. Here I use the <code>GetAncestor</code> and <code>GetRoot</code> methods. <code>GetAncestor(1)</code> fetches the parent element, while <code>GetRoot()</code> obtains
                the hierarchy’s root. Bear in mind that some methods of these T-SQL functions
                are members, such as <code>GetAncestor</code>, while
                other methods are static, like <code>GetRoot</code>. The double
                colon, “::” indicates access to static methods in SQL Server syntax.
              </p>
              <p>
                A <code>DataReader</code> object provides fast forward-only access to the SQL query results,
                from which we assemble <code>SiteMapNode</code> objects.
                The node type is provided so that the same method can be re-used. The value is
                retrieved using <code>reader.GetString(&lt;index&gt;)</code>. The index is the number of the column returned by the SQL query.
                The member fields’ <code>_indexRoot</code>, <code>_indexNode</code> or <code>_indexParent</code> contain the ordinal number for
                the column. In the SQL statement, the result is cast using <code>ToString</code>. This requires the <code>GetString</code> method when returning
                results.
              </p>
              <p>
                The <code>AddNode</code> method from the <code>StaticSiteMapProvider</code>
                base class is responsible for building the hierarchy. To obtain the necessary
                information, provide a parent for each node. In the example, I assume that the
                parent is already defined as a node. This requires the table data to be ordered
                so that parents appear before their children. The <code>GetParentSiteMapNode</code> method is used to retrieve the parent from the private <code>_nodes</code> collection when building the map. This collection exists for that
                purpose and is no longer used when the nodes are retrieved from the sitemap
                controls. The <code>parentKey</code> used here is simply the value returned
                from SQL with the <code>GetAncestor</code> method, as
                mentioned before.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Configuring the Custom Provider" >
            Configuring the Custom Provider
            <Element Type="Text">
              <p>
                The configuration consists of two parts.
                The first step is to define the connection string in order to access the data
                source:
              </p>
              <pre>
                &lt;connectionStrings&gt;
                   &lt;add connectionString=&quot;Data Source=.\SQLEXPRESS;Initial
                                          Catalog=aspnetdb;Integrated Security=True&quot;
                                          name=&quot;siteMap&quot;/&gt;
                &lt;/connectionStrings&gt;
              </pre>
              <p>
                The provider itself needs the basic
                format, as shown before:
              </p>
              <pre>
                &lt;system.web&gt;
                  &lt;siteMap enabled=&quot;true&quot; defaultProvider=&quot;MySqlSiteMapProvider&quot;&gt;
                    &lt;providers&gt;
                      &lt;add name=&quot;MySqlSiteMapProvider&quot;
                            type=&quot;Apress.Extensibility.SqlSiteMap.SqlSiteMapProvider&quot;
                            description=&quot;My SqlSiteMapProvider&quot;          
                securityTrimmingEnabled=&quot;false&quot;        
                connectionStringName=&quot;siteMap&quot;
                        /&gt;
                    &lt;/providers&gt;
                  &lt;/siteMap&gt;
                &lt;/system.web&gt;
              </pre>
              <p>
                Finally, the data source used on the web
                pages needs to point to the provider. If you have several providers, each data
                source can use its own provider.
              </p>
              <pre>
                &lt;asp:SiteMapDataSource ID=&quot;SiteMapDataSource1&quot;
                runat=&quot;server&quot;
                                       SiteMapProvider=&quot;MySqlSiteMapProvider&quot;
                /&gt;
              </pre>
              <p>
                Although there are no changes to the various
                controls using this data source, some features such as security trimming are
                not yet implemented. However, you’ve learned how to extend the default provider
                model regarding site maps, and how to benefit from the new features SQL Server
                2008 provides.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Testing the Provider" >
            Testing the Provider
            <Element Type="Text">
              <p>
                To test the provider, write a simple
                page that contains at least a <code>Menu</code> and a <code>SiteMapPath</code> control bound to the modified <code>SiteMapDataSource</code> control, above. A page such as this one will suffice:
              </p>
              <pre>
                &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
                    &lt;div&gt;
                        &lt;asp:SiteMapPath ID=&quot;SiteMapPath1&quot; runat=&quot;server&quot; SiteMapProvider=&quot;MySqlSiteMapProvider&quot;&gt;
                        &lt;/asp:SiteMapPath&gt;
                        &lt;br /&gt;
                        &lt;br /&gt;
                        Menu:&lt;br /&gt;
                        &lt;asp:Menu ID=&quot;Menu1&quot; runat=&quot;server&quot;
                                  StaticDisplayLevels=&quot;1&quot; DataSourceID=&quot;SiteMapDataSource1&quot; &gt;
                        &lt;/asp:Menu&gt;
                        &lt;br /&gt;
                        &lt;br /&gt;
                    &lt;/div&gt;
                    &lt;asp:SiteMapDataSource ID=&quot;SiteMapDataSource1&quot; runat=&quot;server&quot;
                                           SiteMapProvider=&quot;MySqlSiteMapProvider&quot; /&gt;
                    &lt;/form&gt;
              </pre>
              <p>
                The data source is only required for the
                <code>Menu</code> control. Breadcrumbs are displayed using a <code>SiteMapPath</code> control, which can connect directly to the custom provider using
                its name. The following figure shows the output:
              </p>
            </Element>
            <Element Type="Image" Name="Menu and SiteMapPath controls with data from SQL Server">
              images\19835f0801.tif
            </Element>
            <Element Type="Text">
              <p>
                Remember that you need to add the page
                names to the table data. Otherwise, you’ll encounter page load errors when you
                choose the menu items.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Suggestions for Extending the Example" >
          Suggestions for Extending the Example
          <Element Type="Text">
            <p>
              The example is as simple as possible,
              containing nothing more than the code required to get it working. It lacks
              error checking and proper exception handling. Consider making the following
              changes before using the code in a production environment:
            </p>
            <ul>
              <li>Allow duplicate nodes</li>
              <li>
                Dispose of the dictionary that stores
                the parents
              </li>
              <li>
                Order the SQL query to accept
                unordered node definitions
              </li>
              <li>
                Add a primary key to the table in
                order to improve speed for large node sets
              </li>
            </ul>
            <p>
              There are further ways of extending the
              behavior.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Extending the VirtualPathProvider">
        Extending the VirtualPathProvider
        <Element Type="Text">
          <p>
            Complex sites with hundreds of pages
            are difficult to maintain. For some sections, a file structure with static data
            seems to be more productive, whereas other sections are composed dynamically from
            databases. This difference should be indiscernible to regular users and search
            engines alike. Search engines follow each link on a page and find the navigation
            paths through a site, indexing the content of each page on the way. Users
            bookmark pages and return directly to them later. However, neither of these behaviors
            are what developers are looking for in creating pages.
          </p>
          <p>
            The <code>VirtualPathProvider</code> is designed to separate the internal and external structures. Like
            any other provider, it works transparently, using a pluggable approach. The
            difference is that the virtual path provider does not access a database and
            internally is different from all providers described so far. However, to
            implement a virtual path provider, you’ll have to inherit and implement an
            abstract base class—<code>VirtualPathProvider</code>.
          </p>
        </Element>
        <Element Type="Section" Name = "Using the VirtualPathProvider" >
          Using the VirtualPathProvider
          <Element Type="Text">
            <p>
              In previous chapters, I started with a
              brief overview of the default provider before looking at a custom
              implementation. Here it’s a bit different. There is no default provider, which means
              that each page is handled at its physical location and dynamically-generated
              content appears as is, within the one and only page possessing that
              functionality.
            </p>
            <p>
              Implementing a virtual path provider is
              all about changing the default behavior of the path resolution for any regular
              web site. Some examples of what it can accomplish might help you decide if it’s
              worth the effort:
            </p>
            <ul>
              <li>
                Storing all content in a
                database
              </li>
              <li>
                Intercepting the parsing of pages in scenarios
                where pages come from different sources
              </li>
              <li>
                Customizing the path resolution for
                the root of the application using “~”
              </li>
              <li>Modifying the compilation process</li>
            </ul>
            <p>
              The parsing aspect especially
              is not one that you’ll be using on a daily basis. You might have heard about large
              ASP.NET-based projects such as SharePoint. SharePoint is an application providing
              a content management system, among several other features. Users can create
              content and add active parts—called webparts—to these pages. The content is
              stored in a database and pages are built dynamically. ASP.NET does not support
              this out-of-the-box, as the compiler would not be able to locate any pages to
              compile. A powerful virtual path provider is used to resolve pages found in the
              database, mix them with those still stored as files, and create a final
              structure.
            </p>
            <p>
              While SharePoint is a
              technically admirable example of a virtual path provider, in our example we’ll
              consider a more modest scenario. Given a website with a “MySite” section, let’s
              expose it with a structure like this:
            </p>
            <pre>
              Site  MySiteJoerg
                  Controls
                MySiteJohn
                  Controls
                MySiteKathryn
                  Controls
            </pre>
            <p>
              Users will think that they have a
              private site. They can upload and modify pages there, and you could even allow
              them to store files. However, if users follow convention and use paths such as <i>~/controls/mycontrol.ascx</i>
              to link their web pages to user controls, it will fail. Consider this example:
            </p>
            <pre>
              &lt;%@ Register Src=&quot;~/Controls/my.ascx&quot;
              TagName=&quot;my&quot; TagPrefix=&quot;john&quot; %&gt;
            </pre>
            <p>
              User John is allowed to upload active
              content to his private space under the path <i>MySiteJohn</i>. He assumes—wrongly—that
              this is the root for his private space. John expects it to resolve to <i>/MySiteJohn/Controls/my.ascx</i>.
              It actually resolves to <i>/Site/Controls/my.ascx</i>. Of course, this causes a
              compilation exception.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Register the VirtualPathProvider" >
          Register the VirtualPathProvider
          <Element Type="Text">
            <p>
              In the previous description, I noted that
              the virtual path provider is unlike other providers. In fact, “provider” is probably
              not the best word to describe it, as it’s different from other providers in the
              way it works, the way it accesses the data, and the way it’s configured. To correctly
              resolve paths, even during compilation, the provider must be initialized
              earlier in the ASP.NET framework. Thus, the <i>web.config</i> file is not the correct
              place for defining it. Instead, it has to be defined using a special static
              method, <code>AppInitialize</code>, or in the <i>global.asax</i> file.
            </p>
          </Element>
          <Element Type="Sidebar" SidebarType="Box">
            <header>The Nature of AppInitialize</header>
            <aside>
              <p class="SBBodyFirst">
                You can use any class in either the code
                path of your web site or in the App_Code folder of your web application project
                to define a public, static method called <code>AppInitialize</code>:
              </p>
              <pre>
                public class SomeInitClass

                {   

                    public static void AppInitialize()   

                    {       

                        // Action required to initialize the
                application  

                    }

                }
              </pre>
              <p>
                The method is called during the
                initialization cycle of the application. This is exactly the same as if you’d
                put the code in the Application_Start event handler defined in <i>global.asax</i>.
                There is little information available about why two ways exist to achieve the
                same thing. Perhaps it’s because some applications lack a <i>global.asax</i>
                file, and creating and maintaining one for a single event would be overkill. In
                this case, the <code>AppInitialize</code> method is a better option, as it moves the code portion to one location.
                You can use any class to define this method—even the one we created here to
                define a VirtualPathProvider. This puts the two parts—configuration and
                definition—tightly together.
              </p>
            </aside>
          </Element>
          <Element Type="Text">
            <p>
              With either method of registering
              the provider, the following code is required:
            </p>
            <pre>
              namespace Apress.Extensibility.PathProvider
              {
                public static class AppStart
                {
                  public static void AppInitialize()
                  {
                    CustomPathProvider customProvider = new CustomPathProvider (); 
              HostingEnvironment.RegisterVirtualPathProvider(customProvider);
                  }
                }
              }
            </pre>
            <p>
              This code assumes that the custom
              provider is named <code>CustomPathProvider</code>, as
              shown in the example below. The code also uses other types, and those that are useful
              regarding virtual path providers are explained below.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Prerequisites for a VirtualPathProvider" >
          Prerequisites for a VirtualPathProvider
          <Element Type="Text">
            <p>
              A custom <code>VirtualPathProvider</code> requires specific permissions, according to MSDN. If you look into
              the code using Reflector, you’ll find:
            </p>
            <pre>
              [AspNetHostingPermission(SecurityAction.Demand, Level=AspNetHostingPermissionLevel.High)]
              public static void RegisterVirtualPathProvider(VirtualPathProvider virtualPathProvider)
              {
                  if (_theHostingEnvironment == null)
                  {
                      throw new InvalidOperationException();
                  }
                  if (!BuildManager.IsPrecompiledApp)
                  {     
              RegisterVirtualPathProviderInternal(virtualPathProvider);
                  }
              }
            </pre>
            <p>
              The <code>AspNetHostingPermission</code> attribute means that you’ll need to run in full trust in order to
              register a provider. If you don’t have permission, a <code>SecurityException</code> is thrown. This is the same reason as for the check regarding pre-compilation.
              Both tests ensure that a <code>VirtualPathProvider</code>
              cannot be used without permissions or within a running environment. The third
              check searches for an existing hosting environment. Without this, a path
              provider cannot function.
            </p>

            <p>
              While the missing hosting
              environment throws an exception, the pre-compilation check allows the method to
              fail silently. To understand why, let’s examine the <code>Initialize</code> method in <code>RegisterVirtualPathProviderInternal</code>. It’s not the public method, but the internal one that looks like
              this:
            </p>
            <pre>
              internal virtual void
              Initialize(VirtualPathProvider previous)

              {

                  this._previous = previous;

                  this.Initialize();

              }
            </pre>
            <p>
              If a <code>VirtualPathProvider</code> supports a fallback scenario, this setting ensures that the
              “fallback provider” is available. The overridden <code>Initialize</code>
              method that you may have changed is called after this.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Helpful Classes for Path and File Operations" >
          Helpful Classes for Path and File Operations
          <Element Type="Text">
            <p>
              <code>HostingEnvironment</code> is a class defined in
              <code>System.Web.Hosting</code> that defines the very basic types used to support the ASP.NET
              hosting environment. The same namespace contains the <code>VirtualPathProvider</code> base class. The <code>HostingEnvironment</code> class contains several static methods. Some are useful when dealing
              with paths and path resolving issues.
            </p>
          </Element>
          <Element Type="Section" Name = "The HostingEnvironment Class" >
            The HostingEnvironment Class
            <Element Type="Text">
              <p>
                Let’s take a look at the path handling
                capabilities provided by ASP.NET before we start writing a path provider. The
                following table shows a selection of methods in the class, which explicitly
                support path operations.
              </p>
              <Element Type="Table" Name="Members of the HostingEnvironment class pertaining to path operations">
                <table>
                  <tr>
                    <th>PMethod or Property</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>
                      <code>MapPath</code>
                    </td>
                    <td>
                      Maps a virtual path to
                      its physical counterpart on the server
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>RegisterVirtualPathProvider</code>
                    </td>
                    <td>Registers a virtual path provider</td>
                  </tr>
                  <tr>
                    <td>
                      <code>ApplicationPhysicalPath</code>
                    </td>
                    <td>
                      Gets the
                      physical path of the application
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>ApplicationVirtualPath</code>
                    </td>
                    <td>
                      Gets the virtual
                      path of the application
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code>VirtualPathProvider</code>
                    </td>
                    <td>Gets the currently registered path provider</td>
                  </tr>
                  <tr>
                    <td>
                      <code>SiteName</code>
                    </td>
                    <td>
                      The name of the site
                    </td>
                  </tr>
                </table>
              </Element>
              <Element Type="Text">
                <p>
                  All properties and methods mentioned
                  above are static and don’t require an instance of the class. The other methods and
                  properties concern application domains, object registering, caching, and impersonation.
                  But that’s beyond the scope of this chapter. If you’d like to learn more, take
                  a look at the following MSDN page:
                </p>
                <pre>
                  http://msdn.microsoft.com/en-us/library/system.web.hosting.hostingenvironment.aspx
                </pre>
              </Element>
            </Element>
          </Element>
          <Element Type="Section" Name = "VirtualFile and VirtualDirectory" >
            VirtualFile and VirtualDirectory
            <Element Type="Text">
              <p>
                <code>VirtualFile</code> allows
                direct access to virtual files and reads the file contents as a stream:
              </p>
              <pre>
                public abstract class VirtualFile :
                VirtualFileBase

                {

                    protected VirtualFile(string virtualPath);

                    public override bool IsDirectory { get; }

                    public abstract Stream Open();

                }
              </pre>
              <p>
                <code>IsDirectory</code> always returns
                <code>false</code>. The <code>Open</code> method must be
                overridden and return a read-only stream to the virtual resource.
              </p>
              <p>
                The <code>VirtualDirectory</code> class is similar and manages a directory:
              </p>
              <pre>
                public abstract class VirtualDirectory : VirtualFileBase
                {
                    protected VirtualDirectory(string virtualPath);
                    public abstract IEnumerable Children { get; }
                    public abstract IEnumerable Directories { get; }
                    public abstract IEnumerable Files { get; }
                    public override bool IsDirectory { get; }
                }
              </pre>
              <p>
                <code>Directories</code> lists the subdirectories in
                this virtual directory. <code>Files</code> returns the files
                only. <code>Children</code> returns both the files and the folders. <code>IsDirectory</code> always returns <code>true</code>.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "VirtualPathUtility" >
            VirtualPathUtility
            <Element Type="Text">
              <p>
                This class is defined in the <code>System.Web</code> namespace and provides further useful methods:
              </p>
            </Element>
            <Element Type="Table" Name="Members of the VirtualPathUtility class">
              <table>
                <tr>
                  <th>Method or Property</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td>
                    <code>AppendTrailingSlash</code>
                  </td>
                  <td>
                    Adds a slash
                    at the end of the path if there isn’t one
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>Combine</code>
                  </td>
                  <td>
                    Concatenates a base
                    path and a relative path
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetDirectory</code>
                  </td>
                  <td>
                    Gets the directory
                    path of a virtual path
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetExtension</code>
                  </td>
                  <td>
                    Gets the extension of
                    a file with a virtual path
                  </td>
                  <td>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>GetFileName</code>
                  </td>
                  <td>
                    Gets the file name of a
                    file with a virtual path
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>IsAbsolute</code>
                  </td>
                  <td>
                    Indicates whether a
                    path is absolute
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>IsAppRelative</code>
                  </td>
                  <td>
                    Indicates whether a
                    virtual path is relative against the application
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>MakeRelative</code>
                  </td>
                  <td>
                    Transforms an
                    application relative path with stem operator “~” into a relative virtual path
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>RemoveTrailingSlash</code>
                  </td>
                  <td>
                    Removes a trailing
                    slash from the end; does nothing if there is no slash present
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>ToAbsolute</code>
                  </td>
                  <td>
                    Converts a virtual
                    path into an absolute one
                  </td>
                </tr>
                <tr>
                  <td>
                    <code>ToAppRelative</code>
                  </td>
                  <td>
                    Converts an absolute path into a relative one
                  </td>
                </tr>
              </table>
            </Element>
            <Element Type="Text">
              <p>
                All these methods are static, and thus don’t
                require an instance of the class to be created.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Creating a Virtual Path Provider to Get Themes from Database" >
          Creating a Virtual Path Provider to Get Themes from Database
          <Element Type="Text">
            <p>
              Now that we have all the prerequisites,
              let’s write a provider. In this example, I want to change the behavior of the <code>App_Themes</code> folder. A theme is usually a static conglomeration of skins, style
              sheet files and images. You can specify a theme either in <i>web.config</i> or within
              each web page. Let’s define individual themes in another folder and relate them
              to pages. This is possible using a custom <code>VirtualPathProvider</code>. Its path is defined in <i>web.config</i>, and you can either set it
              dynamically or manipulate it. The provider shown in this section gives you the
              basic framework for handling file access and file resolving.
            </p>
          </Element>
          <Element Type="Section" Name = "Prepare the Project" >
            Prepare the Project
            <Element Type="Text">
              <p>
                The themes are still in a folder in
                your project. The database only defines a reference to the theme’s name. To
                avoid confusing Visual Studio with a regular theme, all themes are kept in a
                different folder named <i>Path_Themes</i>. You can use any valid name except
                for <code>App_Themes</code>, which is reserved.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Create the VirtualPathProvider" >
            Create the VirtualPathProvider
            <Element Type="Text">
              <p>
                The path provider should function as a transparent
                layer for ASP.NET. Implementing it completely requires more steps than other
                providers. For the sake of brevity, I’ve created a simplified but functional path
                provider that consists of three classes:
              </p>
              <ul>
                <li>
                  <code>VirtualThemeFile</code>
                </li>
                <li>
                  <code>VirtualThemeDirectory</code>
                </li>
                <li>
                  <code>VirtualThemePathProvider</code>
                </li>
              </ul>
              <p>
                This provider lacks caching, which
                causes it to work slowly, but it’s fully functional. However, the cache
                implementation is not particularly difficult and can be added easily. I’ve excluded
                it as it’s out of this section’s scope.
              </p>
            </Element>
            <Element Type="Listing" Name="Handling virtual files">
              public class VirtualThemeFile : System.Web.Hosting.VirtualFile
              {
                  private string _themeAbsolutePath = String.Empty;
                  private string _globalAbsolutePath = String.Empty;
                  private VirtualThemeDirectory _parent = null;
                  public VirtualThemeFile(String virtualPath,
                      string themeAbsolutePath,
                      string globalAbsolutePath,
                      VirtualThemeDirectory parent)
                      : base(virtualPath)
                  {
                      _themeAbsolutePath = themeAbsolutePath;
                      _globalAbsolutePath = globalAbsolutePath;
                      _parent = parent;
                  }
                  public override Stream Open()
                  {
                      return File.Open(AbsolutePath, FileMode.Open);
                  }
                  public VirtualThemeDirectory Parent
                  {
                      get
                      {
                          return _parent;
                      }
                  }
                  private String AbsolutePath
                  {
                      get
                      {
                          // Get the current set value

                          String currentSet =
              ThemePathProvider.Current.CurrentSet;

                          if
              ((!String.IsNullOrEmpty(_themeAbsolutePath))

                              &amp;&amp;
              (Parent.FileIsIncluded(Name, currentSet, true)))

                              return _themeAbsolutePath;

                          else if
              ((!String.IsNullOrEmpty(_globalAbsolutePath))

                              &amp;&amp;
              (Parent.FileIsIncluded(Name, currentSet, false)))

                              return _globalAbsolutePath;

                          return String.Empty;
                      }
                  }
                  internal Boolean ExistsInThemeDirectory
                  {
                      get
                      {
                          return (!String.IsNullOrEmpty(_themeAbsolutePath));
                      }
                  }
                  internal Boolean ExistsInGlobalDirectory
                  {
                      get
                      {
                          return (!String.IsNullOrEmpty(_globalAbsolutePath));
                      }
                  }
              }
            </Element>
            <Element Type="Text">
              <p>
                The <code>VirtualThemeFile</code> class holds a reference to a specific file from the <i>Path_Themes</i>
                folder. This is usually a skin file, a style sheet, or a resource (such as an
                image) used with a theme. The file’s complete location is stored in the <code>AbsolutePath</code> property and used in the <code>Open</code> method.
                (The <code>Open</code> method is called to read the file’s contents.) The <code>Parent</code> property points to the containing directory.
              </p>
              <p>
                The main focus of the implementation
                is the directory handling. Hence, the <code>VirtualThemeDirectory</code> class contains much more code.
              </p>
            </Element>
            <Element Type="Listing" Name="Handling virtual directories">
              public class VirtualThemeDirectory : VirtualDirectory
              {
                  struct ItemSearchInfo
                  {
                      public String Name;
                      public String VirtualPath;
                      public String ThemeAbsolutePath;
                      public String GlobalAbsolutePath;
                  }

                  private VirtualThemeDirectory _parent = null;
                  private String _themeAbsolutePath = String.Empty;
                  private String _globalAbsolutePath = String.Empty;
                  private Dictionary&lt;String, VirtualThemeDirectory&gt; _directories = null;
                  private Dictionary&lt;String, VirtualThemeFile&gt; _files = null;
                  private Dictionary&lt;String, VirtualFileBase&gt; _children = null;
                  public VirtualThemeDirectory(String virtualPath)
                      : this(virtualPath, String.Empty, String.Empty, null)
                  {           
                  }

                  public VirtualThemeDirectory(String virtualPath,
                      String themeAbsolutePath,
                      String globalAbsolutePath)
                      : this(virtualPath, themeAbsolutePath, globalAbsolutePath, null)
                  {
                  }

                  public VirtualThemeDirectory(String virtualPath,
                      String themeAbsolutePath,
                      String globalAbsolutePath,
                      VirtualThemeDirectory parent)
                      : base(virtualPath)
                  {
                      if (String.IsNullOrEmpty(themeAbsolutePath))
                      {
                          String sThemeRelativePath =
                            ThemePathProvider.Current.ConvertToThemeRelativePath(virtualPath);
                          themeAbsolutePath =
                            HttpContext.Current.Server.MapPath(sThemeRelativePath);
                      }
                      if (!Directory.Exists(themeAbsolutePath))
                      {
                          themeAbsolutePath = String.Empty;
                      }

                      if
              (String.IsNullOrEmpty(globalAbsolutePath))

                      {

                          String sGlobalRelativePath =  

                            ThemePathProvider.Current.ConvertToGlobalRelativePath(VirtualPath);

                          globalAbsolutePath =  

                            HttpContext.Current.Server.MapPath(sGlobalRelativePath);

                      }

                      if
              (!Directory.Exists(globalAbsolutePath))

                          globalAbsolutePath = String.Empty;

                      _themeAbsolutePath = themeAbsolutePath;

                      _globalAbsolutePath =
              globalAbsolutePath;

                      _parent = parent;

                      // Create the collections to hold the
              virtual items

                      _files = new Dictionary&lt;string,
              VirtualThemeFile&gt;();

                      _directories = new Dictionary&lt;string,
              VirtualThemeDirectory&gt;();

                      _children = new Dictionary&lt;string,
              VirtualFileBase&gt;();

                      FindFiles();

                      FindSubDirectories();

                      FindChildren();

                  }

                 

                  private void FindFiles()

                  {

                      Dictionary&lt;String, ItemSearchInfo&gt;
              fileList =  

                          new Dictionary&lt;string,
              ItemSearchInfo&gt;();

                      if (Directory.Exists(ThemeAbsolutePath))

                      {

                          var files = from f in
              Directory.GetFiles(ThemeAbsolutePath)

                                      select new
              ItemSearchInfo

                                      {

                                          Name =
              Path.GetFileName(f),

                                          VirtualPath =
              VirtualPathUtility.Combine(VirtualPath,

                                                                         
              Path.GetFileName(f)),

                                          ThemeAbsolutePath =
              f

                                      };

                          foreach (ItemSearchInfo fileInfo in
              files)

                          {

                              fileList.Add(fileInfo.Name,
              fileInfo);

                          }

                      }

                      if
              (Directory.Exists(GlobalAbsolutePath))

                      {

                          var files = from f in
              Directory.GetFiles(GlobalAbsolutePath)

                                      select new
              ItemSearchInfo

                                      {

                                          Name =
              Path.GetFileName(f),

                                          VirtualPath =
              VirtualPathUtility.Combine(VirtualPath,

                                                                         
              Path.GetFileName(f)),

                                          GlobalAbsolutePath =
              f

                                      };

                          foreach (ItemSearchInfo fileInfo in
              files)

                          {

                              if
              (fileList.ContainsKey(fileInfo.Name))

                              {

                                  ItemSearchInfo themeFileInfo
              = fileList[fileInfo.Name];

                                 
              fileList.Remove(themeFileInfo.Name);

                                  fileList.Add(themeFileInfo.Name,
              themeFileInfo);

                              }

                              else

                              {

                                  fileList.Add(fileInfo.Name,
              fileInfo);

                              }

                          }

                      }

                      // Loop through each file found

                      foreach (ItemSearchInfo fileInfo in
              fileList.Values)

                      {

                           // Add each file to the files
              dictionary using the

                           // information stored for the
              file

                          _files.Add(fileInfo.Name, new
              VirtualThemeFile(fileInfo.VirtualPath,

                                                                  
              fileInfo.ThemeAbsolutePath,

                                                                
               fileInfo.GlobalAbsolutePath,

                                                                                      
              this));

                      }           

                  }

                  private void FindSubDirectories()

                  {

                      Dictionary&lt;String, ItemSearchInfo&gt;
              directoryList =  

                                new Dictionary&lt;string,
              ItemSearchInfo&gt;();

                      Func&lt;string, string, string&gt;
              MakePath = delegate(string b, string v)

                      {

                          return
              VirtualPathUtility.AppendTrailingSlash(

                                                      VirtualPathUtility.Combine(b,
              v));

                      };

                      if (Directory.Exists(ThemeAbsolutePath))

                      {

                          var themeDirectories =  

                                      from t in
              Directory.GetDirectories(ThemeAbsolutePath)

                                      select new
              ItemSearchInfo

                                      {

                                          Name =
              Path.GetFileName(t),

                                          VirtualPath =
              MakePath(VirtualPath,

                                                        Path.GetFileName(t)),

                                          ThemeAbsolutePath =
              t

                                      };

                          foreach (ItemSearchInfo
              directoryInfo in themeDirectories)

                          {

                             
              directoryList.Add(directoryInfo.Name, directoryInfo);

                          }

                      }

                      if
              (Directory.Exists(GlobalAbsolutePath))

                      {

                          var themeDirectories =  

                                      from t in
              Directory.GetDirectories(GlobalAbsolutePath)

                                      select new
              ItemSearchInfo

                                      {

                                          Name =
              Path.GetFileName(t),

                                          VirtualPath =
              MakePath(VirtualPath,

                                                        Path.GetFileName(t)),

                                          GlobalAbsolutePath =
              t

                                      };

                          foreach (ItemSearchInfo
              directoryInfo in themeDirectories)

                          {

                              if
              (directoryList.ContainsKey(directoryInfo.Name))

                              {

                                  ItemSearchInfo
              themeDirectoryInfo =

                                                 directoryList[directoryInfo.Name];

                                  directoryList.Remove(themeDirectoryInfo.Name);

                                 
              directoryList.Add(themeDirectoryInfo.Name, themeDirectoryInfo);

                              }

                              else

                              {

                                 
              directoryList.Add(directoryInfo.Name, directoryInfo);

                              }

                          }

                      }

                      foreach (ItemSearchInfo directoryInfo in
              directoryList.Values)

                      {

                          VirtualThemeDirectory directory =
              new VirtualThemeDirectory(

                                                            directoryInfo.VirtualPath,

                                                            directoryInfo.ThemeAbsolutePath,

                                                            directoryInfo.GlobalAbsolutePath,

                                                            this);

                          _directories.Add(directory.Name,
              directory);

                      }

                  }

                  private void FindChildren()

                  {

                      foreach (VirtualThemeDirectory directory
              in Directories)

                      {

                          _children.Add(directory.Name,
              directory);

                      }

                      foreach (VirtualThemeFile file in Files)

                      {

                          _children.Add(file.Name, file);

                      }

                  }

                  public Boolean GetFileIsIncluded(String
              fileName)

                  {

                      String currentSet = ThemePathProvider.Current.CurrentSet;

                      if (FileIsIncluded(fileName, currentSet,
              true))

                      {

                          return true;

                      }

                      else

                      {

                          return FileIsIncluded(fileName,
              currentSet, false);

                      }

                  }

                  public Boolean GetDirectoryIsIncluded(String
              directoryName)

                  {

                      String currentSet =
              ThemePathProvider.Current.CurrentSet;

                      if (DirectoryIsIncluded(directoryName,
              currentSet, true))

                      {

                          return true;

                      }

                      else

                      {

                          return
              DirectoryIsIncluded(directoryName, currentSet, false);

                      }

                  }

                  internal Boolean FileIsIncluded(string
              fileName, string currentSet,

                                                   boolean
              checkAgainstTheme)

                  {

                      if (!_files.ContainsKey(fileName))

                          return false;

                      VirtualThemeFile file =
              _files[fileName];

                      if ((checkAgainstTheme)

                          &amp;&amp; (!file.ExistsInThemeDirectory)

                      {

                          return false;

                      }

                      else if ((!checkAgainstTheme)

                          &amp;&amp;
              (!file.ExistsInGlobalDirectory))

                      {

                          return false;

                      }

                      if (String.IsNullOrEmpty(currentSet))

                          return true;

                      String fileExtension =
              Path.GetExtension(fileName);

                      if (fileExtension.ToUpper() ==
              &quot;.SKIN&quot;

                          ||

                          fileExtension.ToUpper() ==
              &quot;.CSS&quot;

                          ||

                          fileExtension.ToUpper() ==
              &quot;.JPG&quot;)

                      {

                          return true;

                      }

                      return false;

                  }

                  internal Boolean DirectoryIsIncluded(string
              directoryName,

                                                        string
              currentSet,

                                                        boolean
              checkAgainstTheme)

                  {

                      if
              (!_directories.ContainsKey(directoryName))

                          return false;

                      VirtualThemeDirectory directory =
              _directories[directoryName];

                      if ((checkAgainstTheme)

                          &amp;&amp;
              (!directory.ExistsInThemeDirectory))

                      {

                          return false;

                      }

                      else if ((!checkAgainstTheme)

                          &amp;&amp;
              (!directory.ExistsInGlobalDirectory))

                      {

                          return false;

                      }

                      return true;

                  }

                  internal VirtualThemeFile GetFile(String
              fileName)

                  {

                      return _files[fileName];

                  }

                  internal VirtualThemeDirectory
              GetDirectory(String virtualDir)

                  {

                      if (_directories.Count == 0)

                          return null;

                      if (virtualDir.StartsWith(VirtualPath,

                          !StringComparison.InvariantCultureIgnoreCase))

                          return null;

                      String relativeVirtualPath =
              virtualDir.Substring(VirtualPath.Length);

                      String directoryName =
              relativeVirtualPath.Substring(0,

                                             relativeVirtualPath.IndexOf(&quot;/&quot;));

                      VirtualThemeDirectory childDirectory =
              _directories[directoryName];

                      if (childDirectory.VirtualPath ==
              virtualDir)

                          return childDirectory;

                      else

                          return
              childDirectory.GetDirectory(virtualDir);

                  }

                 

                  public VirtualThemeDirectory Parent

                  {

                      get

                      {

                          return _parent;

                      }

                  }

                  public Boolean Exists

                  {

                      get

                      {

                          return
              ((Directory.Exists(_themeAbsolutePath))

                              || (Directory.Exists(_globalAbsolutePath)));

                      }

                  }

                  private Boolean ExistsInThemeDirectory

                  {

                      get

                      {

                          return (!String.IsNullOrEmpty(_themeAbsolutePath));

                      }

                  }

                  private Boolean ExistsInGlobalDirectory

                  {

                      get

                      {

                          return
              (String.IsNullOrEmpty(_globalAbsolutePath));

                      }

                  }

                  public override IEnumerable Directories

                  {

                      get

                      {

                          return _directories.Value;

                      }

                  }

                  public override IEnumerable Files

                  {

                      get

                      {

                          return _files.Value;

                      }

                  }

                  public override IEnumerable Children

                  {

                      get

                      {

                          return _children.Value;

                      }

                  }

                  private String ThemeAbsolutePath

                  {

                      get

                      {

                          return _themeAbsolutePath;

                      }

                  }

                  private String GlobalAbsolutePath

                  {

                      get

                      {

                          return _globalAbsolutePath;

                      }

                  }

              }
            </Element>
            <Element Type="Text">
              <p>
                The main purpose of this class
                is to build a copy of the directory and file structure found in the physical
                theme folder (<i>Path_Themes</i>) and to store references to the files. When
                the provider retrieves the files, it accesses this virtual structure.
              </p>
              <p>
                Three internal methods are called
                in the constructor: <code>FindFiles</code>, <code>FindSubDirectories</code> and <code>FindChildren</code>. The <code>Findfiles</code> method reads files in the current base folder. <code>FindSubDirectories</code> loads directories recursively. In each directory located, the <code>FindFiles</code> method is called to load the files for that folder. The <code>FindChildren</code> method creates a single combined list of both directories and
                files.
              </p>
              <p>
                The provider
                calls the <code>GetDirectory</code> method to retrieve a specific directory. A simple filter, <code>FileIsIncluded</code>, limits the allowed file types. This is exclusive to the handling
                of themes; other <code>VirtualPathProvider</code>
                implementations might require different types. The example ignores all files except
                for *.skin, *.css, and *.jpg, but you can extend the list to support any file
                type used in your themes.
              </p>
              <p>
                The <code>GetFile</code> method allows access to a file once it has been located in a
                directory. The resolving of files and their paths occurs in the compiler
                module. A simple file list handles all files in all directories. The key
                contains the full path, so files with the same filename but located in different
                folders still have a unique full name.
              </p>
            </Element>
            <Element Type="Listing" Name="Implementation of a custom VirtualPathProvider">
              public sealed class ThemePathProvider :VirtualPathProvider
              {

                  private static ThemePathProvider _currentProvider = null;
                  private const string ASPNetThemeBasePath = &quot;/App_Themes/&quot;;
                  private string _themeRelativePath = String.Empty;
                  private string _currentThemeSet = String.Empty;
                  private string _globalThemeName = String.Empty;
                  private ThemePathProvider()
                  {

                      _themeRelativePath =

                              WebConfigurationManager.AppSettings[&quot;CustomThemeBasePath&quot;];

                  }

                  public override
              System.Web.Caching.CacheDependency GetCacheDependency(

                         string virtualPath,

                         System.Collections.IEnumerable
              virtualPathDependencies,

                         DateTime utcStart)

                  {

                      return null;

                  }

                  public override bool DirectoryExists(string
              virtualDir)

                  {

                      if
              (virtualDir.IndexOf(ASPNetThemeBasePath) == -1)

                          return
              base.DirectoryExists(virtualDir);

                      VirtualThemeDirectory directory =
              GetDirectory(virtualDir) as

                                                        VirtualThemeDirectory;

                      return directory.Exists;

                  }

                  public override bool FileExists(string
              virtualPath)

                  {

                      if
              (virtualPath.IndexOf(ASPNetThemeBasePath) == -1)

                          return base.FileExists(virtualPath);

                      string fileName =
              System.Web.VirtualPathUtility.GetFileName(virtualPath);

                      string virtualDirectoryPath =

                                   System.Web.VirtualPathUtility.GetDirectory(virtualPath);

                      VirtualThemeDirectory directory =

                                   GetDirectory(virtualDirectoryPath)
              as VirtualThemeDirectory;

                      return
              directory.GetFileIsIncluded(fileName);

                  }

                  public override VirtualDirectory
              GetDirectory(string virtualDir)

                  {

                      if
              (virtualDir.IndexOf(ASPNetThemeBasePath) == -1)

                          return
              base.GetDirectory(virtualDir);

                      if
              (IsThemeDirectoryVirtualPath(virtualDir))

                      {

                          return new
              VirtualThemeDirectory(virtualDir);

                      }

                      else

                      {

                          String themeVirtualPath =
              GetThemeDirectoryVirtualPath(virtualDir);

                          VirtualThemeDirectory directory =
              new VirtualThemeDirectory(virtualDir);

                          return
              directory.GetDirectory(virtualDir);

                      }

                  }

                  public override VirtualFile GetFile(string
              virtualPath)

                  {

                      if
              (virtualPath.IndexOf(ASPNetThemeBasePath) == -1)

                          return base.GetFile(virtualPath);

                      String virtualDirectoryPath =

                                  System.Web.VirtualPathUtility.GetDirectory(virtualPath);

                      VirtualThemeDirectory directory =

                                  GetDirectory(virtualDirectoryPath)
              as VirtualThemeDirectory;

                      String fileName =
              System.Web.VirtualPathUtility.GetFileName(virtualPath);

                      return directory.GetFile(fileName);

                  }

                  private StringCollection
              GetDependentDirectories(

                      String parentDirectoryPath,

                      StringCollection dependentPaths)

                  {

                      String[] directories =
              Directory.GetDirectories(parentDirectoryPath);

                      for (int loopIndex = 0; loopIndex &lt;
              directories.Length; loopIndex++)

                      {

                         
              dependentPaths.Add(directories[loopIndex]);

                         
              GetDependentDirectories(directories[loopIndex], dependentPaths);

                      }

                      return dependentPaths;

                  }

                  private Boolean
              IsThemeDirectoryVirtualPath(String virtualPath)

                  {

                      String parentVirtualPath =

                             System.Web.VirtualPathUtility.GetDirectory(virtualPath);

                      return
              parentVirtualPath.EndsWith(ASPNetThemeBasePath,

                             StringComparison.InvariantCultureIgnoreCase);

                  }

                  private String
              GetThemeDirectoryVirtualPath(String virtualPath)

                  {

                      String parentVirtualPath =  

                             System.Web.VirtualPathUtility.GetDirectory(virtualPath);

                      while
              (!IsThemeDirectoryVirtualPath(parentVirtualPath))

                      {

                          parentVirtualPath =

                             System.Web.VirtualPathUtility.GetDirectory(parentVirtualPath);

                      }

                      return parentVirtualPath;

                  }

                  internal String
              ConvertToThemeRelativePath(String relativePath)

                  {

                      return
              ConvertToThemeNameRelativePath(relativePath, false);

                  }

                  internal String
              ConvertToGlobalRelativePath(String relativePath)

                  {

                      return
              ConvertToThemeNameRelativePath(relativePath, true);

                  }

                  private String
              ConvertToThemeNameRelativePath(String relativePath,

                                                 Boolean
              replaceThemeNameWithGlobal)

                  {

                      String themeNameRelativePath =
              String.Empty;

                      if
              ((!relativePath.StartsWith(ASPNetThemeBasePath))

                          &amp;&amp;
              (!_themeRelativePath.StartsWith(&quot;/&quot;)))

                      {

                          themeNameRelativePath =
              relativePath.Substring(0,

                                               relativePath.IndexOf(ASPNetThemeBasePath));

                      }

                      if
              ((!themeNameRelativePath.EndsWith(&quot;/&quot;))

                          &amp;&amp;
              (!_themeRelativePath.StartsWith(&quot;/&quot;)))

                      {

                          themeNameRelativePath =

                                          System.Web.VirtualPathUtility.

                                          AppendTrailingSlash(themeNameRelativePath);

                      }

                      themeNameRelativePath +=
              _themeRelativePath;

                      String remainderPath =
              relativePath.Substring(

                                             relativePath.IndexOf(ASPNetThemeBasePath)
              +             

                                             ASPNetThemeBasePath.Length);

                      if (replaceThemeNameWithGlobal)

                      {

                          remainderPath =
              remainderPath.Substring(remainderPath.IndexOf(&quot;/&quot;));

                      }

                      themeNameRelativePath += remainderPath;

                      return themeNameRelativePath;

                  }

                  public static ThemePathProvider Current

                  {

                      get

                      {

                          if (_currentProvider != null)

                              return _currentProvider;

                          _currentProvider = new
              ThemePathProvider();

                          return _currentProvider;

                      }

                  }

                  public String CurrentSet

                  {

                      get

                      {

                          return _currentThemeSet;

                      }

                      set

                      {

                          _currentThemeSet = value;

                      }

                  }

              }
            </Element>
            <Element Type="Text">
              <p>
                The <code>GetCacheDependency</code> returns <code>null</code> in order to
                suppress any internal caching. You must either return <code>null</code> or fully implement the caching. Otherwise, the compiler will try to
                resolve the default path (<i>App_Themes</i>) from the cache and this will fail.
              </p>
              <p>
                Two methods are called when
                the compiler tries to resolve an internal path: <code>GetDirectory</code>
                and <code>GetFile</code>. If a file is referenced in a page that points to a theme, the
                compiler asks the provider to retrieve the same. Using the <code>GetFile</code> method, we first check whether the theme’s folder is being used.
                This is the folder for which the provider in the example is responsible. From
                the file’s name, the containing directory is built. The directory is used to obtain
                the <code>VirtualThemeDirectory</code> implementation, which in turn returns the file held there.
              </p>
              <p>
                At the core of this implementation
                is a path manipulation algorithm. It could be far more sophisticated than the
                simple code in the example.
              </p>
              <p>
                Before a folder or file is
                retrieved, the <code>DirectoryExists</code> and <code>FileExists</code> methods are called. This allows the provider to programmatically “hide”
                parts of the structure or to check for the physical presence of the requested
                resource.
              </p>
              <p>
                The basic approach is always the
                same. The calling instance “asks” the provider for a physical file. The
                provider returns a <code>VirtualFile</code> instance,
                which allows direct access to the file’s contents via a <code>Stream</code> object. The remarkable thing is that the file might not necessarily
                exist anywhere on the file system. If, for example, the stream is obtained from
                a database call, the <code>VirtualPathProvider</code> is simulating
                a physical file system. The “Exists” methods could always return <code>true</code> in order to simulate a system where the page developers can use any
                value, and the system returns a set of globally predefined resources.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Configuring the Path Provider" >
            Configuring the Path Provider
            <Element Type="Text">
              <p>
                The provider requires two final configuration
                steps. Firstly, it must have a setting in <i>web.config</i> to show that it’s
                configurable. Secondly, the provider must be registered, which follows the
                pattern previously explained. To demonstrate, I’ve used the <code>Application_Start</code> event handler defined in the <i>global.asax</i> file:
              </p>
            </Element>
            <Element Type="Listing" Name="Configuration settings in web.config">
              &lt;appSettings&gt;

                 &lt;add key=&quot;CustomThemeBasePath&quot;
              value=&quot;/Path_Themes/&quot;/&gt;

              &lt;/appSettings&gt;
              ]]
            </Element>
            <Element Type="Text">
              <p>
                In the example, the key is used to
                configure the physical path.
              </p>
            </Element>
            <Element Type="Listing" Name="Registering the path provider using the Application_Start event">
              protected void Application_Start(object sender, EventArgs e)
              {
              HostingEnvironment.RegisterVirtualPathProvider(ThemePathProvider.Current);
              }
            </Element>
            <Element Type="Text">
              <p>
                The registration uses a singleton
                instance of the provider instead of the constructor. This results in slightly
                shorter code. A singleton instance works well because the provider works
                globally and exists only once in the application.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Limitations of the VirtualPathProvider Approach" >
          Limitations of the VirtualPathProvider Approach
          <Element Type="Text">
            <p>
              The <code>VirtualPathProvider</code> is deeply integrated in the ASP.NET engine. Although it’s very powerful,
              certain tasks can be problematic. In this section, I explain two typical issues
              found when working with custom path providers.
            </p>
          </Element>
          <Element Type="Section" Name = "Working with LoadControl" >
            Working with LoadControl
            <Element Type="Text">
              <p>
                The <code>VirtualPathProvider</code> allows you to override the way in which tilde-based paths are
                resolved in page directives:
              </p>
              <pre>
                &lt;%@ Register TagPrefix=&quot;Test&quot;
                TagName=&quot;MyControl&quot; Src=&quot;~/userctrl.ascx&quot; %&gt;
              </pre>
              <p>
                However, the <code>VirtualPathProvider</code> cannot affect the way in which tilde-based paths are resolved for
                dynamically loaded user controls:
              </p>
              <pre>
                MyPlaceHolder.Controls.Add(LoadControl(&quot;~/userctrl.ascx&quot;));
              </pre>
              <p>
                For the <code>LoadControl</code>
                method to resolve tilde-based paths in the same way as <code>Register</code> directives, the page code-behind needs to override this method:
              </p>
              <pre>
                public new Control LoadControl(string relativePath)
                {
                   string newPath = relativePath;
                   string site = this.Request.QueryString[&quot;site&quot;];
                   if (!String.IsNullOrEmpty(site))
                   {
                      newPath = VirtualPathUtility.ToAppRelative(newPath);
                      newPath = newPath.Substring(1);
                      newPath = &quot;~/MySites/&quot; + site + newPath;
                   }

                   return base.LoadControl(newPath);
                }
              </pre>
              <p>
                This workaround will function as long as
                <code>LoadControl</code> is called directly on your derived class, since it’s not <code>virtual</code>. A similar override in a <code>UserControl</code>
                base class might be also required, since <code>LoadControl</code>
                lives on <code>TemplateControl</code>.
              </p>
            </Element>
          </Element>
          <Element Type="Section" Name = "Working with Precompiled Sites" >
            Working with Precompiled Sites
            <Element Type="Text">
              <p>
                Unfortunately, <code>VirtualPathProvider</code> is not supported in precompiled web sites at the moment. As shown
                in the code exhibit decompiled using Reflector at the beginning of the
                VirtualPathProvider section, the precompiled state is explicitly detected. Consequently,
                MSDN notes that, “if a Web site is precompiled for deployment, content provided
                by a VirtualPathProvider instance is not compiled, and no VirtualPathProvider
                instances are used by the precompiled site.”
              </p>
              <p>
                One way to avoid deploying
                source code is to use the Web Application Project model, in which all classes
                and code-behind files are compiled. Although pre-compilation will give our site
                a performance boost, the difference in speed will only be noticeable during the
                first request to each folder. A more significant benefit is the new deployment
                option made available by pre-compilation—the option to deploy a site without
                copying any of the original source code to the server. This includes the code
                and markup in <i>aspx</i>, <i>ascx</i>, and <i>master</i> files.
              </p>
              <p>
                There is also a hack available
                to force the path provider to work with pre-compiled pages. This is not intended
                for production code, but if you’re under pressure to solve a similar issue, this
                tip might help. The solution is <code>DynamicMethod</code>. Just
                call a Microsoft internal method to register <code>VirtualPathProvider</code> directly. This method is internal and therefore only reflection can
                obtain it. The definition in <code>HostingEnvironment</code>
                looks like this:
              </p>
              <pre>
                internal static void
                RegisterVirtualPathProviderInternal(

                                     VirtualPathProvider
                virtualPathProvider)

                {

                    VirtualPathProvider previous =
                _theHostingEnvironment._virtualPathProvider;

                    _theHostingEnvironment._virtualPathProvider
                = virtualPathProvider;

                    virtualPathProvider.Initialize(previous);

                }
              </pre>
              <p>
                This is, again, a simple hack that may
                fail in future versions due to changes to the internal code by Microsoft.
              </p>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Summary" >
          Summary
          <Element Type="Text">
            <p>
              In this chapter, we looked at site
              management. Providing an existing structure to the navigation is the primary
              task of the <code>SiteMapProvider</code>. This provider allows
              the management of larger sites based on any data store you decide to implement.
              It’s transparent to the controls used to create navigational elements.
            </p>
            <p>
              The <code>VirtualPathProvider</code> gives you more control over internal (physical) and external
              (virtual) paths for directories and files. Replacing the provider allows you to
              “fake” the paths and set them to virtual ones, which makes it easy to manage
              complex file structures. The <code>VirtualPathProvider</code> is
              not as straightforward as the other ones, but it makes sense to use it if your embedded
              features, such as themes that can be extended or customized, are based on
              special folders.
            </p>
          </Element>
        </Element>
      </Element>
    </Element>
    <Element Type="Section" Name="Control Extensibility">
      Control Extensibility
      <Element Type="Text">
        <p>
          Web server controls are the essence of
          ASP.NET, as most aspx pages contain both static HTML and dynamic web server
          controls. Although ASP.NET includes a comprehensive collection of controls, third
          party developers have also built up an impressive array of controls, both free
          and commercial, for almost any task you can imagine. Furthermore, you can
          create your own controls by implementing both design-time and run-time
          behavior.
        </p>
        <p>
          Purchasing controls may not be
          the best solution if embedded ones will fit your needs with minor modification.
          A third party control is usually a sophisticated component designed for a specific
          purpose. For basic functionality in a lightweight package, it’s probably not optimal.
        </p>
        <p>
          Another option is to extend a standard
          ASP.NET control and modify the way it renders. ASP.NET’s extensibility concepts
          are not limited to providers; controls are extensible and customizable if you
          use adapters. In this chapter, I’ll cover adapter techniques and explain:
        </p>
        <ul>
          <li>
            How to implement and activate a
            control adapter
          </li>
          <li>
            How to make the adapter work
            depending on the current browser
          </li>
          <li>
            How to create adapters at a page
            level
          </li>
        </ul>
        <p>
          After reading this chapter, you’ll able
          to “adapt” an existing control so that it renders according to your needs. This
          could include different ways of creating HTML, adding JavaScript, or using cascading
          style sheets to format the output.
        </p>
      </Element>
      <Element Type="Section" Name = "Adaptive Control Behavior" >
        Adaptive Control Behavior
        <Element Type="Text">
          <p>
            Adaptive control behavior is
            architecture that changes the way controls render in order to suit the needs of
            specific clients. Adapters intercept states of the life cycle to alter rendering
            behavior. By default, each control has a designated adapter in a one-to-one
            relationship. It’s possible to change this relationship under certain
            circumstances—when, for example, you encounter a browser that requires a
            different kind of markup.
          </p>
          <p>
            To control the adaptive behavior, choose
            from the following techniques:
          </p>
          <ul>
            <li>
              Configure the application to
              support different markups
            </li>
            <li>
              Choose the <code>XhtmlTextWriter</code> or <code>ChtmlTextWriter</code> class to create specific
              markup
            </li>
            <li>
              Create a <code>TextWriter</code> class that writes the markup to the output stream
            </li>
            <li>
              Use a filter to recognize a client
              device and decide what kind of markup you need
            </li>
            <li>
              Create an adapter and assign the adapter
              to a control
            </li>
          </ul>
          <p>
            The markup is not the only aspect you
            may want to change. Depending on the capabilities of the target device you may
            need to think about:
          </p>
          <ul>
            <li>How to work with postback data</li>
            <li>Managing the view state</li>
            <li>Preventing changes to the control</li>
          </ul>
        </Element>
        <Element Type="Section" Name = "The Default Behavior" >
          The Default Behavior
          <Element Type="Text">
            <p>
              The render process of a page uses the <code>HtmlTextWriter</code> class by default. The <code>RenderControl</code> method is called recursively with an instance of the <code>HtmlTextWriter</code>. Each control adds its markup to the writer. By the end of the
              process, the writer holds the complete markup of the page and writes it to the
              output stream.
            </p>
            <p>
              ASP.NET includes several writer
              types compatible with specific output devices. For HTML 3.2, the <code>Html32TextWriter</code> is used. Which writer to use depends on the <code>TagWriter</code> of the <code>System.Web.HttpRequest.Browser</code>. If a browser supports HTML 4.0, the page framework should compose
              XHTML. Using <i>web.config</i>, you can configure this behavior and replace the
              <code>Html32TextWriter</code> with an <code>XHtmlTextWriter</code>. The <code>Browser</code> property returns an <code>HttpBrowserCapabilities</code>
              object.
            </p>
            <p>
              The underlying code is relatively
              straightforward. If a custom <code>TextWriter</code> is defined,
              the <code>CreateHtmlTextWriterFromType</code> is used. If not, the default <code>Html32TextWriter</code> is used. The following code snippets are decompiled from the <code>
                System.Web.HttpRequest
              </code>class and the <code>System.Web.UI.Page</code> class, respectively.
            </p>
            <pre>
              internal HtmlTextWriter CreateHtmlTextWriterInternal(TextWriter tw)
              {
                  Type tagWriter = this.TagWriter;
                  if (tagWriter != null)
                  {
                      return Page.CreateHtmlTextWriterFromType(tw, tagWriter);
                  }
                  return new Html32TextWriter(tw);
              }
              public Type TagWriter
              {
                  get
                  {
                      try
                      {
                          if (!this._havetagwriter)
                          {
                              string str = this[&quot;tagwriter&quot;];
                              if (string.IsNullOrEmpty(str))
                              {
                                  this._tagwriter = null;
                              }
                              else if (string.Compare(str, typeof(HtmlTextWriter).FullName, StringComparison.Ordinal) == 0)
                              {
                                  this._tagwriter = typeof(HtmlTextWriter);
                              }
                              else
                              {
                                  this._tagwriter = BuildManager.GetType(str, true);
                              }
                              this._havetagwriter = true;
                          }
                      }
                      catch (Exception exception)
                      {
                          throw this.BuildParseError(exception, &quot;tagwriter&quot;);
                      }
                      return this._tagwriter;
                  }
              }

              public static HtmlTextWriter CreateHtmlTextWriterFromType(TextWriter tw, Type writerType)
              {

                  HtmlTextWriter writer;

                  if (writerType == typeof(HtmlTextWriter))
                  {
                      return new HtmlTextWriter(tw);
                  }

                  if (writerType == typeof(Html32TextWriter))
                  {
                      return new Html32TextWriter(tw);
                  }
                  try
                  {
              Util.CheckAssignableType(typeof(HtmlTextWriter), writerType);
              writer = (HtmlTextWriter) HttpRuntime.CreateNonPublicInstance(writerType, new object[] { tw });
                  }
                  catch
                  {
                      throw new HttpException(SR.GetString(&quot;Invalid_HtmlTextWriter&quot;,
                                               new object[] { writerType.FullName }));
                  }
                  return writer;
              }
            </pre>
            <p>
              As you can see, the instance of the
              abstract <code>TextWriter</code> class is responsible for the rendering process. Because ASP.NET produces
              HTML, the <code>HtmlTextWriter</code> class is the optimum point for beginning to implement a custom
              writer class. The <code>XhtmlTextWriter</code> and <code>ChtmlTextWriter</code> types mentioned earlier derive from the <code>HtmlTextWriter</code> and <code>Html32TextWriter</code>
              respectively. They are concrete implementations for specific rendering behavior.
            </p>
          </Element>
          <Element Type="Image" Name="The Control Adapter Architecture">
            images\19835f0903.tif
          </Element>
        </Element>
        <Element Type="Section" Name = "Using Control Adapters" >
          <Element Type="Text">
            <p>
              To modify the behavior described
              earlier, you’ll need an implementation of the <code>System.Web.UI.Adapters.ControlAdapter</code> base class. In each phase of the lifecycle, the control checks
              whether or not an adapter is available. If there is one present, the adapter
              provides an alternative method that replaces the default method that would
              otherwise be called in that step in the lifecycle. If the adapter only modifies
              portions of the behavior, it can call the control’s default method instead.
              Adapters that modify the state persistence behavior differ in that they don’t
              modify, but completely replace, the default behavior. When the adapter
              intercepts the life cycle, the following actions (at a minimum) must occur:
            </p>
            <ul>
              <li>
                Override the <code>OnInit</code> method of the control adapter to modify the initializing phase
              </li>
              <li>
                Override the <code>Render</code> or <code>RenderChildren</code> method to add custom
                markup
              </li>
            </ul>
            <p>
              The abstract base class has the
              following structure:
            </p>
            <pre>
              public abstract class ControlAdapter
              {
                 protected ControlAdapter();
                 protected HttpBrowserCapabilities Browser { get; }
                 protected Control Control { get; }
                 protected Page Page { get; }
                 protected PageAdapter PageAdapter { get; }
                 protected internal virtual void BeginRender(HtmlTextWriter writer);
                 protected internal virtual void EndRender(HtmlTextWriter writer);
                 protected internal virtual void LoadAdapterControlState(object state);
                 protected internal virtual void LoadAdapterViewState(object state);
                 protected internal virtual void OnInit(EventArgs e);
                 protected internal virtual void OnLoad(EventArgs e);
                 protected internal virtual void OnPreRender(EventArgs e);
                 protected internal virtual void OnUnload(EventArgs e);
                 protected internal virtual void Render(HtmlTextWriter writer);
                 protected virtual void RenderChildren(HtmlTextWriter writer);
                 protected internal virtual object SaveAdapterControlState();
                 protected internal virtual object SaveAdapterViewState();
              }
            </pre>
            <p>
              Before you start implementing adapters
              to change a control’s behavior, you’ll need to learn the purpose for each
              property and method.
            </p>
          </Element>
          <Element Type="Table" Name="The ControlAdapter base class">
            <table>
              <tr>
                <th>Class Member</th>
                <th>Description</th>
              </tr>

              <tr>
                <td>
                  <code>Browser</code>
                </td>
                <td>
                  The browser
                  capabilities (<code>HttpBrowserCapabilities</code>) of the client
                  making the current HTTP request.
                </td>
              </tr>
              <tr>
                <td>
                  <code>Control</code>
                </td>
                <td>
                  The control to which this
                  control adapter is attached.
                </td>
              </tr>
              <tr>
                <td>
                  <code>Page</code>
                </td>
                <td>
                  The page containing the
                  control associated with this adapter.
                </td>
              </tr>
              <tr>
                <td>
                  <code>PageAdapter</code>
                </td>
                <td>
                  The page adapter (<code>System.Web.UI.Adapters.PageAdapter</code>) for the page defined by <code>Page</code>, above.
                </td>
              </tr>
              <tr>
                <td>
                  <code>BeginRender</code>
                </td>
                <td>
                  Called prior to the
                  rendering of a control. The method generates opening tags required by a
                  specific target. It takes a <code>System.Web.UI.HtmlTextWriter</code> object to render the target-specific output.
                </td>
              </tr>
              <tr>
                <td>
                  <code>EndRender</code>
                </td>
                <td>
                  Called after the
                  rendering of a control. The method generates closing tags that are required by
                  a specific target. It takes a <code>System.Web.UI.HtmlTextWriter</code> object to render the target-specific output.
                </td>
              </tr>
              <tr>
                <td>
                  <code>CreateChildControls</code>
                </td>
                <td>
                  Creates the
                  target-specific child controls for a composite control.
                </td>
              </tr>
              <tr>
                <td>
                  <code>LoadAdapterControlState</code>
                </td>
                <td>
                  Loads adapter
                  control state information saved by the <code>System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState</code> method during a previous request to the <code>Page</code>. Receives the state as a <code>StateBag</code>
                  object.
                </td>
              </tr>
              <tr>
                <td>
                  <code>LoadAdapterViewState</code>
                </td>
                <td>
                  Loads adapter
                  view state information saved by the <code>System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState</code> method during a previous request to the <code>Page</code>. Receives the state as a <code>StateBag</code>
                  object.
                </td>
              </tr>
              <tr>
                <td>
                  <code>OnInit</code>
                </td>
                <td>
                  Overrides the <code>System.Web.UI.Control.OnInit</code> method for the associated control in order to hook into the
                  initializing phase.
                </td>
              </tr>
              <tr>
                <td>
                  <code>OnLoad</code>
                </td>
                <td>
                  Overrides the <code>System.Web.UI.Control.OnLoad</code> method for the associated control in order to hook into the load
                  phase.
                </td>
              </tr>
              <tr>
                <td>
                  <code>OnPreRender</code>
                </td>
                <td>
                  Overrides the <code>System.Web.UI.Control.OnPreRender</code> method for the associated control.
                </td>
              </tr>
              <tr>
                <td>
                  <code>OnUnload</code>
                </td>
                <td>
                  Overrides the <code>System.Web.UI.Control.OnUnload</code> method for the associated control.
                </td>
              </tr>
              <tr>
                <td>
                  <code>Render</code>
                </td>
                <td>
                  Generates target-specific markup
                  for the control to which the adapter is attached. Takes a <code>System.Web.UI.HtmlTextWriter</code> object to render the target-specific output.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RenderChildren</code>
                </td>
                <td>
                  Generates the
                  target-specific markup for the child controls in a composite control to which
                  the adapter is attached. Takes a <code>System.Web.UI.HtmlTextWriter</code> object to render the target-specific output.
                </td>
              </tr>
              <tr>
                <td>
                  <code>SaveAdapterControlState</code>
                </td>
                <td>
                  Saves control
                  state information for the control adapter into a <code>StateBag</code>
                  object.
                </td>
              </tr>
              <tr>
                <td>
                  <code>SaveAdapterViewState</code>
                </td>
                <td>
                  Saves view state information for the control adapter into a <code>StateBag</code> object.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              You now have all the information
              you need in order to implement a custom control adapter. However, before the
              adapter can be used, it must be configured. Configuration depends on a device
              filter.
            </p>
            <p>
              The <code>System.Web.UI.WebControls.Adapters.WebControlAdapter</code> base class is the preferred way to change the behavior of built-in
              web controls. This class adds virtual methods <code>RenderBeginTag</code>, <code>RenderEndTag</code> and <code>RenderContents</code>, to more closely mirror the render behavior of WebControls.
            </p>
            <pre>
              public class WebControlAdapter : ControlAdapter
              {
                  protected WebControl Control { get; }
                  protected bool IsEnabled { get; }
                  protected virtual void RenderBeginTag(HtmlTextWriter writer);
                  protected virtual void RenderContents(HtmlTextWriter writer);
                  protected virtual void RenderEndTag(HtmlTextWriter writer);
              }
            </pre>
            <p>
              The following table explains its properties
              and methods.
            </p>
          </Element>
          <Element Type="Table" Name="WebControlAdapter">
            <table>
              <tr>
                <th>Member</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>Control</code>
                </td>
                <td>
                  The Web
                  control to which this adapter is attached.
                </td>
              </tr>
              <tr>
                <td>
                  <code>IsEnabled</code>
                </td>
                <td>
                  Indicates
                  whether the Web control and all its parent controls are enabled.
                </td>
              </tr>
              <tr>
                <td>
                  <code>Render</code>
                </td>
                <td>
                  Generates
                  the target-specific markup for the control to which the adapter is attached.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RenderBeginTag</code>
                </td>
                <td>
                  Creates the
                  beginning tag in the markup for the Web control.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RenderContents</code>
                </td>
                <td>
                  Generates the
                  target-specific inner markup for the Web control to which the adapter is
                  attached.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RenderEndTag</code>
                </td>
                <td>
                  Creates
                  the closing tag in the markup for the Web control.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              Note that the <code>WebControlAdapter</code> is not an abstract class but the basic class in the hierarchy of
              adapters responsible for regular WebControls. It’s in the <code>System.Web.UI.WebControls.Adapters</code> namespace. The <code>WebControlAdapter</code> class
              is the base class for the following implementations:
            </p>
            <ul>
              <li>
                <code>HierarchicalDataBoundControlAdapter</code>
              </li>
              <li>
                <code>DataBoundControlAdapter</code>
              </li>
              <li>
                <code>HideDisabledControlAdapter</code>
              </li>
              <li>
                <code>MenuAdapter</code>
              </li>
            </ul>
            <p>
              The <code>MenuAdapter</code>
              is a concrete implementation used to render <code>Menu</code>
              controls. The <code>HierarchicalDataBoundControlAdapter</code>
              provides a virtual method, <code>PerformDataBinding</code>,
              which calls <code>Control.PerformDataBinding</code>. Overriding
              this method in a derived class allows you to change the binding behavior. (This
              is also the case for the <code>DataBoundControlAdapter</code>
              class.) The <code>HideDisabledControlAdapter</code> can be
              applied to any control. Using this adapter removes the control from pages in
              which the control is disabled. It overrides the adapter’s <code>Render</code> method and, if its <code>Enabled</code> property is
              false, the control’s <code>Render</code> method is not
              called.
            </p>
          </Element>
          <Element Type="Image" Name="The class diagram for control adapter classes">
            images\19835f0902.tif
          </Element>
          <Element Type="Text">
            <p>
              The base classes can be used to
              perform basic tasks without you having to implement your own adapter. With them
              you can also vary a single behavior, such as data binding, while benefiting
              from all the other default adapter functionality.
            </p>
            <p>
              In the class diagram, you’ll also
              find a <code>PageAdapter</code> class that derives from <code>ControlAdapter</code>. Thus, pages can have adapters, too.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Using Page Adapters" >
          Using Page Adapters
          <Element Type="Text">
            <p>
              As a <code>Page</code> is essentially
              a specialized <code>Control</code>, the control adapter also
              supports pages. The <code>PageAdapter</code> base class
              exists to make writing a custom page adapter easy. This base class inherits
              from the <code>ControlAdapter</code> described earlier and extends the adapter with page-specific
              features.
            </p>
            <pre>
              public abstract class PageAdapter : ControlAdapter
              {

                  public virtual StringCollection CacheVaryByHeaders { get; }
                  public virtual StringCollection CacheVaryByParams { get; }
                  protected string ClientState { get; }
                  public virtual NameValueCollection DeterminePostBackMode();
                  protected internal virtual string GetPostBackFormReference(string formId);
                  public virtual ICollection GetRadioButtonsByGroup(string groupName);
                  public virtual PageStatePersister GetStatePersister();
                  public virtual void RegisterRadioButton(RadioButton radioButton);
                  public virtual void RenderBeginHyperlink(HtmlTextWriter writer,
                                                          
              string targetUrl,
              bool encodeUrl,
              string softkeyLabel);
                  public virtual void               RenderBeginHyperlink(HtmlTextWriter writer,
                                                          
              string targetUrl,
              bool encodeUrl,
              string softkeyLabel,
              string accessKey);
                  public virtual void              RenderEndHyperlink(HtmlTextWriter writer);
                  public virtual void               RenderPostBackEvent(HtmlTextWriter writer,
              string target,
              string argument,
              string softkeyLabel,
              string text);
                  public virtual void              RenderPostBackEvent(HtmlTextWriter writer,
              string target,

                                                          
              string argument,

                                                          
              string softkeyLabel,

                                                          
              string text,

                                                          
              string postUrl,

                                                          
              string accessKey);

                  protected void
              RenderPostBackEvent(HtmlTextWriter writer,

                                                          
              string target,

                                                          
              string argument,

                                                          
              string softkeyLabel,

                                                          
              string text,

                                                          
              string postUrl,

                                                          
              string accessKey,

                                                          
              bool encode);

                  public virtual string TransformText(string
              text);

              }
            </pre>
            <p>
              The following table explains the properties
              and methods provided by the <code>PageAdapter</code>. (The <code>PageAdapter</code> attaches to a web page. This is the “page” referred to in the table
              descriptions.)
            </p>
          </Element>
          <Element Type="Table" Name="Properties and methods in the PageAdapter, additional to those provided by the ControlAdapter">
            <table>
              <tr>
                <th>Member</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  <code>CacheVaryByHeaders</code>
                </td>
                <td>
                  A list (of type <code>IList</code>) of additional HTTP headers by which caching is varied for the Web
                  page.
                </td>
              </tr>
              <tr>
                <td>
                  <code>CacheVaryByParams</code>
                </td>
                <td>
                  A list (of type <code>IList</code>) of additional parameters from HTTP GET and POST requests by which caching
                  is varied for the Web page.
                </td>
              </tr>
              <tr>
                <td>
                  <code>ClientState</code>
                </td>
                <td>
                  An encoded string
                  containing the view and control state data of the Web page.
                </td>
              </tr>
              <tr>
                <td>
                  <code>DeterminePostBackMode</code>
                </td>
                <td>
                  Evaluates whether
                  the Web page is in postback mode and returns a name/value collection of type <code>System.Collections.Specialized.NameValueCollection</code> of the postback variables.
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetPostBackFormReference</code>
                </td>
                <td>
                  Returns
                  a DHTML code fragment that the client browser can use to reference the form on
                  the page that was posted.
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetRadioButtonsByGroup</code>
                </td>
                <td>
                  Retrieves
                  a collection of radio button controls specified by <code>groupName</code>. Takes the name of a <code>System.Web.UI.WebControls.RadioButton</code> group and returns an <code>ICollection</code>
                  object with <code>RadioButton</code> instances.
                </td>
              </tr>
              <tr>
                <td>
                  <code>GetStatePersister</code>
                </td>
                <td>
                  Returns a <code>PageStatePersister</code> object used by the Web page to maintain the control and view
                  states.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RegisterRadioButton</code>
                </td>
                <td>
                  Adds a radio
                  button control to the collection for a specified radio button group.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RenderBeginHyperlink</code>
                </td>
                <td>
                  Renders an
                  opening hyperlink tag, including the target URL, to the response stream. It takes
                  the current <code>TextWriter</code> instance to write the data.
                  This method is overloaded in order to support different sets of parameters.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RenderEndHyperlink</code>
                </td>
                <td>
                  Renders a
                  closing hyperlink tag to the response stream.
                </td>
              </tr>
              <tr>
                <td>
                  <code>RenderPostBackEvent</code>
                </td>
                <td>
                  Renders a PostBack
                  event to the response stream as a hyperlink, including the encoded and possibly
                  encrypted view state, and the event target and argument. This method is
                  overloaded to support different sets of parameters.
                </td>
              </tr>
              <tr>
                <td>
                  <code>TransformText</code>
                </td>
                <td>
                  Transforms text for the target browser.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              The <code>PageAdapter</code> supports the persistence layer and the render behavior of controls
              that group multiple tags. <code>RadioButtons</code> need
              special treatment when handling groups. You can define a group of radio buttons
              in HTML by giving them the same name. However, ASP.NET requires different IDs
              for each radio button, and by default the name and ID are the same. The <code>PageAdapter</code> will thus render each radio button group appropriately to keep the
              groups separate.
            </p>
            <p>
              The <code>GetStatePersister</code> property can be overloaded in order to change the view state
              persister globally. Using the abstract base class, you can write a custom page
              adapter to change the behaviour of all pages.
            </p>
            <p>
              But why does the rendering of
              a page depend on the client device? Remember that the view state has a strong
              influence on the client. The view state could grow and consume a significant portion
              of the page’s rendered content. (Refer to chapter 1 for a refresher about view
              state.) The user experience on mobile devices and smart phones generally
              deteriorates with large pages. To mitigate this, you could write a page adapter
              that creates a regular view state for PC based browsers and server-side view
              state for mobile devices.
            </p>
            <p>
              That implies that, as for <code>ControlAdapter</code> implementations, the <code>PageAdapter</code> must
              be configured and associated with a set of clients.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Device-Specific Filter for Adaptive Behavior" >
          Device-Specific Filter for Adaptive Behavior
          <Element Type="Text">
            <p>
              A device filter recognizes a client
              device and assigns a device-specific adapter to its controls. The filter can
              also identify control properties, user defined attributes and templates, and
              can be controlled with <code>@Page</code> and <code>@Control</code> directives. Recall that each control has a one-to-one relationship
              with an adapter, so if the filter returns several adapters, the most specific
              one is used.
            </p>
            <p>
              Device filters are based on browser
              definition files. You can find the default definition files in the folder:
            </p>
            <pre>
              %SystemRoot%\Microsoft.NET\Framework\v2.0.50727\CONFIG\Browsers
            </pre>
            <p>
              Browser files are used to create the <code>HttpBrowserCapabilities</code> object that exposes the device’s properties. The definitions form a
              hierarchy, preventing the files from redefining basic definitions. For
              instance, the <i>ie.browser</i> file contains several IE-related definitions. The
              following snippet shows settings specific to Internet Explorer:
            </p>
            <pre>
              &lt;browsers&gt;

                  &lt;browser id=&quot;IE&quot;
              parentID=&quot;Mozilla&quot;&gt;

                      &lt;identification&gt;

                          &lt;userAgent
              match=&quot;^Mozilla[^(]*\([C|c]ompatible;\s*MSIE
              (?'version'(?'major'\d+)(?'minor'\.\d+)(?'letters'\w*))(?'extra'[^)]*)&quot;
              /&gt;

                          &lt;userAgent nonMatch=&quot;Opera|Go\.Web|Windows
              CE|EudoraWeb&quot; /&gt;

                      &lt;/identification&gt;

                      &lt;capture&gt;

                      &lt;/capture&gt;

                      &lt;capabilities&gt;

                          &lt;capability
              name=&quot;browser&quot;              value=&quot;IE&quot; /&gt;

                          &lt;capability
              name=&quot;extra&quot;                value=&quot;${extra}&quot; /&gt;

                          &lt;capability
              name=&quot;isColor&quot;              value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;letters&quot;              value=&quot;${letters}&quot; /&gt;

                          &lt;capability
              name=&quot;majorversion&quot;         value=&quot;${major}&quot; /&gt;

                          &lt;capability
              name=&quot;minorversion&quot;         value=&quot;${minor}&quot; /&gt;

                          &lt;capability
              name=&quot;screenBitDepth&quot;       value=&quot;8&quot; /&gt;

                          &lt;capability
              name=&quot;type&quot;                 value=&quot;IE${major}&quot; /&gt;

                          &lt;capability name=&quot;version&quot;             
              value=&quot;${version}&quot; /&gt;

                      &lt;/capabilities&gt;

                  &lt;/browser&gt;

                  &lt;browser id=&quot;IE5to9&quot;
              parentID=&quot;IE&quot;&gt;

                      &lt;identification&gt;

                          &lt;capability
              name=&quot;majorversion&quot; match=&quot;^[5-9]&quot; /&gt;

                      &lt;/identification&gt;

                      &lt;capture&gt;

                      &lt;/capture&gt;

                      &lt;capabilities&gt;

                          &lt;capability
              name=&quot;activexcontrols&quot;     value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;backgroundsounds&quot;    value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;cookies&quot;             value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;css1&quot;                value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;css2&quot;                value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;ecmascriptversion&quot;   value=&quot;1.2&quot; /&gt;

                          &lt;capability
              name=&quot;frames&quot;              value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;javaapplets&quot;         value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;javascript&quot;          value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;jscriptversion&quot;      value=&quot;5.0&quot; /&gt;

                          &lt;capability
              name=&quot;msdomversion&quot;     

                                                    
              value=&quot;${majorversion}${minorversion}&quot; /&gt;

                          &lt;capability
              name=&quot;supportsCallback&quot;    value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;supportsFileUpload&quot;  value=&quot;true&quot; /&gt;

                          &lt;capability name=&quot;supportsMultilineTextBoxDisplay&quot;
              value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;supportsMaintainScrollPositionOnPostback&quot;

                                                     value=&quot;true&quot;
              /&gt;

                          &lt;capability
              name=&quot;supportsVCard&quot;       value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;supportsXmlHttp&quot;     value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;tables&quot;              value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;tagwriter&quot;     

                                                     value=&quot;System.Web.UI.HtmlTextWriter&quot;
              /&gt;

                          &lt;capability
              name=&quot;vbscript&quot;            value=&quot;true&quot; /&gt;

                          &lt;capability
              name=&quot;w3cdomversion&quot;       value=&quot;1.0&quot; /&gt;

                          &lt;capability
              name=&quot;xml&quot;                 value=&quot;true&quot; /&gt;

                      &lt;/capabilities&gt;

                  &lt;/browser&gt;

                  …

              &lt;/browsers&gt;
            </pre>
            <p>
              The filter consists of two
              parts. Firstly, the <code>userAgent</code> tag provides
              a <code>match</code> attribute which contains a regular expression. This expression is matched
              against the user-agent HTTP header sent by each client device.
            </p>
            <p>
              The capabilities section
              contains a setting for the preferred <code>tagwriter</code>,
              which you can use to assign a particular behavior when creating tags. This is
              much less common than using a full blown adapter, but is expedient if you
              simply want to write XHTML instead of HTML.
            </p>
          </Element>
          <Element Type="Image" Name="User Agent Settings for Internet Explorer">
            images\19835f0900.tif
          </Element>
          <Element Type="SideBar" SidebarType="Warning">
            <header>Warning</header>
            <aside>
              As the User Agent string can be fake, don’t trust the settings for security related activities.
            </aside>
          </Element>
          <Element Type="Text">
            <p>
              Adding client device filters can be accomplished
              on a per application basis using the <i>App_Browsers</i> folder. This is a special
              folder which can be added to any Web application project. Place a custom
              browser file into this folder and define device specific settings there.
            </p>
          </Element>
          <Element Type="Image" Name="Adding a *.browser file to the current project’s App_Browsers folder">
            images\19835f0901.tif
          </Element>
          <Element Type="Text">
            <p>
              The browser file has a similar
              structure to the default ones. The inheritance behavior is crucial. By using
              the right <code>parentID</code> attribute, you can inherit all common settings from an existing
              device and add or change a few values to match your current device.
            </p>
            <p>
              A typical file contains the
              following tags, at a minimum:
            </p>
            <pre>
              &lt;browsers&gt;

                  &lt;browser id=&quot;NewBrowser&quot;
              parentID=&quot;Mozilla&quot;&gt;

                      &lt;identification&gt;

                          &lt;userAgent match=&quot;Unique
              User Agent Regular Expression&quot; /&gt;

                      &lt;/identification&gt;

                      &lt;capture&gt;

                          &lt;userAgent match=&quot;NewBrowser
              (?'version'\d+\.\d+)&quot; /&gt;

                      &lt;/capture&gt;

                      &lt;capabilities&gt;

                          &lt;capability
              name=&quot;browser&quot; value=&quot;My New Browser&quot; /&gt;

                          &lt;capability
              name=&quot;version&quot; value=&quot;${version}&quot; /&gt;

                      &lt;/capabilities&gt;

                      &lt;controlAdapters
              markupTextWriterType=&quot;&quot;&gt;

                          &lt;adapter
              adapterType=&quot;&quot;

                                   controlType=&quot;&quot;
              /&gt;

                     &lt;/controlAdapters&gt;

                                             

                  &lt;/browser&gt;

                  &lt;browser refID=&quot;Mozilla&quot;&gt;

                      &lt;capabilities&gt;

                          &lt;capability name=&quot;xml&quot;
              value=&quot;true&quot; /&gt;

                      &lt;/capabilities&gt;

                  &lt;/browser&gt;

              &lt;/browsers&gt;
            </pre>
            <p>
              The types defined in the <code>controlAdapters</code> tag build the relationship between controls and adapters. They are
              specific to the current device. However, by using a common matching pattern,
              you can assign the filter to any device.
            </p>
            <p>
              While the <code>adapterType</code> is a type derived from the <code>System.Web.UI.Adapters.ControlAdapter</code>, the <code>controlType</code> must derive
              from <code>System.Web.UI.Control</code>. The <code>markupTextWriterType</code>
              attribute defines the writer to render the content. This type is instantiated
              and the object passed to the <code>Render</code> and <code>RenderChildren</code> methods of the control adapter. For an embedded control, this looks
              like:
            </p>
            <pre>
              &lt;controlAdapters
              markupTextWriterType=&quot;System.Web.UI.XhtmlTextWriter&quot; &gt;
                &lt;adapter
              controlType=&quot;System.Web.UI.WebControls.Menu&quot;
              adapterType=&quot;System.Web.UI.WebControls.Adapters.MenuAdapter&quot;&gt;
                &lt;/adapter&gt;
              &lt;/controlAdapters&gt;
            </pre>
          </Element>
          <Element Type="SideBar" SidebarType="Note">
            <header>Note</header>
            <aside>
              The browser capabilities
              file does not function for certain browser settings. The file matches the user
              agent string against a predefined set of properties. For instance, Internet
              Explorer supports JavaScript, hence the <code>HttpBrowserCapabilities</code> object returns true for that setting. If, however, a user disables
              JavaScript, this action does not change the property. You should read the
              object’s name literally—as a <b>capability</b> rather than as actual behavior.
            </aside>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Using Control Adapters" >
        Using Control Adapters
        <Element Type="Text">
          <p>
            There are several usage scenarios for
            adapters. In fact, adapters are one of the most powerful tools for extending
            control behavior.
          </p>
        </Element>
        <Element Type="Section" Name = "Device Friendly Adapters" >
          Device Friendly Adapters
          <Element Type="Text">
            <p>
              The main purpose of control adapters is
              to support specific client devices that do not function well with the standard HTML
              created by built-in controls. The intended behavior is defined within the
              .browser configuration file.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "CSS Friendly Adapters" >
          CSS Friendly Adapters
          <Element Type="Text">
            <p>
              When you read about adapters, you’ll often
              see the term “CSS friendly control adapters”. This wrongly implies that the
              adapter supports CSS (cascading style sheets). An adapter is simply an
              extensibility technique that allows page developers to alter the render
              behavior for all or particular client devices. Replacing pure HTML with CSS
              support is a common scenario, but it is not the only one supported by adapters.
              The reason for the name is the lack of CSS support in ASP.NET, and the development
              of adapters to overcome this limitation. For a sophisticated example of the
              usage of adapters to support CSS, refer to the website <i>www.asp.net/CSSAdapters</i>.
              This site offers a complete set of adapters using specific style definitions to
              format controls. The <code>MenuAdapter</code> shows how
              the replacement of <code>&lt;table&gt;</code> tags with
              nested <code>&lt;ul&gt;</code> tags and CSS styles, saves a lot of space and results in a freely
              configurable menu control. Other examples in the package support complex
              controls such as <code>FormView</code> and <code>TreeView</code>.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Other Adapter Ideas" >
          Other Adapter Ideas
          <Element Type="Text">
            <p>
              An adapter can output any kind of markup.
              It’s not limited to HTML or XHTML, and you can even create XAML to support WPF
              applications or Silverlight. (As this does sound strange, I’ll reiterate it so
              that you know it’s not a mistake.) It is possible to write a regular ASP.NET
              page consisting entirely of ASP.NET controls and render them in XAML—or anything
              else. The <code>TextWriter</code> class, used to add content to the output stream, writes text, whether
              or not it consists of markup. You can also use adapters to expose the source of
              a page by replacing the tags with <code>&amp;lt;</code> and
              <code>&amp;gt;</code> entities. I’ll demonstrate this in one of the following examples.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Writing a Custom Control Adapter" >
        Writing a Custom Control Adapter
        <Element Type="Text">
          <p>
            The following example shows how a
            custom control derived from a built-in control can be modified with an adapter.
          </p>
        </Element>
        <Element Type="Section" Name = "Steps for Creating the Example" >
          Steps for Creating the Example
          <Element Type="Text">
            <p>
              The example consists of the following
              parts:
            </p>
            <ul>
              <li>
                A custom control that adds two
                properties to the built-in CheckBoxList
              </li>
              <li>
                An adapter that changes the render
                behavior using these properties
              </li>
              <li>A page that uses the custom control</li>
              <li>
                A .browser file that assigns the
                adapter to the control
              </li>
            </ul>
          </Element>
        </Element>
        <Element Type="Section" Name = "The Example Code" >
          The Example Code
          <Element Type="Text">
            <p>
              The next code listing shows the custom
              control. The two properties store the names of the image resources. The purpose
              of the control is to display an image list. The control takes <code>ListItem</code> members, and instead of rendering <code>CheckBox</code>
              elements, two images are used—an OnImage if the item is selected (checked) and
              an OffImage otherwise.
            </p>
            <p>
              The control behaves as any standard
              <code>CheckBoxList</code> would. You can add <code>ListItems</code> and fill in
              the appropriate data. However, the adapter changes the render behavior to just display
              images. There is no treatment of content because the list is read-only, and the
              user can’t change anything or post back the data.
            </p>
            <p>
              Imagine that the adapter is used
              to render the control for devices that don’t allow interaction, such as a kiosk
              application. In that situation, a disabled <code>CheckBox</code>
              would look unprofessional.
            </p>
          </Element>
          <Element Type="Listing" Name="A custom control which modifies a built-in one">
            public class MyCheckBoxList : CheckBoxList
            {
                [Browsable(true)]
                public string OffImage
                {
                    get
                    {
                        if (ViewState[&quot;OffImage&quot;] == null)
                        {
                            OffImage = &quot;&quot;;
                        }
                        return (string)ViewState[&quot;OffImage&quot;];
                    }
                    set
                    {
                        ViewState[&quot;OffImage&quot;] = value;
                    }
                }

            [Browsable(true)]
                public string OnImage
                {
                    get
                    {
                        if (ViewState[&quot;OnImage&quot;]== null)
                        {

                            OnImage = &quot;&quot;;

                        }

                        return
            (string)ViewState[&quot;OnImage&quot;];

                    }

                    set

                    {

                        ViewState[&quot;OnImage&quot;] =
            value;

                    }

                }

            }
          </Element>
          <Element Type="Text">
            <p>
              This control has two additional properties.
              The images the properties refer to can be defined as embedded resources. To
              achieve this, use the <code>WebResourceAttribute</code> as
              follows:
            </p>
            <pre>
              [assembly: WebResourceAttribute(   
                        &quot;Apress.Extensibility.Adapters.Resources.OnImage.png&quot;, &quot;image/jpg&quot;)]
              [assembly: WebResourceAttribute(   
                        &quot;Apress.Extensibility.Adapters.Resources.OffImage.png&quot;,
              &quot;image/jpg&quot;)]
            </pre>
            <p>
              Furthermore, we’ll need a simple test
              scenario in order to get the control working. The code shown below is a snippet
              from an .aspx page. The attribute goes anywhere but inside a class,
              specifically the <i>AssemblyInfo.cs</i> file is a great place.
            </p>
          </Element>
          <Element Type="Listing" Name="A simple usage scenario">
            &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;
            &lt;div&gt;
                &lt;cc1:MyCheckBoxList
            ID=&quot;MyCheckBoxList1&quot; runat=&quot;server&quot;
            ControlOrientation=&quot;Horizontal&quot; BackColor=&quot;Red&quot;
            ForeColor=&quot;Blue&quot;&gt;
                &lt;/cc1:MyCheckBoxList&gt;
            &lt;/div&gt;
            &lt;/form&gt;
          </Element>
          <Element Type="Text">
            <p>
              The code behind file contains only the
              data source. To see the control in action, add a few <code>ListItems</code>, and choose images via the <code>Selected</code>
              property. If <code>Selected</code> equals <code>true</code>, OnImage is shown—otherwise, it’s OffImage.
            </p>
          </Element>
          <Element Type="Listing" Name="The code behind file adds a few items for testing purposes">
            public partial class _Default : System.Web.UI.Page
            {
                protected void Page_Load(object sender, EventArgs e)
                {
                    if (!IsPostBack)
                    {
                        var lic = newList&lt;ListItem&gt;();
                        lic.Add(new ListItem(&quot;Value
            1&quot;, &quot;1&quot;) { Selected = true });
                        lic.Add(new ListItem(&quot;Value
            2&quot;, &quot;2&quot;) { Selected = false });
                        lic.Add(new ListItem(&quot;V-alue
            3&quot;, &quot;3&quot;) { Selected = true });
                        lic.Add(new ListItem(&quot;Value
            4&quot;, &quot;4&quot;) { Selected = false });
                        MyCheckBoxList1.Items.AddRange(lic.ToArray());
                    }
                }
            }
          </Element>
          <Element Type="Text">
            <p>
              Last, but not least, the adapter is
              required. This renders the control through a reference to the control, using the
              appropriate Render methods.
            </p>
          </Element>
          <Element Type="Listing" Name="The adapter creates images and labels instead of checkbox controls">
            public class MyCheckBoxListAdapter :System.Web.UI.WebControls.Adapters.WebControlAdapter
            {
                private MyCheckBoxList CheckBoxListControl
                {
                    get
                    {
                        return ((MyCheckBoxList)Control);
                    }
                }

            protected override void enderBeginTag(System.Web.UI.HtmlTextWriter writer)
                {

                    writer.WriteLine();

                    writer.WriteBeginTag(&quot;table&quot;);

                    writer.Write(HtmlTextWriter.TagRightChar);

                    writer.Indent++;

                }

                protected override void
            RenderEndTag(System.Web.UI.HtmlTextWriter writer)

                {

                    writer.WriteEndTag(&quot;table&quot;);

                    writer.WriteLine();

                    writer.Indent--;

                }

                protected override void RenderContents(System.Web.UI.HtmlTextWriter
            writer)

                {

                    switch
            (CheckBoxListControl.RepeatDirection)

                    {

                        case RepeatDirection.Horizontal:

                           
            writer.WriteBeginTag(&quot;tr&quot;);

                            writer.Indent++;

                           
            writer.Write(HtmlTextWriter.TagRightChar);

                            for (int i = 0; i &lt;
            CheckBoxListControl.Items.Count; i++)

                            {

                               
            writer.WriteBeginTag(&quot;td&quot;);

                               
            writer.Write(HtmlTextWriter.TagRightChar);

                                RenderCheckbox(writer, i);

                               
            writer.WriteEndTag(&quot;td&quot;);

                            }

                           
            writer.WriteEndTag(&quot;tr&quot;);

                            writer.Indent--;

                            break;

                        case RepeatDirection.Vertical:

                            for (int i = 0; i &lt;
            CheckBoxListControl.Items.Count; i++)

                            {

                               
            writer.WriteBeginTag(&quot;tr&quot;);

                               
            writer.Write(HtmlTextWriter.TagRightChar);

                               
            writer.WriteBeginTag(&quot;td&quot;);

                                writer.Write(HtmlTextWriter.TagRightChar);

                                RenderCheckbox(writer, i);

                               
            writer.WriteEndTag(&quot;td&quot;);

                               
            writer.WriteEndTag(&quot;tr&quot;);

                            }

                            break;

                    }

                }

                private void RenderCheckbox(HtmlTextWriter
            writer, int i)

                {

                    Image img = new Image();

                    Label l = new Label();

                    if
            (CheckBoxListControl.Items[i].Selected)

                    {

                        img.ImageUrl =
            Page.ClientScript.GetWebResourceUrl(this.GetType(),

                           
            String.Format(&quot;Apress.Extensibility.Adapters.Resources.{0}.png&quot;,

                            CheckBoxListControl.OnImage));

                        l.Text = String.Format(&quot;{0}
            (on) &quot;,

                           
            CheckBoxListControl.Items[i].Text);

                    }

                    else

                    {

                        img.ImageUrl =
            Page.ClientScript.GetWebResourceUrl(this.GetType(),

                           
            String.Format(&quot;Apress.Extensibility.Adapters.Resources.{0}.png&quot;,

                            CheckBoxListControl.OffImage));

                        l.Text = String.Format(&quot;{0}
            (off) &quot;,

                           
            CheckBoxListControl.Items[i].Text);

                    }

                    img.ToolTip =
            CheckBoxListControl.Items[i].Value;

                    img.RenderControl(writer);

                    l.RenderControl(writer);

                }

            }
          </Element>
          <Element Type="Text">
            <p>
              A <code>CheckBoxList</code> supports a <code>RenderDirection</code>
              property, which has several more features not fully supported by this example.
              To obtain the right render direction, a table is used that either grows to the
              right by adding <code>&lt;td&gt;</code> tags, or
              downwards using <code>&lt;tr&gt;&lt;td&gt;</code>
              pairs. The private <code>RenderCheckbox</code> method
              is used to create the content. To simplify this, built-in controls are employed
              and their internal <code>Render</code> method is used
              through the public <code>RenderControl</code> method. This
              ensures that the other adapters responsible for <code>Image</code> and <code>Label</code> controls will work as expected.
            </p>
            <p>
              In the example, an embedded
              resource is used, and the properties the custom control exposes are accessed in
              order to obtain the correct resource. The assembly attributes (<code>WebResourceAttribute</code>) described previously define the embedded
              resources, which are retrieved by means of the <code>GetWebResourceUrl</code> method.
            </p>
            <p>
              When building HTML, it’s often
              necessary to write parts of a tag, empty lines, or other characters. The <code>HtmlTextWriter</code> class has several public constant values to support such
              characters. The following table explains these:
            </p>
          </Element>
          <Element Type="Table" Name="Constant characters and strings, as defined in HtmlTextWriter">
            <table>
              <tr>
                <th>Constant</th>
                <th>Character</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>
                  DefaultTabString
                </td>
                <td>
                </td>
                <td>
                  Represents
                  a single tab character.
                </td>
              </tr>
              <tr>
                <td>
                  DoubleQuoteChar 
                </td>
                <td>&quot;</td>
                <td>
                  Represents
                  the quotation mark (&quot;) character.
                </td>
              </tr>
              <tr>
                <td>
                  EndTagLeftChars
                </td>
                <td> &lt;/ </td>
                <td>
                  Represents
                  the left angle bracket and slash mark of the closing tag
                </td>
              </tr>
              <tr>
                <td>
                  EqualsChar
                </td>
                <td>=</td>
                <td>
                  Represents the
                  equals sign.
                </td>
              </tr>
              <tr>
                <td>
                  EqualsDoubleQuoteString
                </td>
                <td>=&quot;&quot;</td>
                <td>
                  Represents
                  an equals sign with a double quotation mark
                </td>
              </tr>
              <tr>
                <td>
                  SelfClosingChars
                </td>
                <td>/</td>
                <td>
                  Represents
                  a space and the self-closing slash mark of a markup tag
                </td>
              </tr>
              <tr>
                <td>
                  SelfClosingTagEnd
                </td>
                <td>/&gt;</td>
                <td>
                  Represents
                  the closing slash mark and right angle bracket of a self-closing tag.
                </td>
              </tr>
              <tr>
                <td>
                  SemicolonChar
                </td>
                <td>;</td>
                <td>Represents a semicolon.</td>
              </tr>
              <tr>
                <td>
                  SingleQuoteChar
                </td>
                <td>'</td>
                <td>
                  Represents
                  an apostrophe.
                </td>
              </tr>
              <tr>
                <td>
                  SlashChar
                </td>
                <td>/</td>
                <td>
                  Represents a
                  forward slash.
                </td>
              </tr>
              <tr>
                <td>
                  SpaceChar 
                </td>
                <td> </td>
                <td>
                  Represents a
                  space character.
                </td>
              </tr>
              <tr>
                <td>
                  StyleEqualsChar
                </td>
                <td>:</td>
                <td>
                  Represents the
                  style equals character used to set style attributes equal to values.
                </td>
              </tr>
              <tr>
                <td>
                  TagLeftChar
                </td>
                <td>&lt;</td>
                <td>
                  Represents
                  the opening angle bracket of a markup tag.
                </td>
              </tr>
              <tr>
                <td>TagRightChar</td>
                <td>&gt; </td>
                <td>
                  Represents the closing angle bracket of a markup tag.
                </td>
              </tr>
            </table>
          </Element>
          <Element Type="Text">
            <p>
              The code should now run as expected. Figure
              9-5 illustrates the output of the preceding example.
            </p>
          </Element>
          <Element Type="Image" Name="A CheckBoxList that displays images">
            images\19835f0904.tif
          </Element>
          <Element Type="Text">
            <p>
              Although the result may seem unimpressive,
              my intention was to demonstrate how to modify the render behavior of an
              existing control. The benefit here is that the other parts of the control that do
              not affect rendering still function as expected. Developers can choose between using
              this or another render behavior, depending on their application’s needs or
              device capabilities. Imagine that a very basic client can’t render checkboxes,
              but it can render images. Creating a new <code>CheckBoxList</code>
              control would require a lot more work than simply editing the adapter.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Why Use HtmlTextWriter?" >
          Why Use HtmlTextWriter?
          <Element Type="Text">
            <p>
              You may be wondering why the <code>HtmlTextWriter</code> plays such an important role. After all, when building HTML, the <code>StringBuilder</code> is frequently the better and faster alternative. There are several reasons.
              Firstly, the <code>HtmlTextWriter</code> has a number of useful
              predefined characters and strings, as shown in Table 9-4. Secondly, it handles
              indentation well when formatting HTML line by line. This would require
              additional code with <code>StringBuilder</code>. Thirdly,
              it is associated with the output stream, which means that the content is
              written directly to the output (<code>Response.OutputStream</code>).
              This is the fastest way to transmit the response to the Web server.
            </p>
            <p>
              However, there are some disadvantages to
              the <code>HtmlTextWriter</code>. If you create your own <code>HtmlTextWriter</code>, you might associate it with a <code>StringWriter</code>/<code>StringBuilder</code> pair in order to retrieve the content. But using the writer exposed
              by the adapter classes, you can’t access the stream with anything but write
              access, and any attempt to read the content will fail.
            </p>
          </Element>
        </Element>
        <Element Type="Section" Name = "Configure the Example" >
          Configure the Example
          <Element Type="Text">
            <p>
              To configure the code, you only need to
              make an entry in a .browser file. For this example, I define a file called <i>MyClient.browser</i>
              and place it in the default folder for browser definition files, <i>App_Browser</i>.
            </p>
            <pre>
              &lt;browsers&gt;
                &lt;browser refID=&quot;Default&quot;&gt;
                  &lt;controlAdapters&gt;
                    &lt;adapter adapterType=&quot;Apress.Extensibility.Adapters.MyCheckBoxListAdapter&quot;
                             controlType=&quot;Apress.Extensibility.Adapters.MyCheckBoxList&quot;
              /&gt;
                  &lt;/controlAdapters&gt;
                &lt;/browser&gt;
              &lt;/browsers&gt;
            </pre>
            <p>
              This is everything you need. Launch the
              application and the adapter will start working.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Writing a Custom Page Adapter" >
        Writing a Custom Page Adapter
        <Element Type="Text">
          <p>
            A <code>PageAdapter</code>
            is like a <code>ControlAdapter</code> in that it’s the preferred way to change the behavior of a page
            without altering either markup or code. As explained previously, pages are
            responsible not only for the rendering process but also for saving view state
            and for several life cycle events. A typical usage scenario involves the view
            state behavior under specific circumstances. For example, if a client device has
            a low-bandwidth connection, sending the view state to the client and back
            during postback will result in disappointed users.
          </p>
          <p>
            However, to demonstrate creating a
            custom page adapter I will tackle a simplified scenario.
          </p>
        </Element>
        <Element Type="Section" Name = "Steps for Creating the Example" >
          Steps for Creating the Example
          <Element Type="Text">
            <p>
              The <code>PageAdapter</code> functions
              exactly like the <code>ControlAdapter</code>. You’ll
              need the adapter class and a .browser file in order to configure it. The next
              listing shows the code which writes the page’s source at the end of the page:
            </p>
          </Element>
          <Element Type="Listing" Name="Simple PageAdapter to append page source">
            public class SourcePageAdapter : PageAdapter
            {
                protected override void EndRender(System.Web.UI.HtmlTextWriter writer)
                {

                    StreamReader sr = File.OpenText(
                                   this.Page.Server.MapPath(this.Page.Request.Url.LocalPath));
            writer.WriteFullBeginTag(&quot;pre&quot;);
            this.Page.Server.HtmlEncode(sr.ReadToEnd(), writer);
                    sr.Close();
            writer.WriteEndTag(&quot;pre&quot;);           
                    base.EndRender(writer);
                }
            }
          </Element>
          <Element Type="Text">
            <p>
              The writer is used to write the page’s
              content from a <code>StreamReader</code> object. This contains page
              code read directly from the disk. The example assumes that the page is
              available.
            </p>
          </Element>
          <Element Type="SideBar" SidebarType="Note">
            <header>Note</header>
            <aside>
              The example writes the
              content after all regular content, including the closing &lt;html&gt; tag. This
              results in invalid HTML. However, all common browsers render this, despite the
              discrepancy.
            </aside>
          </Element>
          <Element Type="Image" Name="The page used for the ControlAdapter example and content exposed by the page adapter">
            images\19835f0905.tif
          </Element>
          <Element Type="Text">
            <p>
              The configuration activates this for all
              clients. Imagine a workstation that you have configured for testing purposes. On
              it you have set the User-agent string manually in order to send a private key
              to the server. The .browser file recognizes this private key and activates the
              adapter only for requests from the testing computer. It will be the only client
              to receive the content rendered with source. Everyone else will see only the conventional
              page output. You won’t need to set anything in <i>web.config</i>, or in code, or
              anywhere else.
            </p>
          </Element>
          <Element Type="SideBar" SidebarType="Warning">
            <header>Warning</header>
            <aside>
              Several examples recommend
              calling the RenderChildren method in order to send the rendered content of a
              page to a private TextWriter. This would not work with an adapter, as the
              adapter would be summoned again for the subsequent call, which would lead to an
              endless loop and eventually to a <code>StackOverflowException</code>.
            </aside>
          </Element>
          <Element Type="Text">
            <p>
              The next example shows another way to
              play with HtmlTextWriter. Instead of exposing the server-side source I want
              expose the HTML send to client below the page.
            </p>
          </Element>
          <Element Type="Listing" Name="PageAdapter to append rendered Page Source">
            public class ClientSourcePageAdapter :
            PageAdapter

            {

                HtmlTextWriter internalWriter;

                HtmlTextWriter newWriter;

                StringBuilder sb;

                protected override void
            BeginRender(HtmlTextWriter writer)

                {

                    internalWriter = writer;

                    sb = new StringBuilder();

                    newWriter = new HtmlTextWriter(new
            StringWriter(sb));

                    base.BeginRender(newWriter);

                }

                protected override void
            Render(HtmlTextWriter writer)

                {

                    base.Render(newWriter);

                    string html = sb.ToString();

                    writer.Write(html);

                    writer.WriteBeginTag(&quot;pre&quot;);

                    writer.Write(HtmlTextWriter.SpaceChar);

                    writer.WriteAttribute(&quot;style&quot;,
            &quot;border:solid 1px blue&quot;);

                    writer.Write(HtmlTextWriter.TagRightChar);

                    writer.WriteEncodedText(html);

                    writer.WriteEndTag(&quot;pre&quot;);

                }

            }
          </Element>
          <Element Type="Text">
            <p>
              The original writer is now replaced by a
              custom one in the <code>BeginRender</code> method. In
              Render it allows you to access your own writer instance and write the content
              to a string using <code>ToString</code> of the <code>StringBuilder</code> object. Firstly, the string is written back to the original writer.
              The remaining part creates a <code>&lt;pre&gt;</code> tag and a
              border style to place the encoded content in.
            </p>
          </Element>
          <Element Type="Image" Name="The page used for the ControlAdapter example and rendered content exposed by the page adapter">
            images\19835f0906.tif
          </Element>
          <Element Type="Text">
            <p>
              Both examples are very limited in their
              capabilities. They show the basic principiples as well as the power you get
              when dealing on a low level with the content. However, keep in mind that
              changing the render behavior is an option to extend ASP.NET when needed.
            </p>
            <Element Type="SideBar" SidebarType="Warning">
              <header>Warning</header>
              <aside>
                Before considering the usage
                of adapters the common techniques should be tried first. The complete render
                framework is complex and you might experience weird behavior when not
                implementing it either completely or wrong.
              </aside>
            </Element>
          </Element>
        </Element>
        <Element Type="Section" Name = "Configure the Examples" >
          Configure the Examples
          <Element Type="Text">
            <p>
              To configure the code, you’ll just need
              to make an entry in a .browser file. In the first example, I define a file
              called <i>MyClient.browser</i> and place it in the default folder for browser
              definition files, <i>App_Browser</i>.
            </p>
            <pre>
              &lt;browsers&gt;
                &lt;browser refID=&quot;Default&quot;&gt;
                  &lt;controlAdapters&gt;
                    &lt;adapter
              adapterType=&quot;Apress.Extensibility.Adapters.SourcePageAdapter&quot;
              controlType=&quot;System.Web.UI.Page&quot; /&gt;
                  &lt;/controlAdapters&gt;
                &lt;/browser&gt;
              &lt;/browsers&gt;
            </pre>
            <p>
              This is everything you need. Launch
              the application and the adapter will start working. If you combine the
              PageAdaper with the ControlAdapter example shown previously, you can put two <code>&lt;adapter&gt;</code> tags within the same <code>&lt;controlAdapters&gt;</code> section. The only reason to split it into several sections or files
              is to activate it for different kinds of client devices.
            </p>
            <p>
              For the second example simply
              replace the class name <code>SourcePageAdapter</code> with <code>ClientSourcePageAdapter</code> to activate this.
            </p>
          </Element>
        </Element>
      </Element>
      <Element Type="Section" Name = "Summary" >
        <Element Type="Text">
          <p>
            In this chapter, you looked at a method
            of extending a core part of ASP.NET—control rendering. Using adapters, you can
            assign relationships between a control and its adapter. Adapters can change
            render behavior, persistence of view state and control state, and the treatment
            of controls during specific states of their life cycle.
          </p>
          <p>
            Page adapters are specialized
            control adapters supporting alternative behavior of the page’s render and state
            persistence processes.
          </p>
          <p>
            Adapters can be used in
            conjunction with device filters in order to render controls differently for
            devices that can’t handle ordinary HTML. Mobile devices especially suffer when
            it comes to large view states, complex content with several levels of nested
            tables, or other content originally designed for powerful machines. Using
            control adapters allows you to replace render behavior with a lean, device-specific
            version, without changing application code, page markup, or your custom
            controls.
          </p>
        </Element>
      </Element>
    </Element>
  </Element>
</Content>